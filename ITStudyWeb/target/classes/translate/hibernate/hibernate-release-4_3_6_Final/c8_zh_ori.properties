
#		**********************************************************************************************************
#		Chapter 8. Association Mappings
#		**********************************************************************************************************

title8 = 第八章. 关联映射

#		**********************************************************************************************************
#		8.1. Introduction
#		**********************************************************************************************************

title8-1 = 8.1. 介绍
p8-1-1 = 关联关系映射通常情况是最难配置正确的。在这一节中我们首先从单向映射开始，然后考虑双向关系映射。这一章中，<code>Person</code> 和 <code>Address</code>两个类将贯穿始终。
p8-1-2 = 我们根据映射关系是否涉及连接表以及多样性来划分关联类型。
p8-1-3 = 在传统数据模型中，可以为空的外键不被认为是一种好的实践方法，所以我们的例子中不会使用可以为空的外键。这对Hibernate来说不是必须的，即使你去除非空约束，映射依然能够正常运行。

#		**********************************************************************************************************
#		8.2. Unidirectional associations
#		**********************************************************************************************************

title8-2 = 8.2. 单向关联

#		**********************************************************************************************************
#		8.2.1. Many-to-one
#		**********************************************************************************************************

title8-2-1 = 8.2.1. 多对一
p8-2-1-1 = 一个单向多对一关联是最常见的单向关联关系。

#		**********************************************************************************************************
#		8.2.2. One-to-one
#		**********************************************************************************************************

title8-2-2 = 8.2.2. 一对一
p8-2-2-1 = 基于外键关联的单向一对一关联和单向多对一关联几乎是一样的。唯一的不同就是单向一对一关联中的外键字段具有唯一性约束。
p8-2-2-2 = 基于主键关联的单向一对一关联通常使用一个特定的id生成器。（请注意，在这个例子中我们掉换了关联的方向。）

#		**********************************************************************************************************
#		8.2.3. One-to-many
#		**********************************************************************************************************

title8-2-3 = 8.2.3. 一对多
p8-2-3-1 = 基于外键的单向一对多是不常见的，也是不被推荐的做法。
p8-2-3-2 = 你应该使用外联表来替代这种做法。

#		**********************************************************************************************************
#		8.3. Unidirectional associations with join tables
#		**********************************************************************************************************

title8-3 = 8.3. 使用链接表的单向关联

#		**********************************************************************************************************
#		8.3.1. One-to-many
#		**********************************************************************************************************

title8-3-1 = 8.3.1. One-to-many
p8-3-1-1 = 使用连接表的单向的一对多推荐使用。指定<code>unique="true"</code>, 来把many-to-many 修改为 one-to-many。

#		**********************************************************************************************************
#		8.3.2. Many-to-one
#		**********************************************************************************************************

title8-3-2 = 8.3.2. Many-to-one
p8-3-2-1 = 基于连接表的单向多对一关联在关联关系可选的情况下应用也很普遍。例如:

#		**********************************************************************************************************
#		8.3.3. One-to-one
#		**********************************************************************************************************

title8-3-3 = 8.3.3. One-to-one
p8-3-3-1 = 基于连接表的单向一对一关联非常少见，但也是可行的。

#		**********************************************************************************************************
#		8.3.4. Many-to-many
#		**********************************************************************************************************

title8-3-4 = 8.3.4. Many-to-many
p8-3-4-1 = 最后，还有 单向多对多关联。

#		**********************************************************************************************************
#		8.4. Bidirectional associations
#		**********************************************************************************************************

title8-4 = 8.4. 双向关联

#		**********************************************************************************************************
#		8.4.1. one-to-many / many-to-one
#		**********************************************************************************************************

title8-4-1 = 8.4.1. one-to-many / many-to-one
p8-4-1-1 = 双向多对一关联 是最常见的关联关系。下面的例子阐明了标准的 parent/child 关系。
p8-4-1-2 = 如果你使用<code>List</code>, 或者其他的有序集合, 需要设置外键对应的key列为not null。让 Hibernate 从集合端来管理关联。维护每个元素的索引，通过使用<code>update="false"</code> 和 <code>insert="false"</code>来对一端反向操作:
p8-4-1-3 = 如果集合映射的key元素对应的底层外键字段是 NOT NULL的, 那么为这一 <code>&lt;key&gt;</code>元素定义 not-null="true"是很重要的。不要仅仅为可能的嵌套<code>&lt;column&gt;</code>元素定义 <code>not-null="true"</code>，<code>&lt;key&gt;</code>元素也是需要的。

#		**********************************************************************************************************
#		8.4.2. One-to-one
#		**********************************************************************************************************

title8-4-2 = 8.4.2. One-to-one
p8-4-2-1 = 基于外键关联的双向一对一关联也很常见:
p8-4-2-2 = 基于主键关联的一对一关联需要使用特定的id生成器。

#		**********************************************************************************************************
#		8.5. Bidirectional associations with join tables
#		**********************************************************************************************************

title8-5 = 8.5. 使用链接表的双向关联

#		**********************************************************************************************************
#		8.5.1. one-to-many / many-to-one
#		**********************************************************************************************************

title8-5-1 = 8.5.1. one-to-many / many-to-one
p8-5-1-1 = 下面是一个基于链接表的一对多关联。 <code>inverse="true"</code> 可以出现在任意一端, 集合端或者join端。

#		**********************************************************************************************************
#		8.5.2. one to one
#		**********************************************************************************************************

title8-5-2 = 8.5.2. one to one
p8-5-2-1 = 一个双向的一对一关联也可以使用连接表，但是不常见。

#		**********************************************************************************************************
#		8.5.3. Many-to-many
#		**********************************************************************************************************

title8-5-3 = 8.5.3. Many-to-many
p8-5-3-1 = 下面是一个双向的多对多关联的例子。

#		**********************************************************************************************************
#		8.6. More complex association mappings
#		**********************************************************************************************************

title8-6 = 8.6. 更复杂的关联映射
p8-6-1 = 更加复杂的关联链接极为罕见。 通过在映射文档中嵌入SQL片断，Hibernate也可以处理更为复杂的情况。例如, 假若包含历史帐户数据的表定义了 <code>accountNumber</code>, <code>effectiveEndDate</code> 和 <code>effectiveStartDatecolumns</code>, 将会按照下面映射:
p8-6-2 = 那么我们可以对目前(current)实例(其effectiveEndDate为null)使用这样的关联映射:
p8-6-3 = 在更复杂的示例中, 假想<code>Employee</code>和<code>Organization</code>之间的关联是通过一个Employment中间表维护的，而中间表中填充了很多历史雇员数据。那“雇员的最新雇主”这个关联（最新雇主就是startDate最后的那个）可以这样映射：
p8-6-4 = 使用这一功能时可以充满创意，但通常更加实用的是用HQL或条件查询来处理这些情形。































