
#		**********************************************************************************************************
#		Chapter 27. Database Portability Considerations
#		**********************************************************************************************************

title27 = 第二十七章. 数据库可移植性

#		**********************************************************************************************************
#		27.1. Portability Basics
#		**********************************************************************************************************

title27-1 = 27.1. 可移植性基础
p27-1-1 = Hibernate的一大卖点（包括所有的关系/对象型数据库）就是它强大的可移植性。这意味着一个IT用户能够轻松的更换数据库，或者可以开发出一个框架，来为这个框架的使用者提供多数据库服务。不管具体的需求是什么，最基本的原因是你希望在不改动任何代码以及映射数据的情况下就能够迁移数据库。

#		**********************************************************************************************************
#		27.2. Dialect
#		**********************************************************************************************************

title27-2 = 27.2. 方言
p27-2-1 = Hibernate有关可移植性的第一行就是方言，也就是<code>org.hibernate.dialect.Dialect</code>。Hibernate为了完成特定任务对不同的数据库的操作是不同的（比如SELECT语句），方言则封装了所有的这些不同点。Hibernate为绝大多数流行的数据库进行了处理。如果你发现你特定的数据库不在其中，那么你自己写一个也不是特比的难。

#		**********************************************************************************************************
#		27.3. Dialect resolution
#		**********************************************************************************************************

title27-3 = 27.3. 方言解决方案
p27-3-1 = 最开始，Hibernate要求用户必须明确指定方言。当用户想同时作用与多个数据库的简历，这是有问题的。一般遇到这种情况，就需要用户去配置Hiberante方言或者自定义方法来设置值。
p27-3-2 = 从3.2版本开始，Hibernate开始出现自动探测方言的概念，通过使用从数据库的<code>java.sql.Connection</code>获得的<code>java.sql.DatabaseMetaData</code>来实现这一概念。这样就变得好多了，但是存在的问题在于Hibernate必须提前知道数据库，并且不能被配置或重写。
p27-3-3 = 从3.3版本开始，Hiberante有了更加强力的方法来自动探测方言：通过一个类中一系列的代理来实现，这个类实现了只有一个方法的接口<code>org.hibernate.dialect.resolver.DialectResolver</code>：
p27-3-4 = 这里最基础的原理是：如果解析器知道数据库，那么直接返回相对应的方言；如果不知道就返回null并交给下个解析器。The signature also identifies <code>org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver.
p27-3-5 = 这些解析器cool的地方在于用户可以自定义自己的解析器，并在其他Hibernate内建解析器之前执行。这在许多不同的情况下十分有用：它可以轻松的整合方言自动检测和Hibernate本身自带的解析器；它可以在Hibernate知道这个数据库的时候指定自己的方言；等等。要注册一个或者多个解析器，只需要使用'hibernate.dialect_resolvers'配置它们就可以了。

#		**********************************************************************************************************
#		27.4. Identifier generation
#		**********************************************************************************************************

title27-4 = 27.4. 生成标示符
p27-4-1 = 当考虑到数据库的可移植性时，另一个十分重要的决定是选择你想要的id生成策略。最开始Hibernate提供了native生成器，这个生成器的目的在于根据底层数据库，从序列，id或者表策略中选择一个。然而，这个方式存在一个问题，就是一些数据库支持id生成策略，而另一些并不支持。id的生成依赖与SQL定义的id（或者自增长）列的值；这是一个插入之后生成策略，因为我们只有在插入一条数据之后才能知道它的id值。由于Hibernate需要靠这个值来区分持久上下文中的引用对象，所以在用户请求将实体类分配到session（比如调用save()方法时）时，不管当前事务语义如何都必须立刻执行插入。
nc27-4-1 = Hibernate轻微的做了些改变：只有当可行时延迟插入。
p27-4-2 = 底层的问题在于真实的应用程序语义或根据情况而改变。
p27-4-3 = 从3.2.3版本开始，Hibernate引入了多种不同的id生成策略。
nc27-4-2 = 下面指定了2中生成方式绑定：
li27-4-1-1 = org.hibernate.id.enhanced.SequenceStyleGenerator
li27-4-1-2 = org.hibernate.id.enhanced.TableGenerator
p27-4-4 =生成器的意义在于根据实际的语义为不同的数据库生成id。比如，<code>org.hibernate.id.enhanced.SequenceStyleGenerator</code>适合于不支持表的序列化的数据库。

#		**********************************************************************************************************
#		27.5. Database functions
#		**********************************************************************************************************

title27-5 = 27.5. 数据库函数
wc27-5-1 = 这是Hibernate需要提高的地方。处于可移植性考虑，在方法处理方便，HQL做的很好；但是却在其他方面做的十分欠缺。
p27-5-1 = 用户可以有很多方式引用SQL的方法SQL。然而，不是所有的数据库都支持同样的方法。Hibernate提供了许多映射，来将逻辑方法映射到具体的方法，有可能是完全不同的物理方法。
ic27-5-1 = 技术上讲，这个通过<code>org.hibernate.dialect.function.SQLFunctionRegistry</code>注册的方法意图在于允许用户在提供自定义的方法而不需要指定方言。这一行为还没有完全完成。<br/>这种类型的实现使得用户可以使用<code>org.hibernate.cfg.Configuration</code>动态的注册方法，并且这些方法也会注册到HQl上。

#		**********************************************************************************************************
#		27.6. Type mappings
#		**********************************************************************************************************

title27-6 = 27.6. 类型映射
p27-6-1 = 这一章节内容将会晚些完成并发布。。。




