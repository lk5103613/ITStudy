
#		**********************************************************************************************************
#		Chapter 22. Additional modules
#		**********************************************************************************************************

title22 = Chapter 22. Additional modules

#		**********************************************************************************************************
#		22.1. Bean Validation
#		**********************************************************************************************************

title22-1 = 22.1. Bean Validation
p22-1-1 = Bean Validation standardizes how to define and declare domain model level constraints. You can, for example, express that a property should never be null, that the account balance should be strictly positive, etc. These domain model constraints are declared in the bean itself by annotating its properties. Bean Validation can then read them and check for constraint violations. The validation mechanism can be executed in different layers in your application without having to duplicate any of these rules (presentation layer, data access layer). Following the DRY principle, Bean Validation and its reference implementation Hibernate Validator has been designed for that purpose.
p22-1-2 = The integration between Hibernate and Bean Validation works at two levels. First, it is able to check in-memory instances of a class for constraint violations. Second, it can apply the constraints to the Hibernate metamodel and incorporate them into the generated database schema.
p22-1-3 = Each constraint annotation is associated to a validator implementation responsible for checking the constraint on the entity instance. A validator can also (optionally) apply the constraint to the Hibernate metamodel, allowing Hibernate to generate DDL that expresses the constraint. With the appropriate event listener, you can execute the checking operation on inserts, updates and deletes done by Hibernate.
p22-1-4 = When checking instances at runtime, Hibernate Validator returns information about constraint violations in a set of <code>ConstraintViolations</code>. Among other information, the <code>ConstraintViolation</code> contains an error description message that can embed the parameter values bundle with the annotation (eg. size limit), and message strings that may be externalized to a <code>ResourceBundle</code>.

#		**********************************************************************************************************
#		22.1.1. Adding Bean Validation
#		**********************************************************************************************************

title22-1-1 = 22.1.1. Adding Bean Validation
p22-1-1-1 = To enable Hibernate's Bean Validation integration, simply add a Bean Validation provider (preferably Hibernate Validation 4) on your classpath.

#		**********************************************************************************************************
#		22.1.2. Configuration
#		**********************************************************************************************************

title22-1-2 = 22.1.2. Configuration
p22-1-2-1 = By default, no configuration is necessary.
p22-1-2-2 = The Default group is validated on entity insert and update and the database model is updated accordingly based on the Default group as well.
p22-1-2-3 = You can customize the Bean Validation integration by setting the validation mode. Use the <code>javax.persistence.validation.mode</code> property and set it up for example in your persistence.xml file or your <code>hibernate.cfg.xml</code> file. Several options are possible:
li22-1-2-1-1 = <code>auto</code> (default): enable integration between Bean Validation and Hibernate (callback and ddl generation) only if Bean Validation is present in the classpath.
li22-1-2-1-2 = <code>none</code>: disable all integration between Bean Validation and Hibernate
li22-1-2-1-3 = <code>callback</code>: only validate entities when they are either inserted, updated or deleted. An exception is raised if no Bean Validation provider is present in the classpath.
li22-1-2-1-4 = <code>ddl</code>: only apply constraints to the database schema when generated by Hibernate. An exception is raised if no Bean Validation provider is present in the classpath. This value is not defined by the Java Persistence spec and is specific to Hibernate.
nc22-1-2-1 = You can use both <code>callback</code> and <code>ddl</code> together by setting the property to callback, dll
nc22-1-2-2 = This is equivalent to <code>auto</code> except that if no Bean Validation provider is present, an exception is raised.
p22-1-2-4 = If you want to validate different groups during insertion, update and deletion, use:
li22-1-2-2-1 = <code>javax.persistence.validation.group.pre-persist</code>: groups validated when an entity is about to be persisted (default to <code>Default</code>)
li22-1-2-2-2 = <code>javax.persistence.validation.group.pre-update</code>: groups validated when an entity is about to be updated (default to <code>Default</code>)
li22-1-2-2-3 = <code>javax.persistence.validation.group.pre-remove</code>: groups validated when an entity is about to be deleted (default to no group)
li22-1-2-2-4 = <code>org.hibernate.validator.group.ddl</code>: groups considered when applying constraints on the database schema (default to Default)
p22-1-2-5 = Each property accepts the fully qualified class names of the groups validated separated by a comma (,)
nc22-1-2-3 = You can set these properties in <code>hibernate.cfg.xml</code>, <code>hibernate.properties</code> or programmatically.

#		**********************************************************************************************************
#		22.1.3. Catching violations
#		**********************************************************************************************************

title22-1-3 = 22.1.3. Catching violations
p22-1-3-1 = If an entity is found to be invalid, the list of constraint violations is propagated by the <code>ConstraintViolationException</code> which exposes the set of <code>ConstraintViolations</code>.
p22-1-3-2 = This exception is wrapped in a <code>RollbackException</code> when the violation happens at commit time. Otherwise the <code>ConstraintViolationException</code> is returned (for example when calling flush(). Note that generally, catchable violations are validated at a higher level (for example in Seam / JSF 2 via the JSF - Bean Validation integration or in your business layer by explicitly calling Bean Validation).
p22-1-3-3 = An application code will rarely be looking for a <code>ConstraintViolationException</code> raised by Hibernate. This exception should be treated as fatal and the persistence context should be discarded (<code>EntityManager</code> or <code>Session</code>).

#		**********************************************************************************************************
#		22.1.4. Database schema
#		**********************************************************************************************************

title22-1-4 = 22.1.4. Database schema
p22-1-4-1 = Hibernate uses Bean Validation constraints to generate an accurate database schema:
li22-1-4-1-1 = <code>@NotNull</code> leads to a not null column (unless it conflicts with components or table inheritance)
li22-1-4-1-2 = <code>@Size.max</code> leads to a <code>varchar(max)</code> definition for Strings
li22-1-4-1-3 = <code>@Min</code>, <code>@Max</code> lead to column checks (like value <= max)
li22-1-4-1-4 = <code>@Digits</code> leads to the definition of precision and scale (ever wondered which is which? It's easy now with @Digits :) )
p22-1-4-2 = These constraints can be declared directly on the entity properties or indirectly by using constraint composition.
p22-1-4-3 = For more information check the Hibernate Validator reference documentation at <a href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html/">http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html/</a>

#		**********************************************************************************************************
#		22.2. Hibernate Search
#		**********************************************************************************************************

title22-2 = 22.2. Hibernate Search

#		**********************************************************************************************************
#		22.2.1. Description
#		**********************************************************************************************************

title22-2-1 = 22.2.1. Description
p22-2-1-1 = Full text search engines like Apache Lucene are a very powerful technology to bring free text/efficient queries to applications. If suffers several mismatches when dealing with a object domain model (keeping the index up to date, mismatch between the index structure and the domain model, querying mismatch...) Hibernate Search indexes your domain model thanks to a few annotations, takes care of the database / index synchronization and brings you back regular managed objects from free text queries. Hibernate Search is using <a href="http://lucene.apache.org/">Apache Lucene</a> under the covers.

#		**********************************************************************************************************
#		22.2.2. Integration with Hibernate Annotations
#		**********************************************************************************************************

title22-2-2 = 22.2.2. Integration with Hibernate Annotations
p22-2-2-1 = Hibernate Search integrates with Hibernate Core transparently provided that the Hibernate Search jar is present on the classpath. If you do not wish to automatically register Hibernate Search event listeners, you can set <code>hibernate.search.autoregister_listeners</code> to false. Such a need is very uncommon and not recommended.
p22-2-2-2 = Check the Hibernate Search reference documentation ( <a href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html/">http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html/</a> ) for more information.















