
#		**********************************************************************************************************
#		Chapter 20. Improving performance
#		**********************************************************************************************************

title20 = 第二十章. 提升性能

#		**********************************************************************************************************
#		20.1. Fetching strategies
#		**********************************************************************************************************

title20-1 = 20.1. 抓取策略
p20-1-1 = 当应用程序需要操纵关联的时候，Hibernate所使用的获取关联对象的策略。抓取策略可以在 O/R 映射元数据中声明，也可以在特定的HQL或者条件查询中被重载。
p20-1-2 = Hibernate 定义了一下的抓取策略:
li20-1-1-1 = <code>链接抓取</code>: Hibernate通过在<code>SELECT</code>语句中使用<code>OUTER JOIN</code>来获取对象的关联实例或者关联集合。
li20-1-1-2 = <code>查询抓取</code>: 另外一条<code>SELECT</code>语句抓取当前对象的关联实体或者集合。除非你显示的指定<code>lazy="false"</code>来禁止延迟抓取，否则，只有当你真正访问关联关系的时候，才会执行第二条select语句。
li20-1-1-3 = <code>子查询抓取</code>: 另外发送一条<code>SELECT</code>语句抓取在前面查询或者抓取到的所有实体对象的关联集合。除非你显示的指定<code>lazy="false"</code>来禁止延迟抓取，只有在你真正访问关联的时候才会执行第二条select语句。
li20-1-1-4 = <code>批量抓取</code>: 对查询抓取的优化方案。通过指定一个逐渐或者外键列表，Hibernate使用单条select语句获取一批对象或者实例。
p20-1-3 = Hibernate 会区分以下各种情况:
li20-1-2-1 = <code>立即抓取</code>: 当宿主被加载时，关联、集合或者属性被立即抓取。
li20-1-2-2 = <code>延迟集合抓取</code>: 当应用对集合执行了一次操作时，集合才被抓取。对集合而言这是默认行为。
li20-1-2-3 = <code>"Extra-lazy"集合抓取</code>: 对集合的每个元素而言，都是知道需要时采取访问数据库。除非绝对必要，Hibernate 不会试图去把整个应用加载到内存中，适用于非常大的集合。
li20-1-2-4 = <code>代理抓取</code>: 对返回单值的关联而言，当其某个方法被调用，而非对其关键字进行get操作时才抓取。
li20-1-2-5 = <code>非代理抓取</code>: 对于返回单值的关联而言， 当实例变量被访问的时候进行抓取。与上面的代理抓取相比，这种方法没有那么延迟的厉害。就算至访问标示符，也会导致关联抓取。但是这种方式更加的透明，因为对于应用程序来说，不在看到proxy。这种方法徐璈在便一起减进行字节码增强操作，因此很少使用。
li20-1-2-6 = <code>属性延迟加载</code>: 对属性或者返回单值的关联而言，当其实例变量被访问的时候进行抓取。这种方法需要字节码强化，因此这一方法很少需要。
p20-1-4 = 这里我们有两个正交的概念：关联合适被抓取，以及如何被抓取。不要混淆他们。我们使用抓取来改善性能。我们可以使用延迟来定义一些约定，对某个特定类的某个托管的实例，知道有哪些数据是可以使用的。

#		**********************************************************************************************************
#		20.1.1. Working with lazy associations
#		**********************************************************************************************************

title20-1-1 = 20.1.1. 使用延迟加载的关联
p20-1-1-1 = 默认情况下, Hibernate 对集合使用延迟select抓取， 对返回单值的关联使用延迟代理抓取。对几乎是所有的应用而言，其绝大多数的关联，这种策略是有效的。
p20-1-1-2 = 如果你设置了 <code>hibernate.default_batch_fetch_size</code>, Hibernate会对延迟加载采取批量抓取优化措施。这种优化也可能会在更细化的级别打开。
p20-1-1-3 = 然而，你必须了解延迟抓取带来的一个问题。在一个打开的Hibernate session上下文之外调用延迟集合会导致一次意外。比如：
p20-1-1-4 = 因为在session关闭之后，permissions集合还没实例化完成，因此集合无法正常载入其状态。对于托管对象，Hibernate不支持延迟实例化，修改方法是，将permissions读取数据的代码移到事务提交之前。
p20-1-1-5 = 除此之外, 通过关联映射指定 <code>lazy="false"</code> ，我们也可以使用非延迟的集合或关联。但是，对绝大部分集合来说。更推荐使用延迟方式抓取数据。如果在你的对象模型中定义了太多的非延迟关联，Hibernate最终几乎需要在每个事务中载入整个数据库到内存中。
p20-1-1-6 = 另一方面，在一些特殊的事务中，我们也经常需要使用到连接抓取，以替代查询抓取。下面我们将会很快明白如何具体的指定Hibernate中的抓取策略。子Hibernate中，具体选择哪种抓取策略的机制是和选择单只关联或者集合关联一致的。

#		**********************************************************************************************************
#		20.1.2. Tuning fetch strategies
#		**********************************************************************************************************

title20-1-2 = 20.1.2. 调整抓取策略
p20-1-2-1 = 查询抓取 (默认的) 在N+1查询的情况下是及其脆弱的，因此我们可能会要求在映射文档中定义使用连接抓取：
p20-1-2-2 = 在映射文档中定义的 <code>fetch</code> 策略将会对以下列表条目产生影响：
li20-1-2-1-1 = 通过<code>get()</code> 或者 <code>load()</code>方法取得数据
li20-1-2-1-2 = 只有在关联之间进行导航时，才会隐式的取得数据
li20-1-2-1-3 = 条件查询
li20-1-2-1-4 = 使用了<code>subselect</code>抓取策略的HQL 查询 
p20-1-2-3 = 不管你使用哪种抓取策略，定义为非延迟的类图会被保证一定装载入内存。注意这可能意味着在一条HQL查询后紧跟着一系列的查询。 
p20-1-2-4 = 通常情况下,不适用映射文件定制抓取策略，更多的是保持其默认值，然后再特定的事务中，使用HQL的左连接对其进行重载。这将通知Hibernate在第一次查询中使用外部关联，直接得到其关联数据库。在条件查询中，应该使用 <code>setFetchMode(FetchMode.JOIN)</code>。
p20-1-2-5 = 如果你想改变 <code>get()</code> 或者 <code>load()</code>的抓取策略, 你可以使用条件查询。例如:
p20-1-2-6 = 这就是其他ORM解决方案的“抓取计划”在Hibernate中的等价物。
p20-1-2-7 = 截然不同的一种避免N+1次查询的方法是使用二级缓存。

#		**********************************************************************************************************
#		20.1.3. Single-ended association proxies
#		**********************************************************************************************************

title20-1-3 = 20.1.3. 单端关联代理
p20-1-3-1 = 在Hibernate中，对集合的延迟抓取采用了自己的实现方法。但是对于单端关联的延迟抓取，则需要采用其他不同的机制。单端关联的目标实体必须使用代理，Hibernate在运行期二进制级，为持久对象实现了延迟载入代理。
p20-1-3-2 = 默认的Hibernate将会为所有的持久化对象在启动阶段产生代理, 然后使他们实现 <code>many-to-one</code> 和 <code>one-to-one</code> 关联的延迟抓取。
p20-1-3-3 = 在映射文件中，可以通过设置proxy属性为目标class声明一个接口共代理接口使用。默认的，Hibernate将会使用该类的一个子类。 被代理的类必须实现一个至少包可见的默认构造参数，建议所有的持久化类都应该拥有这样的构造函数。
p20-1-3-4 = 当时使用这种方式定义一个多态类的时候，有许多值得注意的常见性问题，例如：
p20-1-3-5 = 首先, Cat 实例永远不可以被强制转换为DomesticCat, 即使它本身就是<code>DomesticCat</code>实例:
p20-1-3-6 = 其次, 代理" =="可能不在成立:
p20-1-3-7 = 然而, 实际情况并没有看上去那么糟糕。虽然我们现在有两个不同的引用分别指向这两个不同的代理对象，但实际上，其底层应该是一个实例对象：
p20-1-3-8 = 第三, 你不能对<code>final</code>类或者具有 <code>final</code>方法的类使用cglib代理。
p20-1-3-9 = 最后, 如果你的持久化对象在实例化时需要某些资源(例如在实例化方法或者默认的构造方法中)，那么代理对象也同样需要使用这些资源。实际上代理类是持久化类的子类。
p20-1-3-10 = 这些问题又源于Java的单根继承模型的天生的限制。如果你希望避免这种问题。那么你的每一个持久化类必须实现一个借口，在此接口中已经声明了其业务方法。然后，你需要在映射文档中在指定这些借口，这里<code>CatImpl</code> 实现了<code>Cat</code>接口并且 <code>DomesticCatImpl</code> 实现了<code>DomesticCat</code>接口。例如:
p20-1-3-11 = 在<code>load()</code> 或者 <code>iterate()</code>方法中就会返回 Cat 和 DomesticCat 的代理对象。
nc20-1-3-1 = <code>list()</code> 通常不返回代理。
p20-1-3-12 = 对象之间的关联也是被延迟载入的。这意味着你应该将属性声明为<code>Cat</code>而不是 <code>CatImpl</code>。
p20-1-3-13 = 某些方法中是不需要使用代理的：
li20-1-3-1-1 = <code>equals()</code>: 如果持久化类没有重载<code>equals()</code>方法
li20-1-3-1-2 = <code>hashCode()</code>: 如果持久化类没有重载<code>hashCode()</code>方法
li20-1-3-1-3 = 标示符的getter方法
p20-1-3-14 = Hibernate 将会识别出那些重载了<code>equals()</code> 或者 <code>hashCode()</code>方法的持久化类
p20-1-3-15 = 如果选择 <code>lazy="no-proxy"</code> 而非默认的<code>lazy="proxy"</code>, 我们可以避免类型转换带来的问题。然而，这样我们就需要编译器字节码增强，并且所有的操作都会导致立刻进行代理初始化。
#		**********************************************************************************************************
#		20.1.4. Initializing collections and proxies
#		**********************************************************************************************************

title20-1-4 = 20.1.4. 实例化集合和代理
p20-1-4-1 = 在Session范围之外访问未初始化的集合或代理，Hibernate将会抛出A <code>LazyInitializationException</code> 异常, 也就是说，在分离状态下，访问一个实体所拥有的集合，或者访问其指向代理的属性时，都会引发此异常。
p20-1-4-2 = 有时候我们需要保证某个代理或者集合在Session关闭之http://dict.cn/前就已经被初始化。当然，也可以通过强行调用<code>cat.getSex()</code> 或 <code>cat.getKittens().size()</code>方法来确保这一点。但是这样的程序会造成读者的疑惑，也不符合通常的代码规范。
p20-1-4-3 = 静态方法<code>Hibernate.initialize()</code> 和 <code>Hibernate.isInitialized()</code>, 为你的程序提供了一个便捷的途径来延迟加载集合或代理。 只要它的Session处于open状态，<code>Hibernate.initialize(cat)</code>将会为cat强制对代理实例化。 <code>Hibernate.initialize( cat.getKittens() )</code>对kittens的集合具有同样的功能。
p20-1-4-4 = 还有另外一种选择，就是保持Session一直处于open状态，直到所有需要的集合或代理都被载入。在某些应用架构中，特别是对于那些使用Hibernate进行数据访问的代码，以及那些在不同应用层和不同物理进程中使用Hibernate的代码在集合实例化时，如何保证Session处于open状态经常会是一个问题。有两种方法可以解决此问题：
li20-1-4-1-1 = 在一个基于Web的应用中，可以利用servlet过滤器（filter），在用户请求（request）结束、页面生成 结束时关闭Session。 (在显示层打开Session模式). 当然，这将依赖于应用框架中异常需要被正确的处理。在返回界面给用户之前，乃至在生成界面过程中发生异常的情况下，正确关闭Session和结束事务将是非常重要的，请参见Hibernate wiki上的"Open Session in View"模式，你可以找到示例。
li20-1-4-1-2 = 在一个拥有单独业务层的应用中，业务层必须在返回之前，为web层“准备”好其所需的数据集合。 这就意味着 业务层应该载入所有表现层/web层所需的数据，并将这些已实例化完毕的数据返回。通常，应用程序应该 为web层所需的每个集合调用<code>Hibernate.initialize()</code> 方法(这个调用必须发生咱session关闭之前)。或者使用带有<code>FETCH</code>从句，或<code>FetchMode.JOIN</code> 的Hibernate查询，事先取得所有的数据集合。如果你在应用中使用了Command模式，代替Session Facade	 ，那么这项任务将会变得简单的多。
li20-1-4-1-3 = 你也可以通过<code>merge()</code> 或<code>lock()</code>方法，在访问未实例化的集合（或代理）之前， 为先前载入的对象绑定一个新的Session。显然，Hibernate将不会，也不应该自动完成这些任务，因为这将引入一个特殊的事务语义。
p20-1-4-5 = 有时候，你并不需要完全实例化整个大的集合，仅需要了解它的部分信息（例如其大小）、或者集合的部分内容。
p20-1-4-6 = 你可以使用集合过滤器得到其集合的大小，而不必实例化整个集合：
p20-1-4-7 = 这里的 <code>createFilter()</code> 方法也可以被用来有效的抓取集合的部分内容，而无需实例化整个集合：

#		**********************************************************************************************************
#		20.1.5. Using batch fetching
#		**********************************************************************************************************

title20-1-5 = 20.1.5. 使用批量抓取
p20-1-5-1 = Hibernate可以充分有效的使用批量抓取，也就是说，如果仅一个访问代理（或集合），那么Hibernate将不载入其他未实例化的代理。 批量抓取是延迟查询抓取的优化方案，你可以在两种批量抓取方案之间进行选择：在类级别和集合级别。
p20-1-5-2 = 类/实体级别的批量抓取很容易理解。假设你在运行时将需要面对下面的问题：在运行时你在一个Session中载入了25个 <code>Cat</code>实例，每个Cat实例都拥有一个引用成员owner，其指向<code>Person</code>，而Person类是代理，同时lazy="true"。如果你必须遍历整个cats集合，对每个元素调用<code>getOwner()</code>方法，Hibernate将会默认的执行25次SELECT查询，得到其owner的代理对象，这时，你可以通过在映射文件的 <code>Person</code>属性，显式声明<code>batch-size</code> ，改变其行为：
p20-1-5-3 = 通过指定 <code>batch-size</code>,当需要访问未经初始化的代理时，Hibernate将会立即执行查询，如上，但是区别在于他将会立刻查询更多的person's owner 而不是直接查询代理实体。因此， 当访问其他person的 owner时，他可能已经使用批量查询通过很少的（少于25）查询语句被初始化。
p20-1-5-4 = 这种行为通过配置batch-size和批量抓取风格来控制。批处理抓取风格配置( <code>hibernate.batch_fetch_style</code> )从4.2.0开始有性能上的提升，这里提供了三种不同的策略，包括legacy, padded 和 dynamic。
lip20-1-5-1-1-1 = <code>LEGACY</code>
lip20-1-5-1-1-2 = 在传统的算法中，我们保留了一组基于<code>org.hibernate.internal.util.collections.ArrayHelper#getBatchSizes</code>的预先建立的一个批量大小。批次会使用已存在的和预构建的批量大小中比较小的那个的批量值。
lip20-1-5-1-1-3 = 在上面的例子中，定义了 batch-size为 25 ，预设值的batch 大小可以是 [25, 12, 10, 9, 8, 7, .., 1]。
lip20-1-5-1-1-4 = 因为这里有25个 persons' owner 需要被初始化。那么将会使用这25个owner的标示符，只执行一条查询语句即可。
lip20-1-5-1-1-5 = 但是另一个例子中, 假设只有24人，Hibernate将只需要执行三次查询，分别为12, 10, 2。查询如下：
lip20-1-5-1-2-1 = <code>PADDED</code>
lip20-1-5-1-2-2 = 这种方式类似于legacy 算法, 他也是用基于的 <code>org.hibernate.internal.util.collections.ArrayHelper#getBatchSizes</code>预建立的batch大小。区别是，Hibernate将会使用下一个比较大的batch大小，并且填充额外的标示符占位符。
lip20-1-5-1-2-3 = 因此, 同样使用上面的例子,初始化 25 个person,查询将会和上面一样，查询所有的owner将会只执行一条查询语句。
lip20-1-5-1-2-4 = 然而, 尝试加载24个owner只需要一个 批量为25的查询，加载的标示符将会被“填充”（又名，重复）来弥补差距。
lip20-1-5-1-3-1 = <code>DYNAMIC</code>
lip20-1-5-1-3-2 = 根据现有Id的实际数量动态的生成SQL，是否仍然会限制实体上决定的批量大小。
p20-1-5-5 = 你也可以在集合级别定义批量抓取。例如，如果每个<code>Person</code>都有一个懒加载的 <code>Cats</code>集合, 并且已经有10个Persion加载入Session，遍历所有的Persion将会执行10次Select语句，对于每一次调用 <code>getCats()</code>getCats方法。如果你在 <code>Person</code>的映射中启用<code>cats</code>集合的批量抓取，Hibernate可以预先抓取整个集合:
p20-1-5-6 = 例如, 如果把 <code>batch-size</code> 设置为3并且 使用传统的批量风格, Hibernate将会使用四条select语句，分别加载3, 3, 3, 1 条集合。再次，属性的值取决于预期的未初始化的<code>Session</code>的数量。
p20-1-5-7 = 如果你的模型中含有树状结构，集合的批量抓取是非常有用的，即，典型的bill-of-materials 模式。然而，对于一个需要经常读取的树状结构，使用嵌套的set或者物理路径也许是更好的选择。

#		**********************************************************************************************************
#		20.1.6. Using subselect fetching
#		**********************************************************************************************************

title20-1-6 = 20.1.6. 使用子查询抓取
p20-1-6-1 = 如果一个延迟集合或单值代理需要抓取，Hibernate会使用一个子查询冲讯运行原来的查询，一次性的读入所有的实例，这和批量抓取的实现方法一样，不会有破碎的加载。

#		**********************************************************************************************************
#		20.1.7. Fetch profiles
#		**********************************************************************************************************

title20-1-7 = 20.1.7. 读取配置文件
p20-1-7-1 = 另一种影响抓取策略加载相关联的对象的方式是通过读取配置文件, 他是和<code>org.hibernate.SessionFactory</code>关联的命名配置，并且通过名称在<code>org.hibernate.Session</code>中启用, 除非明确的禁止，那么读取配置文件将会影响 <code>org.hibernate.Session</code>。
p20-1-7-2 = 这是什么意思呢？下面我们来通过实例来解释，在这个示例中展示了不同的抓取配置文件的方式：
p20-1-7-3 = 现在，通常当你引用一个特定的customer,customer的订单将会被懒加载，这意味着我们现在还没有从数据库中加载订单。一般情况下这是好事，现在我们可以说在某些情况下在加载customer的同时加载订单更有效。其中一种方式是通过HQL或者条件查询使用“动态抓取”策略，但是另一种选择是使用一个抓取配置文件来实现。下面的代码将会同时加载customer和他们的订单：
nc20-1-7-1 = <code>@FetchProfile</code> 的定义是全局的，并且和放置在那个类没有关系。你可以把<code>@FetchProfile</code> 注解放在一个类上或者包上(package-info.java)。可以使用<code>@FetchProfiles</code>来为相同的类或者包定义多个抓取配置文件。
p20-1-7-4 = 目前只支持join风格的抓取配置文件，但是他们的计划是支持更多的风格。参考  <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-3414">HHH-3414</a> 查看详细信息。

#		**********************************************************************************************************
#		20.1.8. Using lazy property fetching
#		**********************************************************************************************************

title20-1-8 = 20.1.8. 使用延迟属性抓取
p20-1-8-1 = Hibernate支持单个属性的延迟抓取。这项优化技术称之为组抓取。请注意，该技术更多的属于市场特性；在实际应用中，优化行读取比优化列读取更重要。然而，仅加载类的部分属性在某些特定情况下会有用，例如，在原有表中有几百列数据、数据模型无法改善的情况下。
p20-1-8-2 = 在映射文件中对特定的属性设置lazy，定义该属性为延迟载入：
p20-1-8-3 = 属性的延迟载入要求在其代码构建时加入二进制指示指令，如果你的持久类代码中没有这些指令，Hibernate将会忽略这些属性的延迟设置，仍然将其直接载入。
p20-1-8-4 = 你可以在Ant的task中，进行如下定义，对持久类代码加入二进制指令：
p20-1-8-5 = 还有一种可以优化的方法，它使用HQL或条件查询的投影特性，可以避免读取非必要的列，这一点至少对只读事务是非常有用的。 它无需在代码构建时“二进制指令”处理，因此是一个更加值得选择的解决方法。
p20-1-8-6 = 有时你需要在HQL中通过抓取所有属性，强行抓取所有内容。

#		**********************************************************************************************************
#		20.2. The Second Level Cache
#		**********************************************************************************************************

title20-2 = 20.2. 二级缓存
p20-2-1 = Hibernate的<code>Session</code>在事务级别进行持久化数据的缓存操作。当然也可以为每个类配置集群，或者JVM级别（SessionFactory级别）的缓存。 你甚至尅为之插入一个集群的缓存。注意，缓存永远不知道其他应用程序对持久化仓库可进行的修改，及时可以将缓存数据设置为定期失效。 
p20-2-2 = 通过在<code>hibernate.cache.provider_class</code>中指定<code>org.hibernate.cache.spi.CacheProvider</code>的某个实现类的名字，你可以选择让Hibernate使用哪个缓存实现。Hibernate打包一些开源缓存实现，提供对他们的内置支持。参见表 <a href="##cacheproviders">Table 20.1, \u201C缓存提供商\u201D</a>。你也可以实现你自己的实现，将他们插入到系统中。注意在3.2版本之前，默认使用EhCache作为缓存实现。
p20-2-3 = <strong>Table 20.1. 缓存提供商</strong>
th20-2-1-1 = Cache
th20-2-1-2 = Provider class
th20-2-1-3 = Type
th20-2-1-4 = Cluster Safe
th20-2-1-5 = Query Cache Supported
td20-2-1-1 = ConcurrentHashMap (only for testing purpose, in hibernate-testing module)
td20-2-1-2 = org.hibernate.testing.cache.CachingRegionFactory
td20-2-1-3 = memory
td20-2-1-4 = 
td20-2-1-5 = yes
td20-2-1-6 = EHCache
td20-2-1-7 = org.hibernate.cache.ehcache.EhCacheRegionFactory
td20-2-1-8 = memory, disk, transactional, clustered
td20-2-1-9 = yes
td20-2-1-10 = yes
td20-2-1-11 = Infinispan
td20-2-1-12 = org.hibernate.cache.infinispan.InfinispanRegionFactory
td20-2-1-13 = clustered (ip multicast), transactional
td20-2-1-14 = yes (replication or invalidation)
td20-2-1-15 = yes (clock sync req.)

#		**********************************************************************************************************
#		20.2.1. Cache mappings
#		**********************************************************************************************************

title20-2-1 = 20.2.1. 缓存映射
p20-2-1-1 = 正如我们在前面章节中所做的，我们在研究配置缓存的两种不同的方式。一种方式是使用注解，另外一种方式是使用Hibernate映射文件。
p20-2-1-2 = 默认情况下,实体木事二级缓存的一部分，而且我们推荐你坚持这种设定。然而，你可以通过在<code>persistence.xml</code>文件中设置<code>shared-cache-mode</code> 元素或者在 你的配置中使用<code>javax.persistence.sharedCache.mode</code>属性来修改这种设定。下面的值是可用的：
li20-2-1-1-1 = <code>ENABLE_SELECTIVE</code> (默认的并且是推荐的值): 除非明确的标记为可缓存，否则不进行缓存。
li20-2-1-1-2 = <code>DISABLE_SELECTIVE</code>: 除非明确的标记为不缓存，否则对实体进行缓存。
li20-2-1-1-3 = <code>ALL</code>: 即使标注为不缓存，也要缓存所有的实体。
li20-2-1-1-4 = <code>NONE</code>:即使标注为可缓存，也不缓存所有的实体。这个选项可以完全禁用二级缓存。
p20-2-1-3 = 通过设置<code>hibernate.cache.default_cache_concurrency_strategy</code> 属性可以指定默认的缓存策略。这个属性的值可以是:
li20-2-1-2-1 = <code>read-only</code>
li20-2-1-2-2 = <code>read-write</code>
li20-2-1-2-3 = <code>nonstrict-read-write</code>
li20-2-1-2-4 = <code>transactional</code>
nc20-2-1-1 = 建议为每一个实体定义缓存并发策略，而不是使用全局的。可以使用<code>@org.hibernate.annotations.Cache</code>注解来实现。
p20-2-1-4 = 如果集合中包含实体，Hibernate也允许你缓存集合的内容或者标示符。需要在集合属性上使用 <code>@Cache</code>注解；
p20-2-1-5 = <a href="#example-cache-annotation-with-attributes">Example 20.7, \u201C @Cache 及属性\u201D</a>展示了 <code>@org.hibernate.annotations.Cache</code> 注解和它的属性。
td20-2-1-1-1 = <code>usage</code>: 给定的缓存并发策略 (NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)
td20-2-1-1-2 = <code>region</code> (可选): 缓存的区域名 (默认是类或者集合的名字)
td20-2-1-1-3 = <code>include</code> (可选): all 用于包含所有的属性， non-lazy 只包含非延迟属性，默认是all.
p20-2-1-6 = 下面我们来看看Hibernate映射文件。 类或者集合映射中的<code>&lt;cache&gt;</code>元素用于配置二级缓存。查看 <a href="#example-hibernate-cache-mapping-element">Example 20.8, \u201CHibernate &lt;cache&gt; 映射元素\u201D</a> ，显然和注解时相似的。
td20-2-1-2-1 = <code>usage</code> (必须) 指定抓取策略: <code>transactional</code>, <code>read-write</code>, <code>nonstrict-read-write</code> 或者 <code>read-only</code> 
td20-2-1-2-2 = <code>region</code> (可选: 默认是类或者集合的名字):指定二级缓存的区域名
td20-2-1-2-3 = <code>include</code> (可选: 默认是 all) <code>non-lazy</code>: 当属性级延迟加载打开时，标记为<code>lazy="true"</code>的实体的属性可能无法被缓存。
p20-2-1-7 = 此外<code>&lt;cache&gt;</code>, 你可以在<code>hibernate.cfg.xml</code>中指定 <code>&lt;class-cache&gt;</code> 和 <code>&lt;collection-cache&gt;</code> 元素。
p20-2-1-8 = 下面我们详细看一下usage策略

#		**********************************************************************************************************
#		20.2.2. Strategy: read only
#		**********************************************************************************************************

title20-2-2 = 20.2.2. 策略: 只读
p20-2-2-1 = 如果你的应用程序需要读取一个持久化类的实例，而无需对其修改，那么可以对其进行只读缓存。这是最简单也是实用性最好的方法。甚至在集群中，它也能完美的运作。

#		**********************************************************************************************************
#		20.2.3. Strategy: read/write
#		**********************************************************************************************************

title20-2-3 = 20.2.3. Strategy: 读/写
p20-2-3-1 = 如果应用程序需要更新数据，那么使用<code>读-写</code>缓存比较合适。如果应用程序需要“序列化事务”隔离级别，那么足额不能使用这种缓存策略。如果在JTA环境中使用缓存，你必须指定<code>hibernate.transaction.manager_lookup_class</code> 属性的值， 通过它，Hibernate才能知道该应用程序中JTA的TransactionManager的具体策略。在其他环境中，你必须保证在调用<code>Session.close()</code> 或者 <code>Session.disconnect()</code> 之前，事务已经结束。如果你想在集群环境中使用此策略，你必须保证底层的缓存实现支持说定。Hibernate内置的缓存策略并不支持锁定。

#		**********************************************************************************************************
#		20.2.4. Strategy: nonstrict read/write
#		**********************************************************************************************************

title20-2-4 = 20.2.4. 策略: 非严格 读/写
p20-2-4-1 = 如果你的应用只需要偶尔更新数据 (也就是说，两个事务同时更新同一个记录的情况很不常见), 并且也不需要十分严格的事务隔离，那么比较适合使用 <code>nonstrict-read-write</code>策略。如果在JTA中使用该策略，米不许指定  <code>hibernate.transaction.manager_lookup_class</code>属性的值。在其他环境中，你需要保证在调用 <code>Session.close()</code>或者<code>Session.disconnect()</code>之前事务已经结束。

#		**********************************************************************************************************
#		20.2.5. Strategy: transactional
#		**********************************************************************************************************

title20-2-5 = 20.2.5. 策略: 事务
p20-2-5-1 =  <code>transactional</code> 缓存策略支持所有的事务缓存提供像，例如 JBoss TreeCache。这种缓存只能用于JTA环境。并且你必须制定<code>hibernate.transaction.manager_lookup_class</code>。

#		**********************************************************************************************************
#		20.2.6. Cache-provider/concurrency-strategy compatibility
#		**********************************************************************************************************

title20-2-6 = 20.2.6. 各种缓存提供商对缓存并发策略的支持情况
ic20-2-6-1 = None of the cache providers support all of the cache concurrency strategies.
p20-2-6-1 = The following table shows which providers are compatible with which concurrency strategies.
p20-2-6-2 = <strong>Table 20.2. Cache Concurrency Strategy Support</strong>
th20-2-6-1-1 = Cache
th20-2-6-1-2 = read-only
th20-2-6-1-3 = nonstrict-read-write
th20-2-6-1-4 = read-write
th20-2-6-1-5 = transactional
td20-2-6-1-1 = ConcurrentHashMap (not intended for production use)
td20-2-6-1-2 = yes
td20-2-6-1-3 = yes
td20-2-6-1-4 = yes
td20-2-6-1-5 = 
td20-2-6-1-6 = EHCache
td20-2-6-1-7 = yes
td20-2-6-1-8 = yes
td20-2-6-1-9 = yes
td20-2-6-1-10 = yes
td20-2-6-1-11 = Infinispan
td20-2-6-1-12 = yes
td20-2-6-1-13 = 
td20-2-6-1-14 = 
td20-2-6-1-15 = yes

#		**********************************************************************************************************
#		20.3. Managing the caches
#		**********************************************************************************************************

title20-3 = 20.3. 管理缓存
p20-3-1 = 无论何时当你给 <code>save()</code>, <code>update()</code> 或者 <code>saveOrUpdate()</code>方法传递一个对象时, 或者当你使用<code>load()</code>, <code>get()</code>, <code>list()</code>, <code>iterate()</code> 或 <code>scroll()</code>方法获得一个对象时, 该对象将会被加入到Session内部的缓存中。
p20-3-2 = 当 <code>flush()</code>方法被调用，对象的状态将会和数据库同步。如果你不希望此同步操作发生，或者你正处理大量对象、需要有效管理内存时， 可以使用 <code>evict()</code>方法，从一级缓存中去掉这些对象及其集合。
p20-3-3 = Session也提供了一个<code>contains()</code>方法来判断某个实例是否处于当前Session的缓存中。
p20-3-4 = 若果要把所有的对象从Session缓存中彻底清除，则需要使用<code>Session.clear()</code>方法。
p20-3-5 = 对于二级缓存来说, 在 <code>SessionFactory</code>中定义了许多方法，用于清除缓存中的实例、这个类、集合实例或者整个集合。
p20-3-6 = CacheMode参数用于控制具体的Session是如何与二级缓存进行交互：
li20-3-1-1 = <code>CacheMode.NORMAL</code>: 从二级缓存中读写数据。
li20-3-1-2 = <code>CacheMode.GET</code>: 从二级缓存中读取数据，尽在数据更新时对二级缓存写数据。
li20-3-1-3 = <code>CacheMode.PUT</code>: 仅向二级缓存写数据，但不从二级缓存中读数据。
li20-3-1-4 = <code>CacheMode.REFRESH</code>: 仅向二级缓存中写数据，但不从二级缓存中读数据。通过<code>hibernate.cache.use_minimal_puts</code>的设置，强制二级缓存从数据库中读取熟读，刷新缓存内容。
p20-3-7 = 如果你要查看二级缓存或查询缓存区域的内容，你可以使用 <code>Statistics</code> API:
p20-3-8 = 此时你需要手动打开统计选项，可选的，你可以让Hibernate更可读的方式维护缓存内容：

#		**********************************************************************************************************
#		20.4. The Query Cache
#		**********************************************************************************************************

title20-4 = 20.4. 查询缓存
p20-4-1 = 查询结果集也可以被缓存。只有当经常使用同样的参数进行查询时，这才会有用处。要使用查询缓存，首先你必须打开它：

#		**********************************************************************************************************
#		20.4.1. Enabling query caching
#		**********************************************************************************************************

title20-4-1 = 20.4.1. 打开查询缓存
p20-4-1-1 = 对于应用中正常的事务处理，缓存查询结果会导致一些额外的开销。例如，如果你对Persion的查询结果进行缓存，Hibernate就需要跟踪什么时候这些查询结果无效。因为对于Persion的修改已经提交。也就是说，再加上大多数应用程序不能从缓存查询结果中获得好处，因此Hibernate默认情况下禁用查询结果缓存。如果要使用查询缓存，首先你需要使查询缓存可用：
p20-4-1-2 = 该设置将会创建两个缓存区域：
li20-4-1-1-1 = <code>org.hibernate.cache.internal.StandardQueryCache</code>, 用于保存查询结果集
li20-4-1-1-2 = <code>org.hibernate.cache.spi.UpdateTimestampsCache</code>, 用于保存最近查询的一系列表的时间戳。他们被用于验证结果，因为他们是由查询缓存提供服务。
ic20-4-1-1 = 如果你配置底层的缓存实现使用过期或者超时，设置UpdateTimestampsCache的底层的缓存区域的超时时间大于其他任何的查询缓存的超时时间是非常重要的。 实际上，我们建议不要给UpdateTimestampsCache区域设置缓存过期时间。注意，对于LRU缓存到期尤其不适合。
p20-4-1-3 = 如上所述，绝大多数的查询并不能从查询缓存中受益，所以，默认情况下，即使在打开查询缓存时，单独查询也不进行查询结果缓存。如果要对特定的查询进行缓存，调用<code>org.hibernate.Query.setCacheable(true)</code>方法，这个调用会让查询在执行时先从缓存中查找结果，并将自己的结果集放到缓存中去。
nc20-4-1-1 = 查询缓存并不缓存实体的状态； 它只缓存标示符的值和值类型。为此，对于那些希望作为查询缓存一部分的实体，查询缓存通常和二级缓存结合使用(就像集合缓存).

#		**********************************************************************************************************
#		20.4.2. Query cache regions
#		**********************************************************************************************************

title20-4-2 = 20.4.2. 缓存区域查询
p20-4-2-1 = 如果你需要对查询缓存的失效政策进行精确的控制，你必须调用<code>Query.setCacheRegion()</code>方法，为每个查询指定其命名的缓存区域。
p20-4-2-2 = 如果你需要强行刷新其查询缓存区域 (忽略所有发现的缓存结果)，可以使用 <code>org.hibernate.Query.setCacheMode(CacheMode.REFRESH)</code>。 结合你为给定的查询定义的区域，Hibernate将会在将要刷新的区域中有选择的强制结果缓存。当底层的数据通过一个单独的线程被修改时，这是非常有用的，并且使用<code>org.hibernate.SessionFactory.evictQueries()</code>来批量迁移缓存区域是更有效的替代方案。

#		**********************************************************************************************************
#		20.5. Bytecode Enhancement
#		**********************************************************************************************************

title20-5 = 20.5. 字节码增强
p20-5-1 = 当这个对象和一个Session关联时，Hibernate 内部需要一个实体( <code>org.hibernate.engine.spi.EntityEntry</code> ) 来告诉实体它相对于持久化状态的当前的状态。然而，优于很多其他的规则必须要遵守，维持这种关联是一种沉重的操作。从4.2.0开始，出于这个目的，有一个新的改进，它将会减轻与会话相关的内存占用和cpu过载的问题。
p20-5-2 = 基本的想法是, 代替使用自定义的（这种方式很消耗资源并且通常被认为是资源消耗点）的map来执行查找，我们修改如下 
p20-5-3 = 有三种方式来从这个改进中获得好处：

#		**********************************************************************************************************
#		20.5.1. Implementing org.hibernate.engine.spi.ManagedEntity interface
#		**********************************************************************************************************

title20-5-1 = 20.5.1. 实现org.hibernate.engine.spi.ManagedEntity 接口
p20-5-1-1 = 一个实体可以选择自行实现此接口，那么就由实体负责来维持双向关联，这个关联中提供了访问和Session/EntityManager向关联的实体信息的方法。更多关于 org.hibernate.engine.spi.ManagedEntity 的信息请参javadoc。

#		**********************************************************************************************************
#		20.5.2. Runtime instrument
#		**********************************************************************************************************

title20-5-2 = 20.5.2. 运行时工具
p20-5-2-1 = 有些时候，你可能不想实现入侵性的接口，可能是处于可移植性考虑，Hibernate照顾到了这种情况，Hibernate会用一个实现了这个接口的类包裹住它们， which is fine and Hibernate will take care of this internally with a wrapper class which implements that interface, and also an internal cache that maps this entity instance and the wrapper together.
p20-5-2-2 = 很显然，这是可选择的最简单的方法，因为这不需要改变任何项目源代码，但是与第一个相比，它更加耗内存和CPU。

#		**********************************************************************************************************
#		20.5.3. Build-time instrument
#		**********************************************************************************************************

title20-5-3 = 20.5.3. 构建时工具
p20-5-3-1 = 除了上述的两种方法，Hibernate还提供了第三种方式，即字节码增强。应用程序通过注解<code>javax.persistence.Entity</code>或者复合使用<code>javax.persistence.Embeddable</code>来使用增强的实体类。
p20-5-3-2 = 1. Ant任务
p20-5-3-3 = 如下所示，使用<code>org.hibernate.tool.enhance.EnhancementTask</code>定义一个taskdef并且调用这个task。这个代码使用了预定义的classpathref和一个指向编译目录的属性。
nc20-5-3-1 = 出现EnhancementTask的目的是为了完全替代InstrumentTask。现在InstrumentTask还是十分的重要，所以将来这些InstrumentTask将会被从新编写。
p20-5-3-4 = 2. Maven插件
p20-5-3-5 = Maven插件使用Mojo修饰符来将Mojo附加到你项目的编译阶段。
p20-5-3-6 = 3. Gradle插件
p20-5-3-7 = Gradle插件将编译任务的输出路径作为实体类文件的源路径，通过强化这个文件来添加强化任务。

#		**********************************************************************************************************
#		20.6. Understanding Collection performance
#		**********************************************************************************************************

title20-6 = 20.6. 理解集合类的性能
p20-6-1 = 在前几节我们已经讨论了集合以及它们的应用。在这一节们将着重讲述集合在运行时的事宜。

#		**********************************************************************************************************
#		20.6.1. Taxonomy
#		**********************************************************************************************************

title20-6-1 = 20.6.1. 分类法
p20-6-1-1 = Hibernate为集合定义了三种基本类型：
li20-6-1-1-1 = 值类型
li20-6-1-1-2 = 一对多关联
li20-6-1-1-3 = 多对多关联
p20-6-1-2 = 这种分类方式区分了各种表和外键之间的关系，但是没有告诉我们有关关系模式的所有细节。要完全理解他们的关系结构和性能特点，我们必须同时考虑“用于Hibernate更新或删除集合行数据的主键的结构”。因此得到了如下的分类：
li20-6-1-2-1 = 有序集合
li20-6-1-2-2 = sets
li20-6-1-2-3 = bags
p20-6-1-3 = 所有的有序集合（maps,lists,和arrays）都有一个由<code>&lt;key&gt;</code>和<code>&lt;index&gt;</code>组成的主键。在这种情况下，集合的更新是十分高效的。当Hibernate识图更新或删除数据时，主键可以快速高效的索引到指定列。
p20-6-1-4 = Sets由<code>&lt;key&gt;</code>和其它元素字段构成。这相对于一些集合元素的类型而言是低效的，特别是复合元素，大文本和二进制字段，造成低效的原因是数据库可能无法高效的索引到复杂的主键。然而，对于<code>one-to-many</code>或者<code>many-to-many</code>关联关系，特别是合成的标示符，集合也能达到同样的高效性能。如果你希望SchemaExport为你的<set>创建主键， 你必须把所有的字段都声明为<code>not-null="true"</code>。
p20-6-1-5 = <code>&lt;idbag&gt;</code>映射定义了代理键，因此它总是可以很高效的被更新。事实上，<code>&lt;idbag&gt;</code>拥有着最好的性能表现。
p20-6-1-6 = Bag是最差的。因为bag允许重复的元素值，也没有索引字段，因此不可能定义主键。 Hibernate无法判断出重复的行。当这种集合被更改时，Hibernate将会先完整地移除 （通过一个整个集合，然后再重新创建整个集合。 因此Bag是非常低效的。
p20-6-1-7 = 对于一对多关联来说，“主键”很可能并不是数据库表的物理主键。 但就算在此情况下，上面的分类仍然是有用的。（它仍然反映了Hibernate在集合的各数据行中是如何进行“定位”的。）

#		**********************************************************************************************************
#		20.6.2. Lists, maps, idbags and sets are the most efficient collections to update
#		**********************************************************************************************************

title20-6-2 = 20.6.2. Lists, maps, idbags 和sets 对于操作update都是非常有效的集合
p20-6-2-1 = 通过上面的讨论，在进行添加、删除、更新元素操作时集合和sets的效率都是非常高的。
p20-6-2-2 = 可论证的是对于多对多关联、值数据集合而言，有序集合类比集合(set)有一个好处。因为Set的内在结构，如果“改变”了一个元素，Hibernate并不会更新这一行。对于Set来说，只有在插入和删除操作时“改变”才有效。再次强调：这段讨论对“一对多关联”并不适用。
p20-6-2-3 = 注意到数组无法延迟载入，我们可以得出结论：lists，maps和idbags是最高效的集合类型，sets紧随其后。sets是Hibernate最常用的集合类型。这是因为Sets在关系模型中是表现最自然的。
p20-6-2-4 = 但是，在设计良好的Hibernate领域模型中，我们通常可以看到更多的集合事实上是带有<code>inverse="true"</code>的一对多的关联。对于这些关联，更新操作将会在多对一的这一端进行处理。因此对于此类情况，无需考虑其集合的更新性能。

#		**********************************************************************************************************
#		20.6.3. Bags and lists are the most efficient inverse collections
#		**********************************************************************************************************

title20-6-3 = 20.6.3. Bags 和lists是最有效的逆向集合
p20-6-3-1 = 存在一种情况，使用bags和lists性能比使用sets好很多。对于指明了<code>inverse="true"</code>的集合类（比如说，标准的双向的一对多关联），我们可以在未初始化(fetch)包元素的情况下直接向bag或list添加新元素，这是因为<code>Collection.add()</code>或者<code>Collection.addAll()</code>方法 对bag或者List总是返回true（这点与与Set不同）。因此对于下面的相同代码来说，速度会快得多。

#		**********************************************************************************************************
#		20.6.4. One shot delete
#		**********************************************************************************************************

title20-6-4 = 20.6.4. 一次性删除
p20-6-4-1 = 逐个删除集合中的元素在一些情况下是十分低效的。Hibernate当然不会那样做，如果你想清空一个集合（比如你调用了<code>list.clear()</code>），Hibernate只需要一个<code>DELETE</code>就搞定了。
p20-6-4-2 = 加入你在一个有20个元素的集合中插入了一个元素，然后又删除了两个。Hibernate会执行一次<code>INSERT</code>语句和两次<code>DELETE</code>语句，除非集合是一个bag。这是显而易见的。
p20-6-4-3 = 但是，假设我们移除了18个元素，值留下2个元素，然后添加了3个新元素。那么有两种方式来处理这种情况
li20-6-4-1-1 = 逐个删除18个元素然后插入三行
li20-6-4-1-2 = 使用<code>DELETE</code>移除整个集合，然后逐个插入5个元素
p20-6-4-4 = Hibernate不知道使用第二种方式是否会快一些。也可能如果Hibernate这么做会引起不满，因为这样的行为会意外的触发数据库触发器等等问题。
p20-6-4-5 = 幸运的是，你可以强制使用第二种策略。你需要取消原来的整个集合类（解除其引用），然后再返回一个新的实例化的集合类，只包含需要的元素。有些时候这是非常有用的。
p20-6-4-6 = 显然，一次性删除并不适用于被映射为<code>inverse="true"</code>的集合。

#		**********************************************************************************************************
#		20.7. Monitoring performance
#		**********************************************************************************************************

title20-7 = 20.7. 性能检测
p20-7-1 = 没有监测和性能参数而进行优化是毫无意义的。Hibernate为其内部操作提供了一系列的示意图，因此可以从 每个<code>SessionFactory</code>抓取其统计数据。

#		**********************************************************************************************************
#		20.7.1. Monitoring a SessionFactory
#		**********************************************************************************************************

title20-7-1 = 20.7.1. 检测 SessionFactory
p20-7-1-1 = 你可以有两种方式访问<code>SessionFactory</code>的数据记录，第一种就是自己直接调用 sessionFactory.getStatistics()方法读取、显示统计数据。
p20-7-1-2 = 此外，如果你打开StatisticsService MBean选项，那么Hibernate则可以使用JMX技术发布其数据记录。你可以让应用中所有的<code>SessionFactory</code>同时共享一个MBean，也可以每个 SessionFactory分配一个MBean。下面的代码即是其演示代码：
p20-7-1-3 = 你可以激活和停止对<code>SessionFactory</code>的检测：
li20-7-1-1-1 = 在配置期间，将<code>hibernate.generate_statistics</code>设置为false
li20-7-1-1-2 = 在运行期间：<code>sf.getStatistics().setStatisticsEnabled(true)</code>或者<code>hibernateStatsBean.setStatisticsEnabled(true)</code>
p20-7-1-4 = 你也可以在程序中调用<code>clear()</code>方法重置统计数据，调用<code>logSummary()</code>在日志中记录（info级别）其总结。

#		**********************************************************************************************************
#		20.7.2. Metrics
#		**********************************************************************************************************

title20-7-2 = 20.7.2. 度量
p20-7-2-1 = Hibernate提供了一系列的数据记录，其记录的内容包括从最基本的信息到与具体场景的特殊信息。所有的测量值都可以由<code>Statistics</code>接口进行访问，主要分为三类：
li20-7-2-1-1 = 使用Session的普通数据记录，例如打开的Session的个数、取得的JDBC的连接数等。
li20-7-2-1-2 = 实体、集合、查询、缓存等内容的统一数据记录
li20-7-2-1-3 = 和具体实体、集合、查询、缓存相关的详细数据记录
p20-7-2-2 = 例如：你可以检查缓存的命中成功次数，缓存的命中失败次数，实体、集合和查询的使用概率，查询的平均时间等。请注意 Java中时间的近似精度是毫秒。Hibernate的数据精度和具体的JVM有关，在有些平台上其精度甚至只能精确到10秒。
p20-7-2-3 = 你可以直接使用getter方法得到全局数据记录（例如，和具体的实体、集合、缓存区无关的数据），你也可以在具体查询中通过标记实体名、或HQL、SQL语句得到某实体的数据记录。请参考Statistics、EntityStatistics、CollectionStatistics、SecondLevelCacheStatistics、和QueryStatistics的API文档以抓取更多信息。下面的代码则是个简单的例子
p20-7-2-4 = 如果你想得到所有实体、集合、查询和缓存区的数据，你可以通过以下方法获得实体、集合、查询和缓存区列表：<code>getQueries()</code>、<code>getEntityNames()</code>、<code>getCollectionRoleNames()</code>和<code>getSecondLevelCacheRegionNames()</code>。