
#		**********************************************************************************************************
#		Chapter 5. Basic O/R Mapping
#		**********************************************************************************************************

title5 = 第五章. 对象/关系数据库映射基础

#		**********************************************************************************************************
#		5.1. Mapping declaration
#		**********************************************************************************************************

title5-1 = 5.1. 映射定义
p5-1-1 = 对象/关系映射可以使用以下三个方法定义:
li5-1-1 = 使用java 5 注解（使用Java Persistence 2 注释）
li5-1-2 = 使用JPA2 XML 部署描述符 (在XXX章描述)
li5-1-3 = 使用hibernate配置文件<code>hbm.xml</code>。
p5-1-2 = Annotations被分为两类, 逻辑映射注解(描述对象模型，两个实体间的关系等。) 和物理映射注解（描述物理模式，表，列，索引等）。 在下面的代码注释中我们混合使用两中注释方法。
p5-1-3 = JPA注解在 <code>javax.persistence.*</code>包中。 Hibernate的一些特殊的扩展在包 <code>org.hibernate.annotations.*</code>中。你钟爱的IDE可以帮助你自动完成注解和其属性 (即使没有指定JPA插件，因为JPA注解本质上就是java 5 注解 。)。
p5-1-4 = 下面是一个映射的例子
p5-1-5 = hbm.xml这种解决方法使用一个可读可写的xml文件。 映射语言是Java-centric, 这意味着映射是围绕者持久化类来声明而不是数据表。
p5-1-6 = 请注意， 尽管许多Hibernate用户选择手动编辑xml，也有一些工具来生成映射文件。像XDoclet, Middlegen 和 AndroMDA。
p5-1-7 = 下面是映射文件例子:
p5-1-8 = 我们现在开始讨论映射文档的内容(注解和XML)。我们只描述Hibernate在运行时使用的元素和属性。映射文档还包括一些额外的可选属性和元素，它们在使用schema导出工具的时候会影响导出的数据库schema结果。（如：not-null属性）。

#		**********************************************************************************************************
#		5.1.1. Entity
#		**********************************************************************************************************

title5-1-1 = 5.1.1. 实体
p5-1-1-1 = 一个实体是一个可以被Hibernate持久化的普通的Java对象（也称作POJO）。
p5-1-1-2 = 使用 @Entity注解可以使一个对象变成一个实体。
p5-1-1-3 = 仅此而已，其他的都是可选的。有许多的可选项来调整你的映射， 我们一一解释。
p5-1-1-4 = <code>@Table</code> 可以定义这个实体持久化对应的数据表。如果没有定义，表名就是该实体的非限定类名，你也可以选择定义catalog, schema 同样也可以定义唯一约束。
p5-1-1-5 = 约束的名称是可选的 (如果未定义则自动生成)。约束名由按照命名规则定义的列名组成。
tc5-1-1-1 = 确保在 @UniqueConstraint 的columnNames属性中使用数据库级别的名称。例如, 对于简单类型， 数据库级别的列名也许和实体级别的列名相同，于关系属性来讲不是这样的。
p5-1-1-6 = <code>@Entity.name</code> 定义一个简写名称让你可以在JP-QL和HQL查询的时候使用。 默认是该类的非限定名。
p5-1-1-7 = Hibernate超出了JPA规范提供了额外的配置。有一些托管在<code>@org.hibernate.annotations.Entity</code>:
li5-1-1-1 = dynamicInsert / dynamicUpdate (默认是false): 指定Insert/Update sql 应该在运行时生成并且只包含那些非空的列。dynamic-insert 和dynamic-update设置不被子类继承。 尽管这种配置在某些情况下可以提高效率，但是实际上在别的情况下也会降低性能。
li5-1-1-2 = selectBeforeUpdate (默认false): 指定Hibernate不应该执行SQL update除非他包含的对象真的有更新。 只有在一个瞬态的对象与一个新的Session关联是使用update(), Hibernate会先额外执行一个select语句来确定update是否要执行。使用select-before-update通常会降低效率。 当你想把游离的实例重新绑定到一个会话中， 他可以阻止数据库中的update 触发器不必要的执行。
li5-1-1-3 = polymorphisms (默认IMPLICIT): 决定使用隐式的还是显示的多态查询。 隐式多态是指如果查询时给出的是任何父类、该类实现的接口或者该类的名字时，都会返回这个类的实例，如果查询中给出的是子类的名字，则返回子类的实例。显示多态意思是只有明确的指定该类的类名时才返回该类的实例。查询这个名字只会返回映射的子类的实例。在大多数情况下,  默认的polymorphisms=IMPLICIT是恰当的。显示的多态在当有两个不同的类映射同一张表时很有用，这样可以允许一个轻量级的类只包含部分的列。
li5-1-1-4 = persister: 指定一个自定义的ClassPersister。这个属性让你自定义类的持久化策略。例如，你可以指定自己的类继承org.hibernate.persister.EntityPersister， 你也可以编写org.hibernate.persister.ClassPersister接口的全新实现，比如使用存储过程调用、序列化到一个文件或者LDAP。 参照org.hibernate.test.CustomerPersister 示例， 持久化到一个Hashtable的简单例子。
li5-1-1-51 = optimisticLock (默认是 VERSION):指定乐观锁策略。如果你启用dynamicUpdate, 你可以选择乐观锁策略：
li5-1-1-5-1 = version: 检查version/timestamp列
li5-1-1-5-2 = all: 检查所有的列
li5-1-1-5-3 = dirty: 检查修改的列，允许一些并发修改
li5-1-1-5-4 = none: 不适用乐观锁
li5-1-1-52 = 强烈推荐在Hibernate中使用version/timestamp来进行乐观锁定。 这种策略优化了性能并且能够正确的处理对游离实例的修改（例如使用Session.merge()的时候）。
tc5-1-1-2 = 确保引入的是<code>@javax.persistence.Entity</code> 把一个类变成实体。通常的错误是引入<code>@org.hibernate.annotations.Entity</code>。
p5-1-1-8 = 有一些实体是不可变的。 他们不能够被应用修改。这允许Hibernate使用 <code>@Immutable</code>注解。做一些轻微的性能优化。
p5-1-1-9 = 你也可以修改Hibernate对类的延迟加载的处理方法。在<code>@Proxy</code>中使用<code>lazy=false</code> 来禁止懒加载（不推荐）。 你也可以指定一个接口用于延迟加载代理（默认是类自己）: 在 <code>@Proxy</code>中使用<code>proxyClass</code>。 Hibernate将会首先返回实现了该指定接口的代理（使用通过hibernate.bytecode.provide定义的字节码提供者）。当代理中的一个方法被调用时持久化对象将会被加载。参照下面的“初始化集合和代理”。
p5-1-1-10 = <code>@BatchSize</code> 指定通过标示符一次性抓取类实例的数量（默认是1）.
p5-1-1-11 = 在获取对象的时候使用 @Where 可以指定使用任意的SQL Where 条件。
p5-1-1-12 = 同样的， <code>@Check</code> @Check可以让你定义一个SQL表达式用于给自动模式生成添加多行检查约束。
p5-1-1-13 = 对于Hibernate映射来讲视图和基本表之间是没有区别的。 这在数据库级别上是透明的，尽管一些数据库管理软件不支持视图，尤其是在更新的时候。 有些时候你想使用视图，但是你在数据库中不能创建它（例如，在遗留模式）。这种情况下，你可以使用 <code>@org.hibernate.annotations.Subselect</code> 映射一个不变的并且只读的实体到一个SQL子查询表达式:
p5-1-1-14 = 声明表来同步这个实体，确保自动刷新可以正确执行，并且依赖于派生实体的查询不会返回过期数据。<code>&lt;subselect&gt;</code>可以作为一个属性或者是嵌套的映射元素。
p5-1-1-15 = 下面我们使用<code>hbm.xml</code>来实现相同的操作。 你可以用class元素声明一个持久化类。例如：
td5-1-1-1 = <code>name</code> (可选): 持久化类（或者接口）的Java全限定名。如果这个属性不存在，Hibernate将假定这是一个非POJO的实体映射。
td5-1-1-2 = <code>table</code> (可选 - 默认是类的非全限定名): 对应的数据库表名。
td5-1-1-3 = <code>discriminator-value</code> (可选 - 默认是类名): 用于在多态时区分每个独立的子类。可接受的值包括null或者not null。
td5-1-1-4 = <code>mutable</code> (可选 - 默认是true): 指明这个类的实例是否可修改。
td5-1-1-5 = <code>schema</code> (可选): 覆盖在根<hibernate-mapping>元素中指定的schema名字。
td5-1-1-6 = <code>catalog</code> (可选): 覆盖在根<hibernate-mapping>元素中指定的catalog名字。
td5-1-1-7 = <code>proxy</code> (可选): 指定一个接口，在延迟装载时作为代理使用。可以指定类本身。
td5-1-1-8 = <code>dynamic-update</code> (可选 - 默认为 false): 指定用于UPDATE 的SQL将会在运行时动态生成，并且只更新那些改变过的字段。
td5-1-1-9 = <code>dynamic-insert</code> (可选 - 默认为 false): 指定用于INSERT的 SQL 将会在运行时动态生成，并且只包含那些非空值字段。
td5-1-1-10 = <code>select-before-update</code> (可选 - 默认为 false): 指明只有在确定对象被修改的时候Hibernate才会执行update语句。只有当一个瞬态的对象被关联到一个新的Session使用update()时，Hibernate会在首先执行一个额外的select语句来确定update是否需要执行。
td5-1-1-11 = <code>polymorphisms</code> (可选 - 默认为 implicit): 界定是隐式还是显式的使用多态查询。
td5-1-1-12 = <code>where</code> (可选): 指定一个附加的SQLWHERE 条件， 在抓取这个类的对象时会一直增加这个条件。
td5-1-1-13 = <code>persister</code> (可选): 指定一个定制的ClassPersister。
td5-1-1-14 = <code>batch-size</code> (可选 - 默认是1): 指定一个用于 根据标识符（identifier）抓取实例时使用的"batch size"（批次抓取数量）。
td5-1-1-15 = <code>optimistic-lock</code> (可选 - 默认是 version): 决定乐观锁定的策略。
td5-1-1-16 = <code>lazy</code> (可选): lazy=“false”来禁用延迟加载。
td5-1-1-17 = <code>entity-name</code> (可选 - 默认是类名): Hibernate允许一个类被映射多次，前提是不同的表。并且允许使用Maps或XML代替Java层次的实体映射 （也就是实现动态领域模型，不用写持久化类－译注）。 在这种情况下，你应该提供一个任意的确切的名字。参考<a href="#c4-4">Section 4.4 动态模型</a> 和 <a href="#c5-1-1">5.1.1 实体</a> 。
td5-1-1-18 = <code>check</code> (可选): 这是一个SQL表达式， 用于为自动生成的schema添加多行（multi-row）约束检查。
td5-1-1-19 = <code>rowid</code> (可选):Hibernate可以使用数据库支持的所谓的ROWIDs，例如： Oracle数据库，如果你设置这个可选的rowid，Hibernate可以使用额外的字段rowid实现快速更新。ROWID是这个功能实现的重点， 它代表了一个存储元组（tuple）的物理位置。
td5-1-1-20 = <code>subselect</code> (可选): 它将一个不可变（immutable）并且只读的实体映射到一个数据库的子查询中。当你想用视图代替一张基本表的时候，这是有用的，但最好不要这样做。更多的介绍请看下面内容。
td5-1-1-21 = <code>abstract</code> (可选): 用于在&lt;union-subclass&gt; 的继承结构中标识抽象超类。
p5-1-1-16 = 若指明的持久化类实际上是一个接口，这也是完全可以接受的。 之后你可以用元素&lt;subclass&gt;来指定该接口的实际实现类。你可以持久化任何static（静态的）内部类。你应该使用标准的类名格式来指定类名，比如：Foo$Bar。
p5-1-1-17 = 下面是如何通过XML来创建虚拟视图(subselect)：
p5-1-1-18 = &lt;subselect&gt; 可以作为元素或者属性使用。

#		**********************************************************************************************************
#		5.1.2. Identifiers
#		**********************************************************************************************************

title5-1-2 = 5.1.2. 标示符
p5-1-2-1 = 被映射的类必须定义对应数据库表主键字段。大多数类都包含了一个JavaBean风格的属性作为实例的唯一标示。
p5-1-2-2 = 用<code>@Id</code>来标记唯一标示符。
p5-1-2-3 = 在 <code>hbm.xml</code>里使用&lt;id&gt; 元素来定义属性和主键列的映射。
td5-1-2-1-1 = <code>name</code> (可选): 标识属性的名字。
td5-1-2-1-2 = <code>type</code> (可选): 标识Hibernate类型的名字。
td5-1-2-1-3 = <code>column</code> (可选 - 默认为属性名): 主键字段的名字。
td5-1-2-1-4 = <code>unsaved-value</code> (可选 - 默认为一个切合实际（sensible）的值): 一个特定的标识属性值，用来标志该实例是刚刚创建的，尚未保存。用来和在之前的Session中保存过的或者加载过的处于游离状态的实例区分开来。
td5-1-2-1-5 = <code>access</code> (可选-默认是property)：Hibernate来访问属性值的策略。
p5-1-2-4 = 如果 <code>name</code>属性不存在，会认为这个类没有标识属性。
p5-1-2-5 = <code>unsaved-value</code> 属性在Hibernate中几乎不在需要，并且在annotations中没有这个元素。
p5-1-2-6 = 你也可以声明一个复合的标示符。 可以访问旧式的多主键数据。我们强烈不建议使用这种方式。

#		**********************************************************************************************************
#		5.1.2.1. Composite identifier
#		**********************************************************************************************************

title5-1-2-1 = 5.1.2.1. 复合主键
p5-1-2-1-1 = 可以使用以下语法类定义复合主键：
li5-1-2-1-1 = 使用组合类型来表示标示符并且在实体中映射为一个属性：然后就可以使用 @EmbeddedId来标注这个属性，组件类型必须是可序列化的。
li5-1-2-1-2 = 使用<code>@Id</code>标注多个属性: 标示符类型本身必须是<code>序列化</code>的。不幸的是这种方法不是一种标准，并且只有Hibernate支持。
li5-1-2-1-3 = 用 @Id映射多个属性并且声明一个外部的类作为标示符类型。这个类必须是可序列化的并且需要使用 @IdClass 来标注为实体。 这个标示类型必须包含属性和实体的标示符相同的属性：每个属性名称必须相同，同样的如果属性的类型是基本类型那么也必须相同，如果实体属性是一个关联（ <code>@OneToOne</code> 或者 <code>@ManyToOne</code>）那么他的类型必须是这个关联实体的主键的类型。
p5-1-2-1-2 = 正如你所看到的，最后一个案例很不明显。 是为了向后兼容,它继承了EJB2。我们不推荐使用（为了简单起见）。
p5-1-2-1-3 = 我们用例子来演示上面三种情况：

#		**********************************************************************************************************
#		5.1.2.1.1. id as a property using a component type
#		**********************************************************************************************************

title5-1-2-1-1 = 5.1.2.1.1. 使用组件类型作为Id属性
p5-1-2-1-1-1 = 下面是一个 <code>@EmbeddedId</code>的简单例子。
p5-1-2-1-1-2 = 可以注意到 <code>UserId</code> 类是 <code>序列化</code>的。 使用<code>@AttributeOverride</code>来覆盖列映射。
p5-1-2-1-1-3 = 嵌套主键本身可以包含关联实体的主键。
p5-1-2-1-1-4 = 嵌套Id的对象，关联会被表示为关联实体的表示符。 但是你可以使用 @MapsId注解在一个实体中连接到特定的关联。 @MapsId的值对应对象的嵌套id的属性名，包括关联的实体的标识。在数据库中，意味着<code>Customer.user</code> 和<code>CustomerId.userId</code> 属性共享相同的列 (在这个例子中是<code>user_fk</code>).
tc5-1-2-1-1-1 = 组合类型作为唯一标示符必须实现<code>equals()</code> 和 <code>hashCode()</code>方法。
p5-1-2-1-1-5 = 实际上，代码只设置了<code>Customer.user</code>属性，Hibernate会把user id的值copy到<code>CustomerId.userId</code>属性。
wc5-1-2-1-1-1 = id的值只有在flush的时候才会被copy, 不要依赖它。
p5-1-2-1-1-6 = 然而在JPA中不支持， Hibernate允许你在嵌套组件Id中直接设置关联 (代替 @MapsId).
p5-1-2-1-1-7 = 用<code>hbm.xml</code> 来实现上面的功能：
p5-1-2-1-1-8 = 首先一个简单的例子：
p5-1-2-1-1-9 = 下面的例子演示怎样映射一个关联：
p5-1-2-1-1-10 = 在上面的示例中注意以下几点:
li5-1-2-1-1-1-1 = 属性列的顺序很重要。在关联和被关联的实体里的主键里的顺序必须要相同。
li5-1-2-1-1-1-2 = 多对一使用相同的列作为主键 因此必须标记为只读的（<code>inserttable </code>和 <code>updateable</code> 设置为false）。
li5-1-2-1-1-1-3 = 和 @MapsId 不同，被关联实体的Id值不会被复制， 更多信息查看外键生成。
p5-1-2-1-1-11 = 最后一个示例演示怎样在嵌套Id中直接映射关联。
p5-1-2-1-1-12 = 推荐使用这种方法来映射组合主键。下面的选项除非特殊的约定否则不应该考虑在内。

#		**********************************************************************************************************
#		5.1.2.1.2. Multiple id properties without identifier type
#		**********************************************************************************************************

title5-1-2-1-2 = 5.1.2.1.2. 不带标示符类型的多Id属性
p5-1-2-1-2-1 = 另外一个更自然的方法是在实体中为多个属性设置 @Id。这种方法只在Hibernate中支持(JPA不支持) 但是不需要额外的嵌套组件。
p5-1-2-1-2-2 = 在这个例子中Customer 使用自身的标示符表示: 他必须是可序列化的并且必须复写<code>equals()</code> 和<code>hashCode()</code>)方法。
p5-1-2-1-2-3 = 在 <code>hbm.xml</code>中实现相同的映射:

#		**********************************************************************************************************
#		5.1.2.1.3. Multiple id properties with with a dedicated identifier type
#		**********************************************************************************************************

title5-1-2-1-3 = 5.1.2.1.3. 多个id属性具有专用标示符类型
p5-1-2-1-3-1 = 在实体上的 @IdClass 指向这个类的标示符的类。实体中标注为 @Id的属性必须在 @IdClass中有对应的属性。 搜索双属性的的返回类型必须为相同的基本属性，或者必须对应于关联的关联实体的标示符类型。
wc5-1-2-1-3-1 = 这个方法继承自EJB2，不推荐使用，但是Hibernate支持，用不用由你决定。
p5-1-2-1-3-2 = Customer 和 CustomerId 有相同的属性customerNumber ，user 也是。<code>user.CustomerId</code> 必须是序列化的并且需要复写<code>equals()</code>和<code>hashCode()</code>方法。
p5-1-2-1-3-3 = 尽管不是JPA标准， Hibernate允许你在<code>@IdClass</code>中声明关联。
p5-1-2-1-3-4 = 对这个功能的兴趣有限，尽管你可能会选择使用<code>@IdClass</code> 来兼容JPA标准，或者有让人无法理解的想法。
p5-1-2-1-3-5 = 在<code>hbm.xml</code> 中实现相同的功能:

#		**********************************************************************************************************
#		5.1.2.2. Identifier generator
#		**********************************************************************************************************

title5-1-2-2 = 5.1.2.2. 标识符生成器
p5-1-2-2-1 = Hibernate可以自动的帮你生成并且填充标识符的值。 推荐在”business“ 或者"nature"id中使用这种方法（尤其是复合主键中）。
p5-1-2-2-2 = Hibernate提供了很多主键生成策略， 我们来看一下符合JPA规范的最长用的几种方式。
li5-1-2-2-1-1 = IDENTITY: 对DB2,MySQL, MS SQL Server, Sybase和HypersonicSQL的内置标识字段提供支持。返回的标识符是<code>long</code>, <code>short</code> 或者 <code>int</code>.
li5-1-2-2-1-2 = SEQUENCE (在Hibernate中称作seqhilo): 使用高/低算法为一个特定的数据库序列来生成标示符，返回的标识符类型为 <code>long</code>, <code>short</code> 或者 <code>int</code>。
li5-1-2-2-1-3 = TABLE (在Hibernate中称为 <code>AMultipleHiLoPerTableGenerator</code> ) : 使用高/低算法来有效的生成标示符， 类型为long, short, 或者int。 给定一个表和字段（默认分别是 hibernate_unique_key 和next_hi）作为高位值的来源。 高/低位算法生成的标识符只在一个特定的数据库中是唯一的。
li5-1-2-2-1-4 = AUTO: 依据底层数据库的功能选择 <code>IDENTITY</code>, <code>SEQUENCE</code> 或 <code>TABLE</code> 。
ic5-1-2-2-1 = 推荐所有的新项目使用增强的主键生成策略。 他们在实体注解中默认是关闭的，但是可以使用hibernate.id.new_generator_mapping=true来激活。这些新的生成器更加的有效并且更加的复合JPA2的规范。<br/>对于已有的Hibernate应用他们不会向下兼容(如果使用sequence或者table生成策略的话)。参考 <a href="#c5-1-2-2">5.1.2.2. 标识符生成器</a> 来获取更多信息。
p5-1-2-2-3 = 使用 @GeneratedValue 把一个id属性标识为自动生成。你可以通过设置<code>strategy</code>来指定生成策略，默认是auto。
p5-1-2-2-4 = SEQUENCE 和 TABLE需要进行额外的配置， 使用<code>@SequenceGenerator</code>和<code>@TableGenerator</code>:
li5-1-2-2-2-1 = <code>name</code>:生成器的名称
li5-1-2-2-2-2 = <code>table / sequenceName</code>: 表或者序列的名称 (默认分别为hibernate_sequences 和hibernate_sequence)
li5-1-2-2-2-3 = <code>catalog / schema</code>:
li5-1-2-2-2-4 = <code>initialValue</code>: Id的初始值。
li5-1-2-2-2-5 = <code>allocationSize</code>: 生成Id时的增量
p5-1-2-2-5 = 另外， TABLE策略还允许以下配置：
li5-1-2-2-3-1 = <code>pkColumnName</code>: 包含实体标识符的列名
li5-1-2-2-3-2 = <code>valueColumnName</code>: 包含标识符值的列名
li5-1-2-2-3-3 = <code>pkColumnValue</code>: 实体标识符
li5-1-2-2-3-4 = <code>uniqueConstraints</code>: 包括Id在内的任何表的可能的列约束
p5-1-2-2-6 = 链接一个TABLE或者sequence生成器到一个实际的生成属性，  定义的name和生成器的<code>generator</code> 属性的值要相同， 如下：
p5-1-2-2-7 = 生成器的定义范围可以是整个应用或者是类。类范围的生成器对外是不可见的并且可以复写应用范围的生成器。应用范围的生成器定义在JPA的xml部署描述符中。(参考 <a href="#c5-1-2-2">5.1.2.2. 标识符生成器</a>):
p5-1-2-2-8 = 如果使用JPA的XML描述符 (像 <code>META-INF/orm.xml</code>) 来定义生成器， <code>EMP_GEN</code> 和 <code>SEQ_GEN</code> 都是应用级别的生成器。
nc5-1-2-2-1 = JPA不支持包级别的定义。然而你可以使用 @GenericGenerator 来定义package级别的生成器。(参考 <a href="#c5-1-2-2">5.1.2.2. 标识符生成器</a>).
p5-1-2-2-9 = 以上是JPA的标准生成器。 Hibernate超越了JPA标准提供了一些额外的生成器或者额外的选项。你也可以通过实现<code>org.hibernate.id.IdentifierGenerator</code>来自定义主键生成器。
p5-1-2-2-10 = 要想自定义生成器，使用 <code>@GenericGenerator</code> 注解 (或者是他的复数形式 <code>@GenericGenerators</code>) 来描述类的主键生成策略或者缩略名和一些键值对。 当使用<code>@GenericGenerator</code> 并且通过<code>@GeneratedValue.generator</code>分配时， @GeneratedValue.strategy会被忽略：留空.
p5-1-2-2-11 = 以hbm.xml的方式， 在<code>&lt;id&gt;</code>标签中使用可选的<code>&lt;generator&gt;</code>子元素，如果需要一些参数来配置或初始化生成器实例，使用<code>&lt;param&gt;</code> 元素来传递。

#		**********************************************************************************************************
#		5.1.2.2.1. Various additional generators
#		**********************************************************************************************************

title5-1-2-2-1 = 5.1.2.2.1. 一些可选的生成策略。
p5-1-2-2-1-1 = 所有的生成器都实现了<code>org.hibernate.id.IdentifierGenerator</code>接口。这是一个很简单的接口。一些应用可以有选择的提供自己的序列化实现，然而，Hibernate提供了一些内置的实现。如下：
dd5-1-2-2-1-1-1 = 用于为long, short或者int类型生成 唯一标识。只有在没有其他进程往同一张表中插入数据时才能使用。 在集群下不要使用。
dd5-1-2-2-1-1-2 = 支持的数据库有DB2，MySQL，MS SQL Server，Sybase和HypersonicSQL。返回的标识符类型为 <code>long</code>, <code>short</code> 或者 <code>int</code>。
dd5-1-2-2-1-1-3 = 在DB2,PostgreSQL, Oracle, SAP DB, McKoi中使用序列（sequence)， 而在Interbase中使用生成器(generator)。返回的标识符类型为<code>long</code>, <code>short</code> 或 <code>int</code>。
dd5-1-2-2-1-1-4 =  使用一个高/低位算法高效的生成long, short 或者 int类型的标识符。 给定一个表和字段（默认分别是 hibernate_unique_key和next_hi）作为高位值的来源。高/低位算法生成的标识符只在一个特定的数据库中是唯一的。 
dd5-1-2-2-1-1-5 = 使用高/低算法为一个已命名的数据库序列来高效的生成long，short 或者 int类型的标识符。
dd5-1-2-2-1-1-6 = 用一个128-bit的UUID算法生成字符串类型的标识符，UUID被编码为一个32位16进制数字的字符串。用户也可以通过配置分隔符把16进制数分割为8,8,4,8,4的格式 (配置参数”separator“)，需要注意的是这和IETF RFC 4122表示的8-4-4-4-12不同。 如果你需要是RFC 4122兼容UUIDs, 考虑使用uuid2。
dd5-1-2-2-1-1-7 = 生成一个IETF RFC 4122兼容128位的UUID。 基于插件式的“生成策略”来生成确切的“version”(RFC术语). 可以生成的值有java.util.UUID, java.lang.String或者长度为16的byte数组（byte[16]）。 生成策略由接口org.hibernate.id.UUIDGenerattionStrategy定义。生成器定义了2个配置参数来决定使用哪一个生成策略：
dd5-1-2-2-1-1-7-1 = 列举 使用的UUIDGenerationStrategy类。
dd5-1-2-2-1-1-7-2 = 列举使用的UUIDGenerationStrategy实例。
p5-1-2-2-1-2 = 以下的策略具有创造性：
li5-1-2-2-1-1-1 = <code>org.hibernate.id.uuid.StandardRandomStrategy</code> (默认的) - 通过<code>java.util.UUID</code>的randomUUID方法生成第三个版本的UUID（又叫做”随机“）。 
li5-1-2-2-1-1-2 = <code>org.hibernate.id.uuid.CustomVersionOneStrategy</code> - 生成第一代的UUID值。 当Mac地址不可用时使用IP地址。如果你需要使用Mac地址，考虑使用一个已存在的第三方的UUID生成器可以发现Mac地址并且通过<code>org.hibernate.id.UUIDGenerationStrategy</code>整合。到目前为止已经知道的库有 <a href="http://johannburkard.de/software/uuid/">http://johannburkard.de/software/uuid/</a> 和 <a href="http://commons.apache.org/sandbox/id/uuid.html">http://commons.apache.org/sandbox/id/uuid.html</a>
dd5-1-2-2-1-1-8 = 在MS SQL Server和MySQL中使用数据库生成的GUID字符串。
dd5-1-2-2-1-1-9 = 根据底层的数据库的功能选择使用identity, sequence或者hilo。
dd5-1-2-2-1-1-10 = 让应用程序在调用save()方法调用之前为对象分配一个Id。如果没有指定<generator>元素默认使用此策略。
dd5-1-2-2-1-1-11 = 通过一些唯一键来查找一些列，来检索有数据库触发器生成的主键和主键的值。
dd5-1-2-2-1-1-12 = 使用另一个关联对象的标识符。 通常和<one-to-one>主键关联结合使用。
dd5-1-2-2-1-1-13 = 一种特别的序列生成策略,使用数据库序列来生成实际值, 但将它和JDBC3的getGeneratedKeys结合在一起, 使得在插入语句执行的时候就返回生成的值。目前为止只有面向JDK 1.4的Oracle 10g驱动支持这一策略。因为Oracle驱动程序的一个bug，这些插入语句的注释被关闭了。

#		**********************************************************************************************************
#		5.1.2.2.2. Hi/lo algorithm
#		**********************************************************************************************************

title5-1-2-2-2 = 5.1.2.2.2. Hi/lo 算法
p5-1-2-2-2-1 = hilo和seqhilo提供了hi/lo算法的两种实现。第一种实现需要一个特殊的数据表来保存下一个"hi"的值。第二种实现使用一个Oracle风格的序列（在被支持的情况下）。
p5-1-2-2-2-2 = 不幸的是，你在为Hibernate自行提供Connection时无法使用hilo。当Hibernate使用JTA获取应用服务器的数据源连接时,你必须正确地配置<code>hibernate.transaction.manager_lookup_class</code>。

#		**********************************************************************************************************
#		5.1.2.2.3. UUID algorithm
#		**********************************************************************************************************

title5-1-2-2-3 = 5.1.2.2.3. UUID 算法
p5-1-2-2-3-1 = UUID包括: IP地址，JVM的启动时间（精确到1/4秒），系统时间和一个计数器值（在JVM中唯一）。 在Java代码中不可能获得MAC地址或者内存地址，所以这已经是我们在不使用JNI的前提下的能做的最好实现了。

#		**********************************************************************************************************
#		5.1.2.2.4. Identity columns and sequences
#		**********************************************************************************************************

title5-1-2-2-4 = 5.1.2.2.4. 标识字段和序列
p5-1-2-2-4-1 = 那些支持标识符字段的数据库 (DB2, MySQL, Sybase, MS SQL), 你可以使用identity生成主键。 于内部支持序列的数据库(DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) 你可以使用sequence风格的关键字生成。这两种方式对于插入一个新的对象都需要两次SQL查询。例如:
p5-1-2-2-4-2 = 对于跨平台开发，native将会根据底层数据库的功能动态的选择使用identity, sequence或hilo策略。

#		**********************************************************************************************************
#		5.1.2.2.5. Assigned identifiers
#		**********************************************************************************************************

title5-1-2-2-5 = 5.1.2.2.5. 程序分配的标识符
p5-1-2-2-5-1 = 如果你需要应用程序分配一个标示符（而非Hibernate来生成），你可以使用assigned 生成器。这种特殊的生成器会使用已经分配给对象的标识符属性的标识符值。这个生成器使用一个自然键（natural key，有商业意义的列－译注）作为主键，而不是使用一个代理键（ surrogate key，没有商业意义的列－译注）。如果没有指定<code>@GeneratedValue</code> 或者 &lt;generator&gt; 元素时这是默认使用的生成器。
p5-1-2-2-5-2 = T当选择assigned生成器时，除非有一个version或timestamp属性，或者你定义了<code>Interceptor.isUnsaved()</code>，否则需要让Hiberante使用 unsaved-value="undefined"，强制Hibernatet查询数据库来确定一个实例是瞬时的（transient） 还是脱管的（detached）。

#		**********************************************************************************************************
#		5.1.2.2.6. Primary keys assigned by triggers
#		**********************************************************************************************************

title5-1-2-2-6 = 5.1.2.2.6. 触发器实现的主键生成器
p5-1-2-2-6-1 = 仅仅用于遗留的schema中 (Hibernate不能使用触发器生成DDL)。
p5-1-2-2-6-2 = 在上面的例子中，类定义了一个命名为socialSecurityNumber的唯一值属性，它是一个自然键（natural key），命名为person_id的代理键（surrogate key） 的值由触发器生成。

#		**********************************************************************************************************
#		5.1.2.2.7. Identity copy (foreign generator)
#		**********************************************************************************************************

title5-1-2-2-7 = 5.1.2.2.7. 身份复制(外键生成器)
p5-1-2-2-7-1 = 最后， 你可以使用Hibernate从另一个关联的实体中拷贝标识符。 在Hibernate术语中，被称为外键生成器， 但是JPA 映射 读起来更加的好并且鼓励使用这个名称。
p5-1-2-2-7-2 = 或者
p5-1-2-2-7-3 = 在 <code>hbm.xml</code>中:

#		**********************************************************************************************************
#		5.1.2.3. Enhanced identifier generators
#		**********************************************************************************************************

title5-1-2-3 = 5.1.2.3. 增强的标识符生成器
p5-1-2-3-1 = 从发布的3.2.3开始，有两种生成器代表了对主键生成器的两个方面的重新思考。 第一个方面是数据库的可移植性； 第二是优化，优化意味着你不需要每次生成新的主键都需要查询数据库。这两个生成器的目的是取代上面描述的从3.3.X版本开始的一些生成器。
p5-1-2-3-2 = 第一个生成器是 <code>org.hibernate.id.enhanced.SequenceStyleGenerator</code>用于替代sequence生成器，并且比native有更好的可移植性。 因为native生成器在identity和sequence之间做选择，这两个有很大的语义差别，在考虑应用的可移植性方面会导致一些微妙的问题。然而<code>org.hibernate.id.enhanced.SequenceStyleGenerator</code>以不同的方式实现可移植性。他选择一个表或者一个序列来在数据库里面存储它的递增值，这取决于所使用的方言的功能。它和native之间的区别是基于表的存储或者基于序列的存储都有相同的语义。实际上，序列正是Hibernate模仿的基于表的生成器。这种生成器有一些配置参数：
li5-1-2-3-1-1 = <code>sequence_name</code> (可选的， 默认是hibernate_sequence): 被使用的序列或者表的名称。
li5-1-2-3-1-2 = <code>initial_value</code> (可选的, 默认是 1): 从序列或者表中检索的初始值。在序列中，它类似于“STARTS WITH”条款。
li5-1-2-3-1-3 = <code>increment_size</code> (可选的 - 默认是  1): 子序列调用序列或者表时的差值（递增量）。在序列条件下类似于“INCREMENT BY”条款。
li5-1-2-3-1-4 = <code>force_table_use</code> (可选的 - 默认是  false): 决定是否我们应该强制使用表作为后台结构尽管方言有可能支持序列。
li5-1-2-3-1-5 = <code>value_column</code> (可选的 - 默认是 next_val): 只对表结构可用，在表中用于保存值的列名。
li5-1-2-3-1-6 = <code>prefer_sequence_per_entity</code> (可选的 - 默认是 false): 决定我们是否应该根据他的名字来为现在共享生成器的实体创建新的序列。
li5-1-2-3-1-7 = <code>sequence_per_entity_suffix</code> (可选的 - 默认是  _SEQ): 专用序列的后缀名。
li5-1-2-3-1-8 =  optimizer (可选的 - 默认是 none): See Section 5.1.2.3.1, \u201C优化标识符生成器\u201D
p5-1-2-3-3 = 第二种新的生成器是 <code>org.hibernate.id.enhanced.TableGenerator</code>, 用于代替TABLE生成器，尽管它的功能更类似于<code>org.hibernate.id.MultipleHiLoPerTableGenerator</code>, 另外， 利用插件化优化的概念对 <code>org.hibernate.id.MultipleHiLoPerTableGenerator</code> 二次实现。本质上这个生成器定义了一个表通过使用明显的有键值的行来存储不同的增量值。配置参数如下：
li5-1-2-3-2-1 = <code>table_name</code> (可选的 - 默认是 hibernate_sequences): 使用的表名。
li5-1-2-3-2-2 = <code>value_column_name</code> (可选的 - 默认是 next_val): 表中用于保存值的列的名称。
li5-1-2-3-2-3 = <code>segment_column_name</code> (可选的 - 默认是  sequence_name): 表中用于保存“分隔键”的列的名字。这个值用于确定使用哪一个增量值。
li5-1-2-3-2-4 = <code>segment_value</code> (可选的 - 默认是  default): 我们想从中为生成器获取增量值的段的值。
li5-1-2-3-2-5 = <code>segment_value_length</code> (可选的 - 默认是  255): 用于模式生成，创建这个段键列列的大小。
li5-1-2-3-2-6 = <code>initial_value</code> (可选的 - 默认是  1): 从表中检索到的初始值。
li5-1-2-3-2-7= <code>increment_size</code> (可选的 - 默认是  1): 后续调用的差值（增量）。
li5-1-2-3-2-8 = <code>optimizer</code> (可选的 - 默认是  5.1.2.3. 增强的标识符生成器): See <a href="#c5-1-2-3-1">Section 5.1.2.3.1, \u201C优化标识符生成器\u201D</a>.

#		**********************************************************************************************************
#		5.1.2.3.1. Identifier generator optimization
#		**********************************************************************************************************

title5-1-2-3-1 = 5.1.2.3.1. 优化标识符生成器
p5-1-2-3-1-1 = 那些在数据库中存储值的标示符生成器，每次生成一个新的标示符都去访问数据库是很低效的，反而你可以在内存中保存一些并且只在内存中的值被用完时在取访问数据库。这是可插拔的优化器的作用。目前只有这两个增强的生成器支持这个操作。(<a href="#c5-1-2-3">Section 5.1.2.3, \u201C增强的标识符生成器\u201D</a>
li5-1-2-3-1-1-1 = <code>none</code> (通常如果没有指定优化器这是默认的): 不会执行任何的优化，每次每个请求都要访问数据库。 
li5-1-2-3-1-1-2 = <code>hilo</code>: 使用hi/lo算法在数据库中检索值。在数据库中由这个优化器产生的值是连续的。在数据库中这个这个优化器检索到的值表明了“组号”。increment_size 乘以内存中的这个值作为“hi值”。
li5-1-2-3-1-1-3 = <code>pooled</code>: 和hilo一样，这个优化器也是企图减少访问数据库的次数。 然而我们只为“下一组”存储其初始值，而不是使用内存分组算法分配一组连续的数值组。这里的increment_size 取自数据库。
 
#		**********************************************************************************************************
#		5.1.2.4. Partial identifier generation
#		**********************************************************************************************************

title5-1-2-4 =  5.1.2.4. 局部标识符生成器
p5-1-2-4-1 = Hibernate支持为一些标识属性自动生成值，只需要在一个或者多个id属性上使用 @GenerateValue注解。
wc5-1-2-4-1 = Hibernate团队一直认为这种想法有本质的错误。在使用此特性之前， 请尽努力的修改数据模型。
p5-1-2-4-2 = 也可以在一个 <code>@EmbeddedId</code> 的类中生成属性。
 
#		**********************************************************************************************************
#		5.1.3. Optimistic locking properties (optional)
#		**********************************************************************************************************

title5-1-3 = 5.1.3. 乐观锁属性（可选）
p5-1-3-1 = 当使用长事务或者跨数据库事务的会话，存储版本数据是很有用的， 他可以保证如果有两个会话同时更新一个实体的时候，最后提交的修改将会被告知而不是直接覆盖其他会话已经完成的工作。他保证了一些独立性也同样有好的伸缩性并且在需要频繁读写的情况下有很好的性能。
p5-1-3-2 = 可以使用两种方式：一个专门的版本号或者时间戳。
p5-1-3-3 = 这个版本号或者时间戳属性不能是NUll或者游离的实例。Hibernate将会把所有发现的任何没有版本号或者时间戳的实例作为瞬态，不管有没有指定其他的unsaved-value策略。在Hibernate中声明不可为空的版本号或者时间戳属性是避免重复传递的一种简单方式。对于使用assigned的标示符或者组合键的人来说特别有用。
 
#		**********************************************************************************************************
#		5.1.3.1. Version number
#		**********************************************************************************************************

title5-1-3-1 = 5.1.3.1. 版本号
p5-1-3-1-1 = 使用 <code>@Version</code> 来给一个实体加上乐观锁。:
p5-1-3-1-2 = 版本属性将会被映射到OPTLOCK列， 实体管理器将使用它检测更新冲突(防止更新丢失， 你也可能赞成last-commit-wins策略).
p5-1-3-1-3 = 版本列可能是一个数字。  Hibernate支持定义和实现了 <code>UserVersionType</code>的任何类型。
p5-1-3-1-4 = 应用程序在任何情况下都不可以修改Hibernate创建的版本号。 若想人为的增加版本号，参考Hibernate实体管理的参考文档 <code>LockModeType.OPTIMISTIC_FORCE_INCREMENT</code>或者 <code>LockModeType.PESSIMISTIC_FORCE_INCREMENT</code>.
p5-1-3-1-5 = 如果版本号由数据库生成（比如通过触发器）, 要确保使用 <code>@org.hibernate.annotations.Generated</code>(GenerationTime.ALWAYS).
p5-1-3-1-6 = 在<code>hbm.xml</code>中声明版本属性如下：
td5-1-3-1-1-1 = <code>column</code> (可选 - -默认属性名): 保存版本号的列的名字。
td5-1-3-1-1-2 = <code>name</code>: 持久化类的属性名。
td5-1-3-1-1-3 = <code>type</code> (可选 - 默认是integer): 版本号数据类型。
td5-1-3-1-1-4 = <code>access</code> (可选 - 默认是property): Hibernate属性值的存取策略。
td5-1-3-1-1-5 = <code>unsaved-value</code> (可选 - 默认是undefined): 一个属性值来表明这个实例是新创建的（未保存的）, 用来和在之前的Session中保存或获取的已处于游离状态的实例区分。Undefined指明应该使用标示符属性值。
td5-1-3-1-1-6 = <code>generated</code> (可选 - 默认是 never): 指明版本属性的值由数据库生成。 更多信息参考 <a href="#c5-5">生成的属性</a> 。
td5-1-3-1-1-7 = <code>insert</code> (可选 - 默认是 true): 指明这个版本列是否应该包含在insert语句中。如果数据库列定义了默认值为0 那么可以设置为false。
 
#		**********************************************************************************************************
#		5.1.3.2. Timestamp
#		**********************************************************************************************************

title5-1-3-2 = 5.1.3.2. 时间戳
p5-1-3-2-1 = 或者， 你可以使用时间戳。 时间戳是乐观锁的一种比较不安全的实现方式。然而，有时候应用程序可能在其他地方使用时间戳。
p5-1-3-2-2 = 只需要简单的把Date或者Calendar类型的属性标记为<code>@Version</code>.
p5-1-3-2-3 = 当使用时间戳版本控制， 你可以通过选择性的给属性添加 <code>@org.hibernate.annotations.Source</code>注解来告诉Hibernate从database还是从JVM中检索时间戳的值。 可能的配置为 <code>org.hibernate.annotations.SourceType.VM</code> 和 <code>org.hibernate.annotations.SourceType.DB</code>。默认是 <code>SourceType.DB</code> 在没有<code>@Source</code>注解时也是用默认值。
p5-1-3-2-4 = 和使用版本号一样， 时间戳也可以有数据库而不是Hibernate生成。使用<code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS)</code>来实现。
p5-1-3-2-5 = 在 <code>hbm.xml</code>中，使用<code>&lt;timestamp&gt;</code> 元素:
td5-1-3-2-1-1 = <code>column</code> (可选 - 默认是属性名): 保存时间戳的列名。
td5-1-3-2-1-2 = <code>name</code>: 持久化类中的类型为Date或者Calendar的javaBean格式的属性名。
td5-1-3-2-1-3 = <code>access</code> (可选 - 默认是 property): Hibernate获取属性值的策略。
td5-1-3-2-1-4 = <code>unsaved-value</code> (可选 - 默认是 null): 一个版本属性值来表明这个实例时新创建的（未保存的），用来和游离状态的实例区分。Undefined指明应该使用标示符属性值。
td5-1-3-2-1-5 = <code>source</code> (可选 -默认是 vm): Hibernate应该从哪里检索时间戳? 从数据库中或者当前的JVM中? 基于数据库的时间戳会有额外的开销，因为Hibernate需要访问数据库以确定下一个值。在集群环境可以安全使用。不是所有的方言都支持从数据库检索时间戳。在使用锁时也可能因为精度问题是不安全的（比如Oracle 8）。
td5-1-3-2-1-6 = <code>generated</code> (可选 - 默认是 never): 指明版本属性的值由数据库生成。 更多信息参考 5.5 “生成的属性”。
nc5-1-3-2-1 = <code>&lt;Timestamp&gt;</code> 等价于 &lt;version type="timestamp"&gt;。 并且 &lt;timestamp source="db"&gt; 等价于&lt;version type="dbtimestamp"&gt;
 
#		**********************************************************************************************************
#		5.1.4. Property
#		**********************************************************************************************************

title5-1-4 = 5.1.4. 属性
p5-1-4-1 = 在一个给定实体中你需要确定哪些属性需要被持久化。这在注解和<code>hbm.xml</code> 文件中有所不同。
 
#		**********************************************************************************************************
#		5.1.4.1. Property mapping with annotations
#		**********************************************************************************************************

title5-1-4-1 = 5.1.4.1. 使用注解映射属性
p5-1-4-1-1 = 在注解的环境中, 一个实体的 所有的非静态的非瞬态的属性(字段或者方法取决于存取类型) 都被认为是持久化的， 除非你标注它为 <code>@Transient</code>。不给属性添加注解等同于适当的<code>@Basic</code>注解。
p5-1-4-1-2 = <code>@Basic</code> 允许你指定属性的抓取策略。如果设置为LAZY，指定该属性在实例变量第一次被访问的时候懒加载。这需要构建时字节码仪器。如果类不能被感知， 属性等级的懒加载会被忽略。默认是EAGER。你也可以使用<code>@Basic.optional</code> 来标记一个属性是不可选的。这将确保底层的列数不为null的（如果可能的话）。比较好的方式是指定<code>@NotNull</code>作为实体验证。
p5-1-4-1-3 = 请看下面的例子:
p5-1-4-1-4 = counter一个瞬态的字段， lengthInMeter，一个方法标记为<code>@Transient</code>, 将会被Hibernate忽略，<code>name</code>, <code>length</code>, 和 <code>firstname</code> 属性被影射为持久化的并且是饥饿加载(对于简单属性来说是默认的)。当实体的懒加载属性第一次被访问时，  detailedComment属性会从数据库中被抓取出来。通常情况下不需要懒加载简单属性（不要与懒关联抓取混淆）。推荐使用JP-QL投影功能（Java持久化查询语言）或者条件查询。
p5-1-4-1-5 = JPA支持HIbernate支持的所有基本类型的属性映射(所有的Java基本类型， 以及他们各自的包装类和序列化类).Hibernate注解创造性的把枚举映射为一个序列（保存枚举序数）或者是一个字符列（保存枚举的字符串表示）：默认的持久化表示是序列， 可以通过 <code>@Enumerated</code>注解覆写，如note属性的例子那样。
p5-1-4-1-6 = 在纯粹的Java API中，时间的精度没有被定义。 当处理时间数据时，你希望能够指定在数据库中的精度。 时间数据的精度可以是DATE, TIME, 或 TIMESTAMP (例如：实际的日期，只有时间，或者两者都有). 使用<code>@Temporal</code>注解来调整。
p5-1-4-1-7 = <code>@Lob</code> 表明属性应该根据它的类型被持久化为Blob或Clob: java.sql.Clob, Character[], char[] 和 java.lang.String 将会被持久化为 Clob. java.sql.Blob, Byte[], byte[] 和 Serializable 类型将会被持久化为Blob.
p5-1-4-1-8 = 如果属性类型实现了 <code>java.io.Serializable</code> 并且不是基本类型， 并且属性页没有被标注为<code>@Lob</code>, 那么将会使用 serializable类型。
 
#		**********************************************************************************************************
#		5.1.4.1.1. Type
#		**********************************************************************************************************

title5-1-4-1-1 = 5.1.4.1.1. 类型
p5-1-4-1-1-1 = 如果有需要，你也可以使用 @org.hibernate.annotations.Type来手动的指定类型和一些参数. @Type.type 可以是:
li5-1-4-1-1-1-1 = Hibernate基本类型的名字: integer, string, character, date, timestamp, float, binary, serializable, object, blob。
li5-1-4-1-1-1-2 = Java 基本数据类型的名字: int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob。
li5-1-4-1-1-1-3 = 序列化java类的名字。
li5-1-4-1-1-1-4 = 自定义的类的名字: com.illflow.type.MyCustomType。
p5-1-4-1-1-2 = 如果没有指定类型, Hibernate 将会根据值得的属性通过反射来获取正确的Hibernate类型。Hibernate将会按照上面2，3,4的规则，尝试解析属性的getter方法返回的类的名字。
p5-1-4-1-1-3 = <code>@org.hibernate.annotations.TypeDef</code> 和 <code>@org.hibernate.annotations.TypeDefs</code> 允许你声明类型定义。这个注解可以放在类或者package等级。需要注意，这些定义对sessionFactory来说是全局的(即使是定义在类一级的)。如果这个类型只用在了一个实体之上，你可以把定义放在实体本身上。否则，我们推荐把定义设置在包级别。在下面的例子中，在处理PhoneNumber的属性时，指定持久化策略为自定义的PhoneNumberType映射类型。 然而，其他类的属性也可以通过显示的使用 <code>@Type</code>注解来指定他们的持久化策略为PhoneNumberType。
nc5-1-4-1-1-1 = 包级别的注解被放置在名为<code>package-info.java</code> 的文件中。把你的注解放在包声明之前。
p5-1-4-1-1-4 = 下面的示例展示了如何在自定义TypeDef中使用parameters.
p5-1-4-1-1-5 = 当使用复合的用户类型时, 你将会须知道怎样定义列。出于这个目的介绍了<code>@Columns</code>。
 
#		**********************************************************************************************************
#		5.1.4.1.2. Access type
#		**********************************************************************************************************

title5-1-4-1-2 = 5.1.4.1.2. 存取类型
p5-1-4-1-2-1 = 默认情况下，类级别的存取类型由<code>@Id</code> 或者 <code>@EmbeddedId</code>注解的位置决定。如果这些注解标注在一个字段上，则只会持久化字段并且通过字段来获取状态。如果注解标注在getter方法上，那么只有getter方法会被持久化并且通过getter/setter方法获取状态。在实际中能够很好的使用，并且是推荐使用的方法。
nc5-1-4-1-2-1 = 类层级的注解（字段或者属性）必须同样的可以定义默认的存取类型。建议你在整个应用中使用一个注解布局策略。
p5-1-4-1-2-2 = 然而在某些情况下，你需要:
li5-1-4-1-2-1-1 = 强制存取类型为实体级别
li5-1-4-1-2-1-2 = 在类级为特定的实体覆写存取类型
li5-1-4-1-2-1-3 = 覆写可嵌入类型的存取类型
p5-1-4-1-2-3 = 最好的例子是一个可嵌入的类被多个实体使用但是不使用相同的存取类型。在这种情况下，最好在可嵌入类上强制存取类型。
p5-1-4-1-2-4 = 下面演示使用<code>@Access</code> 注解来强制一个给定类的存取类型：
p5-1-4-1-2-5 = 在持有其他属性标准的同时你也可以为单个属性覆写存取类型。
p5-1-4-1-2-6 = 在这个示例中, 除了orderNumber属性之外 其他的存取类型都是FIELD。 注意，对应的字段，如果有的话需要被标记为<code>@Transient</code> 或者瞬态的.
nc5-1-4-1-2-2 = <code>@org.hibernate.annotations.AccessType</code>注解在字段和属性的存取上不建议使用，但是如果你想使用自定义的存取类型的话，还是有有用的。
 
#		**********************************************************************************************************
#		5.1.4.1.3. Optimistic lock
#		**********************************************************************************************************

title5-1-4-1-3 = 5.1.4.1.3. 乐观锁
p5-1-4-1-3-1 = 它有时候非常有用，即使给定的是属性是脏数据它也可以避免增长版本号 (针对特定的集合)。你可以在属性（或者集合上） 使用<code>@OptimisticLock(excluded=true)</code>注解来实现上述功能。
p5-1-4-1-3-2 = 更正式的, 指定更新该属性时不需要获得乐观锁。
 
#		**********************************************************************************************************
#		5.1.4.1.4. Declaring column attributes
#		**********************************************************************************************************

title5-1-4-1-4 = 5.1.4.1.4. 列属性说明
p5-1-4-1-4-1 = 用于属性映射的列可以由<code>@Column</code>注解定义。用它来覆盖默认值（针对默认的情况查看JPA文档）。你可以在下面几种类型的属性上面使用该注解：
li5-1-4-1-4-1-1 = 完全没有注释的
li5-1-4-1-4-1-2 = 用 <code>@Basic</code>标注的
li5-1-4-1-4-1-3 = 用 <code>@Version</code>标注的
li5-1-4-1-4-1-4 = 用 <code>@Lob</code>标注的
li5-1-4-1-4-1-5 = 用 <code>@Temporal</code>标注的
p5-1-4-1-4-2 = name属性被映射为<code>flight_name</code> 列, 并且不可以为空，长度为50并且不可修改(使该属性不可变).
p5-1-4-1-4-3 = 这个注解可以使用在常规的属性上，也包括<code>@Id</code> 和 <code>@Version</code> 属性。
td5-1-4-1-4-1-1 = <code>name</code> (可选): 列名(默认是属性名)
td5-1-4-1-4-1-2 = <code>unique</code> (可选): 标注该列是否使用唯一约束(默认是false)
td5-1-4-1-4-1-3 = <code>nullable</code> (可选): 标注该列是否可为空(默认 true).
td5-1-4-1-4-1-4 = <code>insertable</code> (可选): 是否被包含在insert语句中(默认 true)
td5-1-4-1-4-1-5 = <code>updatable</code> (可选): 是否被包含在update语句中(默认 true)
td5-1-4-1-4-1-6 = <code>columnDefinition</code> (可选): 覆写特定列的sql ddl片段(非便捷式的)
td5-1-4-1-4-1-7 = <code>table</code> (可选): 指定目标表(默认是主表)
td5-1-4-1-4-1-8 = <code>length</code> (可选): 列的长度 (默认 255)
td5-1-4-1-4-1-9 = <code>precision</code> (可选): 列的精度 (默认 0)
td5-1-4-1-4-1-10 = <code>scale</code> (可选): 可用的小数点位数 (默认 0)
 
#		**********************************************************************************************************
#		5.1.4.1.5. Formula
#		**********************************************************************************************************

title5-1-4-1-5 = 5.1.4.1.5. 公式
p5-1-4-1-5-1 = 有时候你希望数据库可以做一些运算，而不是在JVM中计算。你也许希望创建某种类型的虚拟列。你可以使用SQL片段（即公式）来取代把属性映射为列。这种类型的属性是只读的（它的值由sql公式计算得来）。
p5-1-4-1-5-2 = SQl片段也可以很复杂，甚至可以包含子查询。
 
#		**********************************************************************************************************
#		5.1.4.1.6. Non-annotated property defaults
#		**********************************************************************************************************

title5-1-4-1-6 = 5.1.4.1.6. 未注解属性的默认值
p5-1-4-1-6-1 = 如果一个属性未被注解，则遵从以下规则:
li5-1-4-1-6-1-1 = 如果一个属性是简单类型，默认使用<code>@Basic</code>映射。
li5-1-4-1-6-1-2 = 否则, 如果属性类型注解了，则默认使用 <code>@Embedded</code>注解。
li5-1-4-1-6-1-3 = 否则, 如果属性的类型是序列化的，则在保存对象的序列化版本的列上使用<code>@Basic</code> 注解
li5-1-4-1-6-1-4 = 否则, 如果属性类型是java.sql.Clob 或 java.sql.Blob, 会根据<code>LobType</code>加上适当的 @Lob注解。 
 
#		**********************************************************************************************************
#		5.1.4.2. Property mapping with hbm.xml
#		**********************************************************************************************************

title5-1-4-2 = 5.1.4.2. 使用<code>hbm.xml</code>映射属性
p5-1-4-2-1 = <code>&lt;property&gt;</code> 元素用于声明类中JavaBean风格的属性。
td5-1-4-2-1-1 = <code>name</code>: 属性名，以小写字母开头。
td5-1-4-2-1-2 = <code>column</code> (可选 - 默认是属性名): 在数据库中映射的列名。也可以使用嵌入的<column>元素来指定。
td5-1-4-2-1-3 = <code>type</code> (可选): 表明Hibernate 类型。
td5-1-4-2-1-4 = <code>update</code>, <code>insert</code> (可选 - 默认 true): 表明映射的列应该包含在update 和insert sql语句中。如果都设置为false,则允许使用一个完全派生的属性，它的值由和它映射到相同列的属性或者由一个触发器或其他应用指定。
td5-1-4-2-1-5 = <code>formula</code> (可选): 一个sql表达式，来计算属性的值。计算得来的属性在数据库中没有对应的映射列。
td5-1-4-2-1-6 = <code>access</code> (可选 - 默认 property): Hibernate存取属性值的策略。
td5-1-4-2-1-7 = <code>lazy</code> (可选 - 默认 false): 指定当实例变量第一次被访问时该属性应该被延迟抓取。这需要build-time字节码控件。
td5-1-4-2-1-8 = <code>unique</code> (可选): 为该列启用DDL生成的唯一约束。同样，该属性也可以是property-ref的目标。
td5-1-4-2-1-9 = <code>not-null</code> (可选): 为该列启用DDL生成的非空约束。
td5-1-4-2-1-10 = <code>optimistic-lock</code> (可选 - 默认 true): 指定修改该属性时不需要获取乐观锁。换句话说，当该属性是脏数据的时候，是否应该增加版本号。
td5-1-4-2-1-11 = <code>generated</code> (可选 - 默认 never): 指定该属性的值由数据库生成。参考 <a href="#c5-5">生成的属性</a>获取更多信息。
p5-1-4-2-2 = 类型名可以为:
li5-1-4-2-1-1 = Hibernate基本类型的名字: <code>integer</code>, <code>string</code>, <code>character</code>, <code>date</code>, <code>timestamp</code>, <code>float</code>, <code>binary</code>, <code>serializable</code>, <code>object</code>, <code>blob</code> etc.
li5-1-4-2-1-2 = Java基本类型的名字: <code>int</code>, <code>float</code>, <code>char</code>, <code>java.lang.String</code>, <code>java.util.Date</code>, <code>java.lang.Integer</code>, <code>java.sql.Clob</code> etc.
li5-1-4-2-1-3 = 序列化的Java类的名字。
li5-1-4-2-1-4 = 自定义类型的类名: <code>com.illflow.type.MyCustomType</code> etc.
p5-1-4-2-3 = 如果没有指定类型, Hibernate将会根据指定的属性通过反射来获取正确的Hibernate类型。Hibernate将会尝试安装上面2,3,4条规则解析通过属性的getter方法返回的类的名字。在某些情况下你需要type属性。例如, 用来区分Hibernate.DATE 和 <code>Hibernate.TIMESTAMP</code>, 或者用来指定自定义类型。
p5-1-4-2-4 = <code>access</code>用来控制Hibernate在运行时怎样访问属性。默认的，Hibernate将会调用属性的get/set方法。如果你指定access="field", Hibernate将会绕开get/set方法，直接通过反射来访问属性。你可以通过指定一个实现了<code>org.hibernate.property.PropertyAccessor</code>接口的类来自定义属性访问策略。
p5-1-4-2-5 = 另一个强大的特性是派生属性。这些属性被定义为只读的。属性的值在加载时计算得出。你可以声明使用SQL表达式计算。表达式将会转化成加载一个实例的SQl子查询语句：
p5-1-4-2-6 = 你可以通过不给特定的列指定别名来引用实体表。在上面的例子中是 <code>customerId</code>。如果你不想把它作为属性使用，你也可以使用嵌入的<formula>元素。
 
#		**********************************************************************************************************
#		5.1.5. Embedded objects (aka components)
#		**********************************************************************************************************

title5-1-5 = 5.1.5. 嵌入式对象 (又名组件)
p5-1-5-1 = 嵌入式对象(或组件) 是那些属性被同样映射到主表的对象。反过来，组件也可以定义自己的属性、组件、和集合。
p5-1-5-2 = 可以在一个实体中声明嵌入组件，甚至可以重新映射属性列。组件类必须在类上使用 @Embeddable注解。可以在关联的属性上面使用<code>@Embedded</code> 和 <code>@AttributeOverride</code> 注解来为一个特定的实体覆写列的映射：
p5-1-5-3 = 嵌入式对象继承其所属实体中定义的访问类型（注意，这可以通过使用<code>@Access</code> 注解来覆盖原有值）。
p5-1-5-4 = 上面的例子中，<code>Person</code> 有两个组件属性，分别是homeAddress和bornIn. homeAddress属性并没有被注解，但是Hibernate会自动检测其对应的Address类中的 <code>@Embeddable</code>注解，并将其看做一个持久化组件。对于Country中已映射的属性，使用<code>@Embedded</code> 和 <code>@AttributeOverride</code>注解来覆盖原来映射的列名（覆写为bornCountryName）。正如你所看到的，Address对象中还内嵌了Country对象，这里也同样使用了Hibernate和EJB3的自动检测机制。 通过“.”符号来覆盖嵌入式对象中的嵌入式对象。
p5-1-5-5 = Hibernate 注解支持很多EJB3规范中没有明确定义的特性。例如，你可以在嵌入式对象上添加 <code>@MappedSuperclass</code>注解，这样可以将其父类的属性持久化。(详情参阅 <code>@MappedSuperclass</code> )。
p5-1-5-6 = 可以在关联注解中使用嵌入式对象(例如 <code>@OneToOne</code>, <code>@ManyToOne</code>, <code>@OneToMany</code> 和 <code>@ManyToMany</code>)。你可以使用 <code>@AssociationOverride</code>注解来覆写关联列。
p5-1-5-7 = 如果你想在一个实体中使用两个同类型的嵌入对象，其默认的列名是无效的，因为几个嵌入对象将会共享相同的列。在JPA中，你需要至少对一个进行覆写。而在Hibernate中，允许你通过NamingStrategy接口对默认的命名机制进行扩展。通过这种方式你可以写一个防止命名冲突的策略。DefaultComponentSafeNamingStrategy 就是这样一个例子。
p5-1-5-8 = 如果嵌入对象属性反向指向了他的所属实体，那么，把它标记为 <code>@Parent</code> 。Hibernate将会确保属性和实体引用被正确加载。
p5-1-5-9 = 在XML中，使用<code>&lt;component\&gt;</code> 元素。
td5-1-5-1-1 = <code>name</code>: 属性名。
td5-1-5-1-2 = <code>class</code> (可选 - 默认由反射决定的属性类型): 组件(子)类的名字。
td5-1-5-1-3 = <code>insert</code>: 映射列是否在insert语句中出现？
td5-1-5-1-4 = <code>update</code>: 映射列是否在update语句中出现？
td5-1-5-1-5 = <code>access</code> (可选 - 默认是property): Hibernate访问属性值的策略。
td5-1-5-1-6 = <code>lazy</code> (可选 - 默认false): 指定在第一次访问实例变量时该组件应该被懒加载，需要在构建时加入二进制指示指令。
td5-1-5-1-7 = <code>optimistic-lock</code> (可选 - 默认 true): 指定更新该组件时不需要获取乐观锁，他决定了当该属性是脏数据时，是否增加版本号。
td5-1-5-1-8 = <code>unique</code> (可选 - 默认 false): 指定在所有的映射列中加入唯一约束。
p5-1-5-10 = 子 <code>&lt;property&gt;</code> 标签，映射子类的所有属性到表列。
p5-1-5-11 = <code>&lt;component&gt;</code> 标签内可以使用&lt;parent&gt; 子元素来映射组件内反向引用所属实体的属性。
p5-1-5-12 = <code>&lt;dynamic-component&gt;</code> 元素，可以把Map映射为组件，Map的key会被映射成属性名，详情参考 <a href="#c9-5">Section 9.5, \u201C动态组件\u201D</a> 。该特性在注解中不被支持。
 
#		**********************************************************************************************************
#		5.1.6. Inheritance strategy
#		**********************************************************************************************************

title5-1-6 = 5.1.6. 继承策略
p5-1-6-1 = Java支持多态: 一个类可以继承自另外的类。 这些策略存在一个层次结构：
li5-1-6-1-1 = 每个类分层结构一张表: 一个表存储该类的层次结构的所有数据
li5-1-6-1-2 = 链接的子表策略: 类和其子类各一张表，各个表存储对应子类的特殊属性。实体的状态被存储在它对的类和它所有的超类中。 
li5-1-6-1-3 = 每个类一张表: 每个具体类和子类各一张表，每个表存储了他的属性和它父类的属性。实体的状态完全存储在他的特定表中。
 
#		**********************************************************************************************************
#		5.1.6.1. Single table per class hierarchy strategy
#		**********************************************************************************************************

title5-1-6-1 = 5.1.6.1. 每个类层次结构一张表
p5-1-6-1-1 = 在这种方法中，一个给定类层次结构中的所有子表的属性都被保存在一张表中。
p5-1-6-1-2 = 每个子类声明自己的属性和子类。版本和id属性继承自根类。层次结构中的每个子类都必须定义一个鉴定值。如果没有指定，则默认使用类的权限定名。
p5-1-6-1-3 = 在<code>hbm.xml</code>中, 针对每个层次结构一张表的策略，使用<code>&lt;subclass&gt;</code> 声明。例如:
td5-1-6-1-1 = <code>name</code>: 子类的全限定名。
td5-1-6-1-2 = <code>discriminator-value</code> (可选 - 默认类名): 用于区分每个子类的值。
td5-1-6-1-3 = <code>proxy</code> (可选): 指定一个类或者接口用于懒加载代理。
td5-1-6-1-4 = <code>lazy</code> (可选 - 默认true): 设置 lazy="false" 来禁用懒加载。
p5-1-6-1-4 = 继承映射的更多信息参考<a href="c10">Chapter 10, 继承映射</a>.
 
#		**********************************************************************************************************
#		5.1.6.1.1. Discriminator
#		**********************************************************************************************************

title5-1-6-1-1 = 5.1.6.1.1. 鉴别器
p5-1-6-1-1-1 = 在使用table-per-class-hierarchy映射策略的多态持久化中需要使用鉴别器。在表中声明了鉴别列。 这个鉴别列包含标记值，来告诉持久层一个特定的行对应于哪一个子类。Hibernate 内核支持以下类型作为鉴别列： <code>string</code>, <code>character</code>, <code>integer</code>, <code>byte</code>, <code>short</code>, <code>boolean</code>, <code>yes_no</code>, <code>true_false</code>。
p5-1-6-1-1-2 = 和鉴别类型一样，使用<code>@DiscriminatorColumn</code> 来定义鉴别列。
nc5-1-6-1-1-1 = 在<code>javax.persitence.DiscriminatorColumn</code> 中可以使用的DiscriminatorType只包括<code>STRING</code>, <code>CHAR</code> 和 <code>INTEGER</code> ，这意味着并不是所有的Hibernate类型都被<code>@DiscriminatorColumn</code> 支持。
p5-1-6-1-1-3 = 也可以使用 <code>@DiscriminatorFormula</code> 在SQL中创建一个虚拟的鉴别列。当鉴别器的值是从表的一列或者多列中获取时，这是非常有用的。 <code>@DiscriminatorColumn</code> 和 <code>@DiscriminatorFormula</code> 都只能用在根实体上(每个持久化层次一个).
p5-1-6-1-1-4 = <code>@org.hibernate.annotations.DiscriminatorOptions</code> allows to optionally specify Hibernate specific discriminator options which are not standardized in JPA. The available options are force and insert. The force attribute is useful if the table contains rows with "extra" discriminator values that are not mapped to a persistent class. This could for example occur when working with a legacy database. If force is set to true Hibernate will specify the allowed discriminator values in the SELECT query, even when retrieving all instances of the root class. The second option - insert - tells Hibernate whether or not to include the discriminator column in SQL INSERTs. Usually the column should be part of the INSERT statement, but if your discriminator column is also part of a mapped composite identifier you have to set this option to false.
tc5-1-6-1-1-1 = 又有一个叫 <code>@org.hibernate.annotations.ForceDiscriminator</code> 的注解，但是自从3.6版本开始就被弃用了。它被<code>@DiscriminatorOptions</code> 所取代。
p5-1-6-1-1-5 = 最后, 在层次结构中的每个类上使用 <code>@DiscriminatorValue</code>注解来指定给定实体的鉴别列的值。如果在类上没有指定<code>@DiscriminatorValue</code>，将会默认使用类的权限定名。
p5-1-6-1-1-6 = 在 <code>hbm.xml</code>中, 使用 <code>&lt;discriminator&gt;</code> 元素来定义鉴别列或公式:
td5-1-6-1-1-1-1 = <code>column</code> (可选 - 默认 class): 鉴别列的名字。
td5-1-6-1-1-1-2 = <code>type</code> (可选 - 默认 string): Hibernate类型名。
td5-1-6-1-1-1-3 = <code>force</code> (可选 - 默认 false): 强制Hibernate取出鉴别器的值，即使在取所有的根实例的时候。
td5-1-6-1-1-1-4 = <code>insert</code> (可选 - 默认 true): 如果你的鉴别列是映射的组件标识符的一部分时，把它设置为false。来告诉Hibernate 不把该列包含在SQL insert语句中。
td5-1-6-1-1-1-5 = <code>formula</code> (可选): 一个任意的SQL表达式，在类型判断时执行。可用于基于内容的鉴别器。
p5-1-6-1-1-7 = 鉴别列的实际值是由<code>&lt;class&gt;</code> 和 <code>&lt;subclass&gt;</code> 元素的discriminator-value属性得来的。
p5-1-6-1-1-8 = 使用 <code>formula</code> 属性，你可以定义一个任意的SQL表达式，用来判断一行数据的类型：
 
#		**********************************************************************************************************
#		5.1.6.2. Joined subclass strategy
#		**********************************************************************************************************

title5-1-6-2 = 5.1.6.2. 链接子类策略
p5-1-6-2-1 = 每个子类可以映射他自己的表。又被称为table-per-subclass 映射策略。 通过链接该表和其其父表来获取该类的状态。在这种映射策略中不在需要鉴别列，但是每个子类必须声明一个列来存储标示符。这个表的主键是父表的外键。由 <code>@PrimaryKeyJoinColumns</code> 或者<code>&lt;key&gt;</code> 元素指定。
nc5-1-6-2-1 = 表名默认是类的权限定名。 如果没有设置<code>@PrimaryKeyJoinColumn</code> ，那么主键/外键列名和父类主表的主键列的列名相同。
p5-1-6-2-2 = 在<code>hbm.xml</code>中, 使用<code>&lt;joined-subclass&gt;</code> 元素。 例如:
td5-1-6-2-1-1 = <code>name</code>: 子类的权限定类名。
td5-1-6-2-1-2 = <code>table</code>: 子类对应的表名。
td5-1-6-2-1-3 = <code>proxy</code> (可选): 指定一个类或者接口用于懒加载代理。
td5-1-6-2-1-4 = <code>lazy</code> (可选, 默认 true): 设置 lazy="false" 禁用懒加载。
p5-1-6-2-3 = 使用<code>&lt;key&gt;</code> 元素声明主键/外键列。在这一章开始的映射文件应该被修改为：
p5-1-6-2-4 = 关于继承映射的更多信息参考<a href="#c10">Chapter 10, 继承映射</a>.
 
#		**********************************************************************************************************
#		5.1.6.3. Table per class strategy
#		**********************************************************************************************************

title5-1-6-3 = 5.1.6.3. 每个类一张表策略
p5-1-6-3-1 = 第三种选择是在继承层次结构中的每个具体类都映射一张表。又被成为 table-per-concrete-class 策略。每张表定义了对应类的所有持久化状态，也包括继承的状态。在Hibernate中, 并不需要完全显示的映射这样的继承树。可以把每个类作为单独的根实体来映射。然而，如果你想使用多态关联(例如，对继承结构中超类的关联), 你应该使用联合子类映射。
p5-1-6-3-2 = 在 <code>hbm.xml</code>中:
td5-1-6-3-1-1 = <code>name</code>: 子类的全限定名。 
td5-1-6-3-1-2 = <code>table</code>: 子类的表名。
td5-1-6-3-1-3 = <code>proxy</code> (可选): 指定一个类或者接口用于懒加载代理。
td5-1-6-3-1-4 = <code>lazy</code> (可选, 默认 true): 设置 lazy="false" 禁用懒加载。
p5-1-6-3-3 = 这种映射策略不需要指定鉴别标识列。
p5-1-6-3-4 = 更多继承映射的信息参考<a href="#c10">Chapter 10, 继承映射</a>.
 
#		**********************************************************************************************************
#		5.1.6.4. Inherit properties from superclasses
#		**********************************************************************************************************

title5-1-6-4 = 5.1.6.4. 从父类继承属性
p5-1-6-4-1 = 在没有被映射的实体(例如，该实体没有对应的表)特定的业务超类之间共享属性是非常有用的。出于这个目的，你可以使用<code>@MappedSuperclass</code>。
p5-1-6-4-2 = 在数据库中,这个层次结构将会被表示为Order表，并且表中含有id, lastUpdate 和 lastUpdater 列。超类的嵌入的属性的映射被复制到他们子类实体中。记住，可嵌入的超类不是继承结构的根。.
nc5-1-6-4-1 = 父类中没有被标记为<code>@MappedSuperclass</code>的属性会被忽略。
nc5-1-6-4-2 = 除非使用 <code>@Access</code>注解，否则使用默认的访问类型(自动或者方法)。
nc5-1-6-4-3 = 相同的概念可以被用在<code>@Embeddable</code>对象从父类继承属性中。这也需要使用<code>@MappedSuperclass</code>来完成。(到目前为止，还不是标准的EJB3特性)
nc5-1-6-4-4 = 允许在一个类上使用<code>@MappedSuperclass</code>，这个类可以在继承结构映射的中间。
nc5-1-6-4-5 =  继承结构中所有没被 <code>@MappedSuperclass</code> 或 <code>@Entity</code> 标记的类将会被忽略。
p5-1-6-4-3 = 你可以通过<code>@AttributeOverride</code> 注解覆盖实体父类中定义的列，这个注解只能在继承层次结构的顶端使用。
p5-1-6-4-4 = 在上面这个例子中，altitude属性的值最终将持久化到Plane表的fld_altitude列。而名为propulsion的关联则保存在fld_propulsion_fk外键列。
p5-1-6-4-5 =  你可以在<code>@Entity</code>，<code>@MappedSuperclass</code> 以及那些对象为 <code>@Embeddable</code>的属性定义<code>@AttributeOverride(s)</code> 和 <code>@AssociationOverride(s)</code>。
p5-1-6-4-6 = 在<code>hbm.xml</code>中, 只需要简单在需要继承他们的实体中使用 <code>&lt;class&gt;</code> 元素来映射超类的属性。
 
#		**********************************************************************************************************
#		5.1.6.5. Mapping one entity to several tables
#		**********************************************************************************************************

title5-1-6-5 = 5.1.6.5. 一个实体映射到多张表
p5-1-6-5-1 = 虽然在一个全新的模式中不推荐这样做，但是有些遗留的数据库会强迫你映射单个实体到多张表。
p5-1-6-5-2 = 使用类级的 @SecondaryTable 或 @SecondaryTables 注解。用<code>@Column</code> 或 <code>@JoinColumn</code>的table参数来表明某个列在一个特定的表中。
p5-1-6-5-3 = 在这个示例中, name保存在MainCat表中, storyPart1保存在Cat1表中, storyPart2保存在Cat2表中. Cat1表通过外键cat_id和MainCat表关联, Cat2表通过id列和MainCat表关联 (和MainCat的id列同名). 对storyPart2列还定义了唯一约束。
p5-1-6-5-4 = 使用<code>@org.hibernate.annotations.Table</code> 注解可以做一些优化调整:
li5-1-6-5-1-1 = <code>fetch</code>: 如果设为JOIN, 也是默认的, Hibernate将会使用内连接来抓取有一个类或者他的超类定义的二级表，使用外连接抓取由子类定义的耳二级表。如果设置为SELECT，当这行数据是子类的实例时，Hibernate将会在由父类定义的二级表上使用连续查询。当检索由类及其父类定义的二级表时，将会一直使用内连接。
li5-1-6-5-1-2 = <code>inverse</code>: 如果为true, Hibernate将不会通过此链接来插入或更新属性，默认是false。 
li5-1-6-5-1-3 = <code>optional</code>: 如果启用 (默认的), 如果打开，Hibernate 只会在此连接定义的属性非空时插入一行数据，并且总是使用一个外连接来得到这些属性。
li5-1-6-5-1-4 = <code>foreignKey</code>: 定义二级表指向主表的外键名。
p5-1-6-5-5 = 确保在appliesto属性上使用二级表的名字
p5-1-6-5-6 = 在 <code>hbm.xml</code>中, 使用 <code>&lt;join&gt;</code> 元素。
td5-1-6-5-1-1 = <code>table</code>: 连接表的名字。
td5-1-6-5-1-2 = <code>schema</code> (可选): 覆写由根 <hibernate-mapping> 元素指定的模式名。
td5-1-6-5-1-3 = <code>catalog</code> (可选): 覆写由根 <hibernate-mapping> 元素指定的catalog名。
td5-1-6-5-1-4 = <code>fetch</code> (可选 - 默认join): 如果设置为默认值join， Hibernate 将使用一个内连接来得到这个类或其超类定义的<join>，而使用一个外连接来得到其子类定义的<join>。如果设置为select，则 Hibernate 将为子类定义的 <join>使用顺序选择。这仅在一行数据表示一个子类的对象的时候才会发生。对这个类和其超类定义的<join>，依然会使用内连接得到。
td5-1-6-5-1-5 = <code>inverse</code> (可选 - 默认 false): 如果打开，Hibernate 不会插入或者更新此连接定义的属性。
td5-1-6-5-1-6 = <code>optional</code> (可选 - 默认 false): 如果打开，Hibernate 只会在此连接定义的属性非空时插入一行数据，并且总是使用一个外连接来得到这些属性。
p5-1-6-5-7 = 例如, 一个人(person)的地址(address)信息可以被映射到单独的表中(并保留所有属性的值类型语义)：
p5-1-6-5-8 = 此特性常常对遗留数据模型有用。我们推荐表个数比类个数少，以及细粒度的领域模型。然而，在单独的继承树上切换继承映射策略是有用的，后面会解释这点。
 
#		**********************************************************************************************************
#		5.1.7. Mapping one to one and one to many associations
#		**********************************************************************************************************

title5-1-7 = 5.1.7. 映射 一对一 和一对多关联
p5-1-7-1 = 链接一个实体到另一个实体, 你需要映射关联属性为一个 到一 的关联。在这种关联模型中，你可以使用外键或者一张挂链表，或者是两个实体共享相同的主键(不太常用)。
p5-1-7-2 = 使用<code>@ManyToOne</code> 或者 <code>@OnetoOne</code>来标记一个关联。
p5-1-7-3 = <code>@ManyToOne</code> 和 <code>@OneToOne</code> 有一个targetEntity 属性，这个属性指定了目标实体的名字。因为在大部分情况下默认值(表示关联关系的属性类型)就可以很好的满足要求了。不过下面这种情况下这个参数就显得有意义了：使用接口作为返回值而不是常见的实体。
p5-1-7-4 = cascade属性设置为除了none以外任何有意义的值，它将把特定的操作传递到关联对象中。这种有意义的值分为三种：
li5-1-7-1-1 = 基本操作,包括: <code>persist</code>, <code>merge</code>, <code>delete</code>, <code>save-update</code>, <code>evict</code>, <code>replicate</code>, <code>lock</code> 和 <code>refresh</code>;
li5-1-7-1-2 = 特殊的值: delete-orphan 或者 all ; 
li5-1-7-1-3 = 逗号分隔的操作: <code>cascade="persist"</code>,<code>merge</code>,<code>evict</code>. 或者 <code>cascade="all,delete-orphan"</code>. 详细信息参考 <a href="#c11-11">Section 11.11, \u201C持久化的传播\u201D</a> 。单值关联的many-to-one不支持删除孤儿。
p5-1-7-5 = 默认，单向的关联在JPA2中使用饥渴加载。 你可以使用<code>@ManyToOne(fetch=FetchType.LAZY)</code>来把它标记为懒加载，在这种情况下，Hibernate会代理关联，并且在关联实体是可达的时候加载它。你可以使用<code>@LazyToOne(NO_PROXY)</code>来强制Hibernate不适用代理。这时，当实例变量第一次被访问时，属性延迟加载。 这需要构建时字节码编译器。 <code>lazy="false"</code> 表明关联永远被饥渴加载。
p5-1-7-6 = 在JPA的默认选项中, 如果被设置为LAZY，单节点的关联将会使用子查询来加载，如果被设置为EAGER，将会使用SQL链接语句。 然而你可以调整抓取策略， 例如，使用 <code>@Fetch</code>来决定获取策略。 FetchMode 可以是 SELECT (在加载关联时使用查询) 或者 JOIN (使用 SQL JOIN 在加载实体的同时加载关联)。JOIN 覆写了任何lazy属性 (通过JOIN策略加载的关联不可以是Lazy的)。
 
#		**********************************************************************************************************
#		5.1.7.1. Using a foreign key or an association table
#		**********************************************************************************************************

title5-1-7-1 = 5.1.7.1. 使用外键或者关联表
p5-1-7-1-1 = 到一个持久化类的普通关联使用以下定义：
li5-1-7-1-1-1 = <code>@ManyToOne</code> 如果多个实体指向目标实体
li5-1-7-1-1-2 = <code>@OneToOne</code>. 如果只有一个实体指向目标实体。
p5-1-7-1-2 = 并且一个表的外键引用目标表的主键。 
p5-1-7-1-3 = <code>@JoinColumn</code> 属性是可选的，关联字段的默认值,列名为：主体的关联属性名＋下划线＋被关联端的主键列名.在这个例子中是 <code>company_id</code> 因为关联的属性是company, Company的主键是id。
p5-1-7-1-4 = 对于多对一也可以通过关联表的方式来映射。通过<code>@JoinTable</code>注解可定义关联表，该关联表包含了指回实体表的外键(通过<code>@JoinTable.joinColumns</code>) 以及指向目标实体表的外键(通过<code>@JoinTable.inverseJoinColumns</code>)。
nc5-1-7-1-1-1 = 可以使用模拟SQL片段通过 <code>@JoinColumnOrFormula / @JoinColumnOrformulas</code> 注解来模拟物理连接(就像你可以使用 <code>@Formula</code> 注解来模拟一个属性列一样)。
p5-1-7-1-5 = 可以使用optional=false 属性把一个关联标记为必须的。我们推荐使用Bean验证的 @NotNull注解作为更好的选择。因此，外键列将会被标记为非空的（如果有可能的话）。
p5-1-7-1-6 = 如果被关联的元素在数据表中不存在（关联列上id错误），Hibernate就不能够解析这个关联，并且会抛出异常。这对于遗留或者严格维护的模式中是非常不方便的。 你可以使用<code>@NotFound</code> 注解让Hibernate忽略这个元素而不是抛出异常。
p5-1-7-1-7 = 当一个给定实体被删除时，有时候希望把级联删除委托给数据库。在这种情况下Hibernate会在数据库级别上生成级联删除约束。
p5-1-7-1-8 = 外键约束, 当由Hibernate生成时, 名字没有可读性。你可以使用<code>@ForeignKey</code>来覆写这个约束名。
p5-1-7-1-9 = 有时候, 你希望一个实体引用另外的实体，但是不是通过目标实体的主键关联，而是通过某个唯一键关联。你可以在<code>@JoinColumn.referenceColumnName</code>中引用这个唯一键来实现。
p5-1-7-1-10 = 但是并不鼓励这样做，应该按照原来的映射。
p5-1-7-1-11 = 在<code>hbm.xml</code>中, 使用相似的方式映射关联。主要的区别在于<code>@OneToOne</code> 被映射成 <code>&lt;many-to-one unique="true"/&gt;</code>, 我们来深入讨论。
td5-1-7-1-1-1 = <code>name</code>: 属性名。
td5-1-7-1-1-2 = <code>column</code> (可选): 外键列名。 也可以通过嵌入的<code>&lt;column&gt;</code> 元素指定。
td5-1-7-1-1-3 = <code>class</code> (可选 - 默认通过反射获取的属性类型): 关联类的名字。
td5-1-7-1-1-4 = <code>cascade</code> (可选): 指定从父对象到关联对象，应该级联哪些操作。
td5-1-7-1-1-5 = <code>fetch</code> (可选 - 默认 select): 选择 outer-join 抓取 或 连续的查询语句抓取。
td5-1-7-1-1-6 = <code>update, insert</code> (可选 - 默认 true): 表明映射的列应该包含在update 和insert sql语句中。如果都设置为false,则允许使用一个完全派生的属性，它的值由和它映射到相同列的属性或者由一个触发器或其他应用指定。
td5-1-7-1-1-7 = <code>property-ref</code> (可选): 连接到外键的关联类的属性名。如果没有指定，默认使用关联类的主键。
td5-1-7-1-1-8 = <code>access</code> (可选 - 默认 property): Hibernate访问属性值的策略。
td5-1-7-1-1-9 = <code>unique</code> (可选): 为外键列使用DDL生成唯一约束。通过把property-ref的目标设置为唯一的，可以实现多重的一对一。
td5-1-7-1-1-10 = <code>not-null</code> (可选): 使用DDL为该字段添加可否为空（nullability）的约束。
td5-1-7-1-1-11 = <code>optimistic-lock</code> (可选 - 默认 true):指定这个属性在做更新时是否需要获得乐观锁定（optimistic lock）。换句话说，它决定这个属性发生脏数据时版本（version）的值是否增长。
td5-1-7-1-1-12 = <code>lazy</code> (可选 - 默认proxy):默认情况下，单点关联是经过代理的。lazy="no-proxy"指定此属性应该在实例变量第一次被访问时应该延迟抓取（fetche lazily）（需要运行时字节码的增强）。 lazy="false"指定此关联总是被预先抓取。
td5-1-7-1-1-13 = <code>not-found</code> (可选 - 默认 exception): 指定外键引用的数据不存在时如何处理： ignore会将行数据不存在视为一个空（null）关联。
td5-1-7-1-1-14 = <code>entity-name</code> (可选): 被关联的类的实体名。
td5-1-7-1-1-15 = <code>formula</code> (可选): SQL表达式，用于定义computed（计算出的）外键值。
p5-1-7-1-12 = cascade属性设置为除了none以外任何有意义的值，它将把特定的操作传递到关联对象中。这种值被分为三类。首先是基本操作，包括 : persist, merge, delete, save-update, evict, replicate, lock 和 refresh; 以及特别值: delete-orphan和all，并且可以用逗号分隔符 来组合这些操作，例如： <code>cascade="persist,merge,evict"</code> 或者 <code>cascade="all,delete-orphan"</code>. 参考 <a href="#c11-11">Section 11.11, \u201C持久化传播\u201D</a> 获取更多信息。注意，单值关联 (<code>many-to-one</code> 和 <code>one-to-one</code>关联) 不支持删除孤儿 。
p5-1-7-1-13 = 一个典型的简单many-to-one定义例子：
p5-1-7-1-14 = <code>property-ref</code>属性只应该用来对付遗留下来的数据库系统，可能有外键指向对方关联表的是个非主键字段的情况下 这是一种十分丑陋的关系模型。比如说，假设Product类有一个惟一的序列号，它并不是主键。unique属性控制Hibernate通过SchemaExport工具进行的DDL生成。
p5-1-7-1-15 = 那么关于OrderItem 的映射可能是：
p5-1-7-1-16 = 当然，我们决不鼓励这种用法。
p5-1-7-1-17 = 如果被引用的唯一主键由关联实体的多个属性组成， 你应该在名称为<code>&lt;properties&gt;</code>的元素 里面映射所有关联的属性。
p5-1-7-1-18 = 假若被引用的唯一主键是组件的属性，你可以指定属性路径：
 
#		**********************************************************************************************************
#		5.1.7.2. Sharing the primary key with the associated entity
#		**********************************************************************************************************

title5-1-7-2 = 5.1.7.2. 关联实体共享主键
p5-1-7-2-1 = 第二种方法是确保实体和他的关联实体共享主键。在这种情况下，主键列也是外键列，并且没有额外的列。这种关联通常是一对一的。
nc5-1-7-2-1 = 很多人对于基于主键的一对一的关联感到疑惑。如果Hibernate能够知道关联的另一端是永远存在的则可以使用延迟加载。使用<code>@OneToOne(optional=false)</code>来通知Hibernate。
p5-1-7-2-2 = 在 <code>hbm.xml</code>中, 按照下面的映射：
td5-1-7-2-1-1 = <code>name</code>:属性名
td5-1-7-2-1-2 = <code>class</code> (可选 -  默认为通过反射得到的属性类型): 关联类的名称。
td5-1-7-2-1-3 = <code>cascade</code> (可选): 指定从父对象到关联对象，应该级联哪些操作。
td5-1-7-2-1-4 = <code>constrained</code> (可选):  表明该类对应的表对应的数据库表，和被关联的对象所对应的数据库表之间，通过一个外键引用对主键进行约束。 这个选项影响save()和delete()在级联执行时的先后顺序以及 决定该关联能否被委托(也在schema export tool中被使用)。
td5-1-7-2-1-5 = <code>fetch</code> (可选 - 默认 select): 在外连接抓取或者序列选择抓取选择其一.
td5-1-7-2-1-6 = <code>property-ref</code> (可选): 指定关联类的属性名，这个属性将会和本类的主键相对应。如果没有指定，会使用对方关联类的主键。
td5-1-7-2-1-7 = <code>access</code> (可选 - 默认 property): Hibernate用来访问属性的策略。
td5-1-7-2-1-8 = <code>formula</code> (可选): 绝大多数一对一的关联都指向其实体的主键。在一些少见的情况中， 你可能会指向其他的一个或多个字段，或者是一个表达式，这些情况下，你可以用一个SQL公式来表示。 （可以在org.hibernate.test.onetooneformula找到例子）
td5-1-7-2-1-9 = <code>lazy</code> (可选 - defaults to proxy):  默认情况下，单点关联是经过代理的。<code>lazy="no-proxy"</code> 指定此属性应该在实例变量第一次被访问时应该延迟抓取（fetche lazily）（需要运行时字节码的增强）。 <code>lazy="false"</code> 指定此关联总是被预先抓取。注意，如果<code>constrained="false"</code>, 不可能使用代理，Hibernate会采取预先抓取！
td5-1-7-2-1-10 = <code>entity-name</code> (可选):  被关联的类的实体名。
p5-1-7-2-3 = 主键关联不需要额外的表字段；如果两行是通过这种一对一关系相关联的，那么这两行就共享同样的主关键字值。所以如果你希望两个对象通过主键一对一关联，你必须确认它们被赋予同样的标识值！
p5-1-7-2-4 = 对于主键关联, 分别为 <code>Employee</code> and <code>Person</code> 添加如下关联:
p5-1-7-2-5 = 现在我们必须确保PERSON和EMPLOYEE中相关的字段是相等的。我们使用一个被成为foreign的特殊的hibernate标识符生成策略：
p5-1-7-2-6 = 一个刚刚保存的Person实例被赋予和该<code>Person</code>的employee属性所指向的<code>employee</code> 实例同样的关键字值。
#		**********************************************************************************************************
#		5.1.8. Natural-id
#		**********************************************************************************************************

title5-1-8 = 5.1.8. Natural-id
p5-1-8-1 = 尽管我们建议使用无意义的键作为主键，但是你也可是尝试为所有实体使用自然键作为主键。自然间是一个或组合唯一非空属性。它同样是不可修改的。使用<code>@NaturalId</code>或者在<code>&lt;natural-id&gt;</code>元素中定义自然键。Hibernate会生成必要的唯一键和非空约束，你的映射将变得更加self-documenting。
p5-1-8-2 = 或者使用XML,
p5-1-8-3 = 推荐实现<code>equals()</code> 和 <code>hashCode()</code>来比较实体的自然键属性值。
p5-1-8-4 = 这一映射不是为了把自然键作为主键而准备的。
li5-1-8-1-1 = <code>mutable</code> (可选 - 默认为false): 默认情况下，自然键的属性值为不可变的（常量）。
 
#		**********************************************************************************************************
#		5.1.9. Any
#		**********************************************************************************************************

title5-1-9 = 5.1.9. Any
p5-1-9-1 = 这是属性映射的另一种类型。<code>@Any</code>映射定义了一种多表之间的多态关联关系。这种类型的映射需要多个列。第一列包含相关实体的类型。剩下的列包含ID。在这种关联关系中是可以指定一个外键约束的。这不是指定多态映射常用的方式，而且你也应该尽量避免使用这种约束，除非在十分特殊的情况下。比如，对审计日志，用户会话数据等。
p5-1-9-2 = <code>@Any</code>注解描述了列所持有的metadata的信息。如果想将metadata信息和实际的实体类型关联起来，可以使用<code>@AnyDef</code>和<code>@AnyDefs</code>注解。<code>meta-type</code>属性使得应用程序能指定一个将数据库字段的值映射到持久化类的自定义类型。这个持久化类包含有用<code>id-type</code>指定的标识符属性。你必须指定从meta-type的值到类名的映射。
p5-1-9-3 = 注意<code>@AnyDef</code>可以交互和重用。在这个例子中推荐把它放在包的metadata中。
p5-1-9-4 = <code>hbm.xml</code>如下：
nc5-1-9-1 = 在<code>hbm.xml</code>中你不能像在注解中一样进行metadata的交互。
td5-1-9-1-1 = <code>name</code>: 属性名称。
td5-1-9-1-2 = <code>id-type</code>: id类型。
td5-1-9-1-3 = <code>meta-type</code> (可选 - 默认为string): 允许辨别标志(discriminator)映射的任何类型
td5-1-9-1-4 = <code>cascade</code> (可选- 默认为none): 级联类型。
td5-1-9-1-5 = <code>access</code> (可选 - 默认为property): Hibernate用来访问属性值的策略方法。
td5-1-9-1-6 = <code>optimistic-lock</code> (可选 - 默认为true):  表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号(Version)

 
#		**********************************************************************************************************
#		5.1.10. Properties
#		**********************************************************************************************************

title5-1-10 = 5.1.10. Properties
p5-1-10-1 = <code>&lt;properties&gt;</code>元素给定义一个类的属性，这属性已经命名和逻辑分组。 The most important use of the construct is that it allows a combination of properties to be the target of a property-ref. It is also a convenient way to define a multi-column unique constraint. For example:
td5-1-10-1-1 = <code>name</code>: 组的逻辑名称。它不是真正的属性名称。
td5-1-10-1-2 = <code>insert</code>: 在插入SQL语句中显示映射的列名
td5-1-10-1-3 = <code>update</code>: 在更新SQL语句中显示映射的列名
td5-1-10-1-4 = <code>optimistic-lock</code> (可选 - 默认为true): 指定这个属性在做更新时是否需要获得乐观锁定（optimistic lock）。 换句话说，它决定这个属性发生脏数据时版本（version）的值是否增长。
td5-1-10-1-5 = <code>unique</code> (可选 - 默认为false): 指明组件中所有的列是否都有唯一性约束。
p5-1-10-2 = 比如说，如果我们有<code>&lt;properties&gt;</code>映射：
p5-1-10-3 = 你可能会有一些遗留数据指向<code>Person</code>表中这个唯一的键而不是主键。
nc5-1-10-1 = 但是当用注解来定义映射策略时，由于列和与这个列相关的列的绑定已经直接完成了，所以这样的做法是不必要的。
p5-1-10-4 = 像这样在外部映射遗留数据的方式是不被推荐的。
 
#		**********************************************************************************************************
#		5.1.11. Some hbm.xml specificities
#		**********************************************************************************************************

title5-1-11 = 5.1.11. 一些hbm.xml d的特殊性
p5-1-11-1 = <code>hbm.xml</code> 文件有一些使用注解没有的特性，让我们来详细的讨论一下这些特性。
 
#		**********************************************************************************************************
#		5.1.11.1. Doctype
#		**********************************************************************************************************

title5-1-11-1 = 5.1.11.1. Doctype
p5-1-11-1-1 = 所有的XML映射都应该定义dcttype以用来展示。实际的DTD可以在这些地方， 文件夹<code>hibernate-x.x.x/src/org/hibernate</code> ,或者在<code>hibernate3.jar</code>.Hibernate会首先在它的类路径中查找DTD。如果你想通过网络的方式查找DTD，请检查你类路径下的DTD文档。
 
#		**********************************************************************************************************
#		5.1.11.1.1. EntityResolver
#		**********************************************************************************************************

title5-1-11-1-1 = 5.1.11.1.1. 实体解析器
p5-1-11-1-1-1 = Hibernate会首先尝试在它的类路径下解析DTD。它通过注册一个实现了<code>SAXReader</code>的自定义<code>org.xml.sax.EntityResolver</code>来解析这个xml文件。这个自定义的实体解析器可以认识两个不同系统ID的命名空间：
li5-1-11-1-1-1-1 = 无论什么时候只要遇到系统ID以<code>http://www.hibernate.org/dtd/</code>开头，就认为它是<code>hibernate namespace</code>。解析器试图用Hibernate类的classloader来解析。
li5-1-11-1-1-1-2 = 无论什么时候只要遇到系统ID以<code>classpath:// URL protocol</code>开头，就认为它是<code>user namespace</code>。解析器会首先尝试调用当前线程的classloader解析，如果解析失败，再调用Hibernate类的classloader进行解析。
p5-1-11-1-1-2 = 下面是一个使用<code>user namespace</code>的例子：
p5-1-11-1-1-3 = <code>types.xml</code>是一个在<code>your.domain</code>包中的含有自定义typedef的资源。
 
#		**********************************************************************************************************
#		5.1.11.2. Hibernate-mapping
#		**********************************************************************************************************

title5-1-11-2 = 5.1.11.2. Hibernate-mapping
p5-1-11-2-1 = 这个元素有几个可选属性。<code>schema</code>和<code>catalog</code>属性指定了映射中的数据表所属于的模式和/或目录。假若指定了这个属性，表名会加上所指定的schema和catalog的名字扩展为全限定名。假若没有指定，表名就不会使用全限定名。<code>default-cascade</code>属性的作用是猜测没有被指定cascade属性的字段和集合应该使用那种级联关系。默认情况下，<code>auto-import</code>属性允许你在查询语言中可以使用 非全限定名的类名。
td5-1-11-2-1-1 = <code>schema</code> (可选): 数据库模式的名称。
td5-1-11-2-1-2 = <code>catalog</code> (可选): 数据库目录的名称。
td5-1-11-2-1-3 = <code>default-cascade</code> (可选 - 默认为none): 默认使用的级联风格。
td5-1-11-2-1-4 = <code>default-access</code> (可选 - 默认为property): 为了访问所有字段，Hibernate应该使用的策略。它可以是一个自定义的PropertyAccssor。
td5-1-11-2-1-5 = <code>default-lazy</code> (可选 - 默认为true): 当Java属性和集合类没有指定lazy属性时，Hibernate应该使用哪种默认行为。
td5-1-11-2-1-6 = <code>auto-import</code> (可选 - 默认为true): 指定我们是否可以在查询语言中使用非全限定的类名（仅限于本映射文件中的类）。
td5-1-11-2-1-7 = <code>package</code> (可选): 为在映射文档中没有指定全限定类的名称指定一个包前缀。
p5-1-11-2-2 = 如果你有两个持久化类拥有相同的非全限定名称，你应该设置<code>auto-import="false"</code>。如果你试图给两个类分配相同的"import过"的名称，Hibernate会抛出一个异常。
p5-1-11-2-3 = <code>hibernate-mapping</code> 属性允许你嵌套多个如上所示的<code>&lt;class&gt;</code>。但是更好的做法是一个持久化类（或者一个类的继承层次）对应一个映射文件，并以超类的名称命名。例如，<code>Cat.hbm.xml</code>， <code>Dog.hbm.xml</code>或者使用继承，<code>Animal.hbm.xml</code>。
 
#		**********************************************************************************************************
#		5.1.11.3. Key
#		**********************************************************************************************************

title5-1-11-3 = 5.1.11.3. Key
p5-1-11-3-1 = <code>&lt;key&gt;</code>元素在这个教程中出现了很多次。这个元素在父映射元素定义了对新表的连接，并且在被连接表中定义了一个外键引用原表的主键的情况下经常使用。
td5-1-11-3-1-1 = <code>column</code> (可选): 外键列的名称。这个也可以在<code>&lt;column&gt;</code>元素的嵌套中定义。
td5-1-11-3-1-2 = <code>on-delete</code> (可选 - 默认值为noaction): 指明外键约束是否在数据库级别的级联删除时开启。
td5-1-11-3-1-3 = <code>property-ref</code> (可选): 标示外键引用的字段不是原表的主键。提供在遗留数据。
td5-1-11-3-1-4 = <code>not-null</code> (可选): 指定外键列不能为空。这表明无论什么时候外键都是主键的一部分。
td5-1-11-3-1-5 = <code>update</code> (可选): 指明外键永远不能被更新。这表明无论什么时候外键都是主键的一部分。
td5-1-11-3-1-6 = <code>unique</code> (可选): 指明外键应该有唯一性约束。这表明无论什么时候外键都是主键的一部分。
p5-1-11-3-2 = 对于看重删除性能的系统，我们建议所有的键都应该定义为<code>on-delete="cascade"</code>。Hibernate将使用数据库级别的ON CASCADE DELETE约束，而不是多个单独的DELETE语句。 注意，这个特性会绕过 Hibernate 通常对版本数据(versioned data)采用的乐观锁策略。
p5-1-11-3-3 = <code>not-null</code>和<code>update</code>属性在映射但像一对多关联关系时有用。如果你映射一个单向一对多关联到一个非空的外键，你必须用<code>&lt;key not-null="true"&gt;</code>定义这个字段。
 
#		**********************************************************************************************************
#		5.1.11.4. Import
#		**********************************************************************************************************

title5-1-11-4 = 5.1.11.4. Import
p5-1-11-4-1 = 如果你的应用中有两个名字相同的持久化类，而且你不想在Hibernate查询中指定全类名，那么除了依赖<code>auto-import="true"</code>之外，类也可以显示的被引入。你也可以引入没有显示指明的类和接口：
td5-1-11-4-1-1 = <code>class</code>: 任何Java类的全限定名。
td5-1-11-4-1-2 = <code>rename</code> (可选 - 默认情况下为非全限定名): 在查询语言中可以被使用的名称。
nc5-1-11-4-1 = 这个特性只在<code>hbm.xml</code>中存在，在注解时不被支持。
 
#		**********************************************************************************************************
#		5.1.11.5. Column and formula elements
#		**********************************************************************************************************

title5-1-11-5 = 5.1.11.5. 列和公式元素
p5-1-11-5-1 = 就收column属性的元素也会支持<code>&lt;column&gt;</code>子元素。同样的，<code>&lt;formula&gt;</code>也是formula元素的一种选择。比如：
p5-1-11-5-2 = 在<code>column</code>中的大多数属性在自动生成schema时提供了剪切DDL的方法。read和write属性允许你指定自定义的SQL，这个SQLHibernate会用来访问这个列的值。想要获取更多咨询，查看列读写表达式的讨论。
p5-1-11-5-3 = <code>column</code>和<code>formula</code>元素甚至可以用同一个属性或者关联映射被合并起来表示，例如，奇怪的连接条件。
 
#		**********************************************************************************************************
#		5.2. Hibernate types
#		**********************************************************************************************************

title5-2 = 5.2. Hibernate类型
 
#		**********************************************************************************************************
#		5.2.1. Entities and values
#		**********************************************************************************************************

title5-2-1 = 5.2.1. 实体和值
p5-2-1-1 = 按持久化服务来分，Java语言的对象可以大致被分为两组：
p5-2-1-2 = 一个<code>entity</code>独立于任何其他对象引用的实体而存在。对比一般的Java模型，这样一个为被引用的对象将会被当做垃圾清理掉。实体必须被显示的保存和删除。然而对于保存和删除，也可以在操作父实体时级联操作子实体。这一点是和ODMG模式的差别，而且这么做也更加贴合大型系统中的使用逻辑。实体支持循环引用和交叉引用。它们也可以添加版本信息。
p5-2-1-3 = 一个实体的持久状态包含指向其他实体和值类型实例的引用。值类型是原始类型：集合（不是集合中的对象），组件或者特定的不可变对象。与实体不同的是，在特定集合和组件中的值类型，是通过可到达性来进行持久化或是删除操作的。由于值类型和原始类的存储和删除操作设计到它们所包含的实体，所以他们不能单独的标注版本信息。值类型没有独立的id，所以他们不能被两个实体或集合共享。
p5-2-1-4 = 直到现在，我们一直用"持久化类"来形容实体。我们还会继续这么做。不是所有用户定义的类都有持久化状态，但是实体必须有。一个组件是用户定义的有值语义的类。<code>java.lang.String</code>类型的Java属性也是有值语义的。我们给出以下定义，Java中JDK提供给的所有的类型(classes)都是有值语义的，但是用户定义的类型可以被映射到实体或者值语义上。这个决定由应用的开发者决定。在domain模型中的实体类一般都会持有一个那个类的单一引用，然而组合或者聚合一般会被转化为值类型。
p5-2-1-5 = 我们会在本教程中多次提到上面的概念。
p5-2-1-6 = 挑战在于将Java类型系统和开发者定义的实体和值类型映射到SQL/数据库类型系统上。Hiebrate提供了连接两个系统的桥梁。对于实体，<code>&lt;class&gt;</code>, <code>&lt;subclass&gt;</code>等会被使用。对于值类型我们使用<code>&lt;property&gt;</code>, <code>&lt;component&gt;</code>等有<code>type</code>属性的标签。这个属性的值就是Hibernate映射类型的名称。Hibernate为标准的JDK值类型提供了一系列线程的映射类型。你也可以根据自己的转换策略书写自己的映射类型。
p5-2-1-7 = 除了collection之外，所有的内建Hibernate类型都支持<code>null</code>语义。
 
#		**********************************************************************************************************
#		5.2.2. Basic value types
#		**********************************************************************************************************

title5-2-2 = 5.2.2. 基础值类型
p5-2-2-1 = 内建的基础映射类型可以大致的分为以下几类：
dd5-2-2-1-1 = 将Java原始类或封装类映射到适当的SQL类。对于Java的布尔类型或者<code>java.lang.Boolean</code>， <code>yes_no</code>和<code>true_false</code>都可以被选择用来使用。
dd5-2-2-1-2 = 将会把<code>java.lang.String</code>映射到<code>VARCHARA</code>（或者Oracle的<code>VARCHAR2</code>）。
dd5-2-2-1-3 = 将会把<code>java.util.Date</code>和它的子类映射到SQL类型的<code>DATE</code>，<code>TIME</code>和<code>TIMESTAMP</code>。
dd5-2-2-1-4 = 将会把<code>java.util.Calendar</code>映射到SQL类型的<code>TIMESTAMP</code>和<code>DATE</code>。
dd5-2-2-1-5 = 将会把<code>java.math.BigDecimal</code>和<code>java.math.BigInteger</code>映射成<code>NUMERIC</code>（或者Oracle的<code>NUMBER</code>）。
dd5-2-2-1-6 = 将会把<code>java.util.Locale</code>，<code>java.util.TimeZone</code> 和 <code>java.util.Currency</code>映射成<code>VARCHAR</code>（或者Oracle的<code>VARCHAR2</code>）。<code>Locale</code>和<code>Currency</code>的实例将会映射成它们的ISO码。<code>TimeZone</code>的实例将会映射成它们的ID。
dd5-2-2-1-7 = 将会把<code>java.lang.Class</code>映射成<code>VARCHAR</code>（或者Oracle的<code>VARCHAR2</code>）。<code>Class</code>会映射到它的全类名称。
dd5-2-2-1-8 = 将bytpe数组映射成适合的SQL二进制类型。
dd5-2-2-1-9 = 将Java的长字符串映射成SQL的<code>LONGVARCHAR</code>或者<code>TEXT</code>类型。
dd5-2-2-1-10 = 将长byte数组映射成SQL的<code>LONGVARBINARY</code>。
dd5-2-2-1-11 = 将可序列化的Java类型映射成适当的SQL二进制类型。你也可以为一个并非默认为基本类型的可序列化Java类或者接口指定Hibernate类型serializable。
dd5-2-2-1-12 = 是JDBC类型<code>java.sql.Clob</code>和<code>java.sql.Blob</code>的映射类型。这两个类型可能在一些程序中并不适用，因为<code>blob</code>或者<code>clob</code>在事务外不能被重用。驱动对它们的支持也不好。
dd5-2-2-1-13 = 将Java长字符串映射成SQL的<code>CLOB</code>类型。当读到<code>CLOB</code>，它会马上转化为Java的<code>string</code>。一些驱动需要CLOB的值在事务内被读取。一旦被转化成了Java string，它便可以在事务外被访问。
dd5-2-2-1-14 = 将长byte数组映射成SQL的<code>BLOB</code>类型。当读取时，BLOB值会马上转换成byte数组。一些驱动需要BLOB的值在事务中被读取。一旦被转换成byte数组，它便可以在事务外被访问。
dd5-2-2-1-15 = 映射可变的Java类型。只有对不可变的Java类型，Hibernate才会采用特定的优化措施，应用程序会把它当做不可变兑现刚进行处理。比如，对于映射了<code>imm_timestamp</code>的实体来说，你不应该调用<code>Date.setTime()</code>方法。想要改变这个属性的值，并让这个变化持久化，应用程序必须给这个对象分配一个新的，不一样的对象。
p5-2-2-2 = 实体的唯一标示符和集合可以使用除了<code>binary</code>,<code>blob</code>和<code>clob</code>之外的所有基本类型。复合标示符也是被允许的，这将在后面提到。
p5-2-2-3 = 基础的值类型常量在<code>org.hibernate.Hibernate</code>中被定义。比如，<code>Hibernate.STRING</code>代表string类型。
 
#		**********************************************************************************************************
#		5.2.3. Custom value types
#		**********************************************************************************************************

title5-2-3 = 5.2.3. 自定义值类型
p5-2-3-1 = 开发者创建自己的值类型相对简单一些。比如，你可能想要将类型<code>java.lang.BigInteger</code>保存成为数据库中的<code>VARCHAR</code>类。Hibernate并没有内建这样的规则。自定义类型并没有限制将一个属性或者集合元素映射到一张表的一列中去。所以，举例说，你可能有<code>java.lang.String</code>类型的<code>getName()/setName()</code>属性，对应的持久化到<code>FIRST_NAME</code>,<code>INITIAL</code>和<code>SURNAME</code>三列中。
p5-2-3-2 = 想要实现一个自定义类型，需要实现<code>org.hibernate.UserType</code>或者<code>org.hibernate.CompositeUserType</code>，并且用全类名来定义属性。查看 <code>org.hibernate.test.DoubleStringType</code>，看看它是怎么做的。
p5-2-3-3 = 注意这里使用了<code>&lt;column&gt;</code>标签映射了多列。
p5-2-3-4 = <code>CompositeUserType</code>, <code>EnhancedUserType</code>, <code>UserCollectionType</code>, 和 <code>UserVersionType</code>接口提供了更多特别的用法。
p5-2-3-5 = 你甚至可以在映射文件中将参数传给UserType。想要这么做，UserType必须实现<code>org.hibernate.usertype.ParameterizedType</code>接口。想要传递参数给自定义类型，你可以在你的映射文件中使用<code>&lt;type&gt;</code>元素。
p5-2-3-6 = 现在<code>UserType</code>可以从传入的参数值中获得默认的属性值。
p5-2-3-7 = 如果你经常使用一个UserType，那么给它一个短一点的名字是十分有用处的。你可以通过使用<code>&lt;typedef&gt;</code>元素类实现。Typedefs给自定义类型分配了一个名称，如果有参数的话它还会包含一些列的参数默认值。
p5-2-3-8 = 也可以根据具体案例通过属性映射中的类型参数覆盖在typedef中提供的参数。
p5-2-3-9 = 由于Hibernate丰富的内建类型以及对组件的支持，你很少会用到自定义类型，但是在应用中为非实体类使用自定义类型也是一个好办法。比如，一个<code>MonetaryAmount</code>使用<code>CompositeUserType</code>来映射就很不错，虽然它可以被映射成一个组件。这么做的一个原因是抽象。使用自定义类型，金钱显示方式的改变并不会改变你的映射文件。
 
#		**********************************************************************************************************
#		5.3. Mapping a class more than once
#		**********************************************************************************************************

title5-3 = 5.3. 多次映射同一个类
p5-3-1 = 为一个特定的持久化类提供多个映射是可行的。在这种情况下，你必须为实体指定一个名称来消除两个被映射实体的歧义性。默认情况下，实体名和类名相同。Hibernate在操作持久化对象，编写查询语句或者把映射这顶到实体是会让你指定实体名。
p5-3-2 = 这里关联使用了<code>entity-name</code>而不是class。
nc5-3-1 = 这个特性在注解中不被支持。
 
#		**********************************************************************************************************
#		5.4. SQL quoted identifiers
#		**********************************************************************************************************

title5-4 = 5.4. SQL引用标示符
p5-4-1 = 你可通过在映射文档中使用反向引号(`)把表名或者字段名包围起来，以强制Hibernate在生成的SQL中把标识符用引号包围起来。Hibernate会使用相应的SQLDialect(方言)来使用正确的引号风格(通常是双引号，但是在SQL Server中是括号，MySQL中是反向引号)。
 
#		**********************************************************************************************************
#		5.5. Generated properties
#		**********************************************************************************************************

title5-5 = 5.5. 数据库生成属性
p5-5-1 = 数据库生成属性是指数据库生成的具有值的属性。一般来说，如果对象包含由数据库生成的任何属性，Hibernate都需要进行刷新。然而如果将属性标记成generated，应用程序就将控制权交给了Hiberante。当Hibernate执行了插入或更新操作之后，会立即执行select来获得这些生成值。
p5-5-2 = 被标记为generated的属性必须是不可插入也不可更新的。只有<a href="#c5-5">versions</a>, <a href="#c5-1-3-2">timestamps</a>, 和 <a href="#c5-1-4">simple properties</a>可以被标记成generated。
p5-5-3 = <code>never</code> (默认值): 此属性值不由数据库生成。
p5-5-4 = <code>insert</code>: 这个属性值在执行插入操作时生成，但不会在之后的update时重新生成。比如<code>created-date</code>属性就属于这种情况。虽然<a href="#c5-5">versions</a>和<a href="#c5-1-3-2">timestamps</a>可以被标记成generated，但是不能做这个操作。
p5-5-5 = <code>always</code>: 无论插入还是更新操作都会生成这个属性值。
p5-5-6 = 想要将一个属性标记成generated，使用<code>@Generated</code>。
 
#		**********************************************************************************************************
#		5.6. Column transformers: read and write expressions
#		**********************************************************************************************************

title5-6 = 5.6. 列的变化：读和写表达式
p5-6-1 = Hibernate允许你通过映射<a href="#c5-1-4">simple properties</a>来自定义读写所用的SQL。比如，如果你的数据库提供的许多加密方法，你可以像这样为一个单独的列执行它们:
p5-6-2 = 或者用XML
nc5-6-1 = 如果有不止一列需要定义这些规则，你可以使用复数形式<code>@ColumnTransformers</code>。
p5-6-3 = 如果一个属性使用了不止一列，你必须使用<code>forColumn</code>属性来指定表达式指定的哪一列。
p5-6-4 = 当查询中读写属性时，Hibernate会自动使用自定义的表达式，这个功能与派生特性（derived-property ）<code>formula</code>十分相似，但有两个不同点：
li5-6-1-1 = 这个属性值被一个或多个自动生成的列支持。
li5-6-1-2 = 这个属性值可读写，不仅仅是只读。
p5-6-5 = 如果指定了<code>write</code>表达式，那么它必须为值保留一个 ‘？’占位符。
 
#		**********************************************************************************************************
#		5.7. Auxiliary database objects
#		**********************************************************************************************************

title5-7 = 5.7. 辅助数据库对象
p5-7-1 = 辅助数据库对象可以创建和删除任意数据库对象。与Hibernate图表交互工具结合起来，可以根据用户的映射文件生成响应图表。尽管这是为了创建和删除比如触发器，或者存储过程而设计的，但是任何SQL指令都可以通过<code>java.sql.Statement.execute()</code>来执行（比如，ALTERs, INSERTs等）。本质上有两种模式来定义辅助数据库对象：
p5-7-2 = 第一种模式是在映射文件中显示的生命<code>CREATE</code>和<code>DROP</code>命令。
p5-7-3 = 第二种模式是提供一个包含了<code>CREATE</code>和<code>DROP</code>命令的的类。这个自定义类必须实现<code>org.hibernate.mapping.AuxiliaryDatabaseObject</code>接口。
p5-7-4 = 另外，这些数据库对象可以特别指定为仅在特定的方言中才使用。
nc5-7-1 = 在注释模式下不支持这个特性。
