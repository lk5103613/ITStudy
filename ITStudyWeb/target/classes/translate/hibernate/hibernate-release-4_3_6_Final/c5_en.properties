
#		**********************************************************************************************************
#		Chapter 5. Basic O/R Mapping
#		**********************************************************************************************************

title5 = Chapter 5. Basic O/R Mapping

#		**********************************************************************************************************
#		5.1. Mapping declaration
#		**********************************************************************************************************

title5-1 = 5.1. Mapping declaration
p5-1-1 = Object/relational mappings can be defined in three approaches:
li5-1-1 = using Java 5 annotations (via the Java Persistence 2 annotations)
li5-1-2 = using JPA 2 XML deployment descriptors (described in chapter XXX)
li5-1-3 = using the Hibernate legacy XML files approach known as <code>hbm.xml</code>
p5-1-2 = Annotations are split in two categories, the logical mapping annotations (describing the object model, the association between two entities etc.) and the physical mapping annotations (describing the physical schema, tables, columns, indexes, etc). We will mix annotations from both categories in the following code examples.
p5-1-3 = JPA annotations are in the <code>javax.persistence.*</code> package. Hibernate specific extensions are in <code>org.hibernate.annotations.*</code>. You favorite IDE can auto-complete annotations and their attributes for you (even without a specific "JPA" plugin, since JPA annotations are plain Java 5 annotations).
p5-1-4 = Here is an example of mapping
p5-1-5 = The legacy hbm.xml approach uses an XML schema designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations and not table declarations.
p5-1-6 = Please note that even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document. These include XDoclet, Middlegen and AndroMDA.
p5-1-7 = Here is an example mapping:
p5-1-8 = We will now discuss the concepts of the mapping documents (both annotations and XML). We will only describe, however, the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool (for example, the not-null attribute).

#		**********************************************************************************************************
#		5.1.1. Entity
#		**********************************************************************************************************

title5-1-1 = 5.1.1. Entity
p5-1-1-1 = An entity is a regular Java object (aka POJO) which will be persisted by Hibernate.
p5-1-1-2 = To mark an object as an entity in annotations, use the @Entity annotation.
p5-1-1-3 = That's pretty much it, the rest is optional. There are however any options to tweak your entity mapping, let's explore them.
p5-1-1-4 = <code>@Table</code> lets you define the table the entity will be persisted into. If undefined, the table name is the unqualified class name of the entity. You can also optionally define the catalog, the schema as well as unique constraints on the table.
p5-1-1-5 = The constraint name is optional (generated if left undefined). The column names composing the constraint correspond to the column names as defined before the Hibernate NamingStrategy is applied.
tc5-1-1-1 = Be sure to use the database-level column names for the columnNames property of a @UniqueConstraint. For example, whilst for simple types the database-level column name may be the same as the entity-level property name, this is often not the case for relational properties.
p5-1-1-6 = <code>@Entity.name</code> lets you define the shortcut name of the entity you can used in JP-QL and HQL queries. It defaults to the unqualified class name of the class.
p5-1-1-7 = Hibernate goes beyond the JPA specification and provide additional configurations. Some of them are hosted on <code>@org.hibernate.annotations.Entity</code>:
li5-1-1-1 = dynamicInsert / dynamicUpdate (defaults to false): specifies that INSERT / UPDATE SQL should be generated at runtime and contain only the columns whose values are not null. The dynamic-update and dynamic-insert settings are not inherited by subclasses. Although these settings can increase performance in some cases, they can actually decrease performance in others.
li5-1-1-2 = selectBeforeUpdate (defaults to false): specifies that Hibernate should never perform an SQL UPDATE unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using update(), will Hibernate perform an extra SQL SELECT to determine if an UPDATE is actually required. Use of select-before-update will usually decrease performance. It is useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a Session.
li5-1-1-3 = polymorphisms (defaults to IMPLICIT): determines whether implicit or explicit query polymorphisms is used. Implicit polymorphisms means that instances of the class will be returned by a query that names any superclass or implemented interface or class, and that instances of any subclass of the class will be returned by a query that names the class itself. Explicit polymorphisms means that class instances will be returned only by queries that explicitly name that class. Queries that name the class will return only instances of subclasses mapped. For most purposes, the default polymorphisms=IMPLICIT is appropriate. Explicit polymorphisms is useful when two different classes are mapped to the same table This allows a "lightweight" class that contains a subset of the table columns.
li5-1-1-4 = persister: specifies a custom ClassPersister. The persister attribute lets you customize the persistence strategy used for the class. You can, for example, specify your own subclass of org.hibernate.persister.EntityPersister, or you can even provide a completely new implementation of the interface org.hibernate.persister.ClassPersister that implements, for example, persistence via stored procedure calls, serialization to flat files or LDAP. See org.hibernate.test.CustomPersister for a simple example of "persistence" to a Hashtable.
li5-1-1-51 = optimisticLock (defaults to VERSION): determines the optimistic locking strategy. If you enable dynamicUpdate, you will have a choice of optimistic locking strategies:
li5-1-1-5-1 = version: check the version/timestamp columns
li5-1-1-5-2 = all: check all columns
li5-1-1-5-3 = dirty: check the changed columns, allowing some concurrent updates
li5-1-1-5-4 = none: do not use optimistic locking
li5-1-1-52 = It is strongly recommended that you use version/timestamp columns for optimistic locking with Hibernate. This strategy optimizes performance and correctly handles modifications made to detached instances (i.e. when Session.merge() is used).
tc5-1-1-2 = Be sure to import <code>@javax.persistence.Entity</code> to mark a class as an entity. It's a common mistake to import <code>@org.hibernate.annotations.Entity</code> by accident.
p5-1-1-8 = Some entities are not mutable. They cannot be updated by the application. This allows Hibernate to make some minor performance optimizations.. Use the <code>@Immutable</code> annotation.
p5-1-1-9 = You can also alter how Hibernate deals with lazy initialization for this class. On <code>@Proxy</code>, use <code>lazy=false</code> to disable lazy fetching (not recommended). You can also specify an interface to use for lazy initializing proxies (defaults to the class itself): use <code>proxyClass</code> on <code>@Proxy</code>. Hibernate will initially return proxies ( using bytecode provider defined by hibernate.bytecode.provider) that implement the named interface. The persistent object will load when a method of the proxy is invoked. See "Initializing collections and proxies" below.
p5-1-1-10 = <code>@BatchSize</code> specifies a "batch size" for fetching instances of this class by identifier. Not yet loaded instances are loaded batch-size at a time (default 1).
p5-1-1-11 = You can specific an arbitrary SQL WHERE condition to be used when retrieving objects of this class. Use <code>@Where</code> for that.
p5-1-1-12 = In the same vein, <code>@Check</code> lets you define an SQL expression used to generate a multi-row check constraint for automatic schema generation.
p5-1-1-13 = There is no difference between a view and a base table for a Hibernate mapping. This is transparent at the database level, although some DBMS do not support views properly, especially with updates. Sometimes you want to use a view, but you cannot create one in the database (i.e. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression using <code>@org.hibernate.annotations.Subselect</code>:
p5-1-1-14 = Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly and that queries against the derived entity do not return stale data. The <code>&lt;subselect&gt;</code> is available both as an attribute and a nested mapping element.
p5-1-1-15 = We will now explore the same options using the <code>hbm.xml</code> structure. You can declare a persistent class using the class element. For example:
td5-1-1-1 = <code>name</code> (optional): the fully qualified Java class name of the persistent class or interface. If this attribute is missing, it is assumed that the mapping is for a non-POJO entity.
td5-1-1-2 = <code>table</code> (optional - defaults to the unqualified class name): the name of its database table.
td5-1-1-3 = <code>discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses that is used for polymorphic behavior. Acceptable values include null and not null.
td5-1-1-4 = <code>mutable</code> (optional - defaults to true): specifies that instances of the class are (not) mutable.
td5-1-1-5 = <code>schema</code> (optional): overrides the schema name specified by the root <hibernate-mapping> element.
td5-1-1-6 = <code>catalog</code> (optional): overrides the catalog name specified by the root <hibernate-mapping> element.
td5-1-1-7 = <code>proxy</code> (optional): specifies an interface to use for lazy initializing proxies. You can specify the name of the class itself.
td5-1-1-8 = <code>dynamic-update</code> (optional - defaults to false): specifies that UPDATE SQL should be generated at runtime and can contain only those columns whose values have changed.
td5-1-1-9 = <code>dynamic-insert</code> (optional - defaults to false): specifies that INSERT SQL should be generated at runtime and contain only the columns whose values are not null.
td5-1-1-10 = <code>select-before-update</code> (optional - defaults to false): specifies that Hibernate should never perform an SQL UPDATE unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using update(), will Hibernate perform an extra SQL SELECT to determine if an UPDATE is actually required.
td5-1-1-11 = <code>polymorphisms</code> (optional - defaults to implicit): determines whether implicit or explicit query polymorphisms is used.
td5-1-1-12 = <code>where</code> (optional): specifies an arbitrary SQL WHERE condition to be used when retrieving objects of this class.
td5-1-1-13 = <code>persister</code> (optional): specifies a custom ClassPersister.
td5-1-1-14 = <code>batch-size</code> (optional - defaults to 1): specifies a "batch size" for fetching instances of this class by identifier.
td5-1-1-15 = <code>optimistic-lock</code> (optional - defaults to version): determines the optimistic locking strategy.
td5-1-1-16 = <code>lazy</code> (optional): lazy fetching can be disabled by setting lazy="false".
td5-1-1-17 = <code>entity-name</code> (optional - defaults to the class name): Hibernate allows a class to be mapped multiple times, potentially to different tables. It also allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <a href="#c4-4">Section 4.4 Dynamic models</a> and <a href="#c5-1-1">5.1.1 Entity</a> for more information.
td5-1-1-18 = <code>check</code> (optional): an SQL expression used to generate a multi-row check constraint for automatic schema generation.
td5-1-1-19 = <code>rowid</code> (optional): Hibernate can use ROWIDs on databases. On Oracle, for example, Hibernate can use the rowid extra column for fast updates once this option has been set to rowid. A ROWID is an implementation detail and represents the physical location of a stored tuple.
td5-1-1-20 = <code>subselect</code> (optional): maps an immutable and read-only entity to a database subselect. This is useful if you want to have a view instead of a base table. See below for more information.
td5-1-1-21 = <code>abstract</code> (optional): is used to mark abstract superclasses in &lt;union-subclass&gt; hierarchies.
p5-1-1-16 = It is acceptable for the named persistent class to be an interface. You can declare implementing classes of that interface using the &lt;subclass&gt; element. You can persist any static inner class. Specify the class name using the standard form i.e. e.g.Foo$Bar.
p5-1-1-17 = Here is how to do a virtual view (subselect) in XML:
p5-1-1-18 = The &lt;subselect&gt; is available both as an attribute and a nested mapping element.

#		**********************************************************************************************************
#		5.1.2. Identifiers
#		**********************************************************************************************************

title5-1-2 = 5.1.2. Identifiers
p5-1-2-1 = Mapped classes must declare the primary key column of the database table. Most classes will also have a JavaBeans-style property holding the unique identifier of an instance.
p5-1-2-2 = Mark the identifier property with <code>@Id</code>.
p5-1-2-3 = In <code>hbm.xml</code>, use the &lt;id&gt; element which defines the mapping from that property to the primary key column.
td5-1-2-1-1 = <code>name</code> (optional): the name of the identifier property.
td5-1-2-1-2 = <code>type</code> (optional): a name that indicates the Hibernate type.
td5-1-2-1-3 = <code>column</code> (optional - defaults to the property name): the name of the primary key column.
td5-1-2-1-4 = <code>unsaved-value</code> (optional - defaults to a "sensible" value): an identifier property value that indicates an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session.
td5-1-2-1-5 = <code>access</code> (optional - defaults to property): the strategy Hibernate should use for accessing the property value.
p5-1-2-4 = If the <code>name</code> attribute is missing, it is assumed that the class has no identifier property.
p5-1-2-5 = The <code>unsaved-value</code> attribute is almost never needed in Hibernate and indeed has no corresponding element in annotations.
p5-1-2-6 = You can also declare the identifier as a composite identifier. This allows access to legacy data with composite keys. Its use is strongly discouraged for anything else.

#		**********************************************************************************************************
#		5.1.2.1. Composite identifier
#		**********************************************************************************************************

title5-1-2-1 = 5.1.2.1. Composite identifier
p5-1-2-1-1 = You can define a composite primary key through several syntaxes:
li5-1-2-1-1 = use a component type to represent the identifier and map it as a property in the entity: you then annotated the property as @EmbeddedId. The component type has to be Serializable.
li5-1-2-1-2 = map multiple properties as <code>@Id</code> properties: the identifier type is then the entity class itself and needs to be <code>Serializable</code>. This approach is unfortunately not standard and only supported by Hibernate.
li5-1-2-1-3 = map multiple properties as @Id properties and declare an external class to be the identifier type. This class, which needs to be Serializable, is declared on the entity via the @IdClass annotation. The identifier type must contain the same properties as the identifier properties of the entity: each property name must be the same, its type must be the same as well if the entity property is of a basic type, its type must be the type of the primary key of the associated entity if the entity property is an association (either a <code>@OneToOne</code> or a <code>@ManyToOne</code>).
p5-1-2-1-2 = As you can see the last case is far from obvious. It has been inherited from the dark ages of EJB 2 for backward compatibilities and we recommend you not to use it (for simplicity sake).
p5-1-2-1-3 = Let's explore all three cases using examples.

#		**********************************************************************************************************
#		5.1.2.1.1. id as a property using a component type
#		**********************************************************************************************************

title5-1-2-1-1 = 5.1.2.1.1. id as a property using a component type
p5-1-2-1-1-1 = Here is a simple example of <code>@EmbeddedId</code>.
p5-1-2-1-1-2 = You can notice that the <code>UserId</code> class is <code>serializable</code>. To override the column mapping, use <code>@AttributeOverride</code>.
p5-1-2-1-1-3 = An embedded id can itself contains the primary key of an associated entity.
p5-1-2-1-1-4 = In the embedded id object, the association is represented as the identifier of the associated entity. But you can link its value to a regular association in the entity via the @MapsId annotation. The @MapsId value correspond to the property name of the embedded id object containing the associated entity's identifier. In the database, it means that the <code>Customer.user</code> and the <code>CustomerId.userId</code> properties share the same underlying column (<code>user_fk</code> in this case).
tc5-1-2-1-1-1 = The component type used as identifier must implement <code>equals()</code> and <code>hashCode()</code>. 
p5-1-2-1-1-5 = In practice, your code only sets the <code>Customer.user</code> property and the user id value is copied by Hibernate into the <code>CustomerId.userId</code> property.
wc5-1-2-1-1-1 = The id value can be copied as late as flush time, don't rely on it until after flush time.
p5-1-2-1-1-6 = While not supported in JPA, Hibernate lets you place your association directly in the embedded id component (instead of having to use the <code>@MapsId</code> annotation).
p5-1-2-1-1-7 = Let's now rewrite these examples using the <code>hbm.xml</code> syntax.
p5-1-2-1-1-8 = First a simple example:
p5-1-2-1-1-9 = Then an example showing how an association can be mapped.
p5-1-2-1-1-10 = Notice a few things in the previous example:
li5-1-2-1-1-1-1 = the order of the properties (and column) matters. It must be the same between the association and the primary key of the associated entity
li5-1-2-1-1-1-2 = the many to one uses the same columns as the primary key and thus must be marked as read only (<code>insertable</code> and <code>updatable</code> to false).
li5-1-2-1-1-1-3 = unlike with @MapsId, the id value of the associated entity is not transparently copied, check the foreign id generator for more information.
p5-1-2-1-1-11 = The last example shows how to map association directly in the embedded id component.
p5-1-2-1-1-12 = This is the recommended approach to map composite identifier. The following options should not be considered unless some constraint are present.

#		**********************************************************************************************************
#		5.1.2.1.2. Multiple id properties without identifier type
#		**********************************************************************************************************

title5-1-2-1-2 = 5.1.2.1.2. Multiple id properties without identifier type
p5-1-2-1-2-1 = Another, arguably more natural, approach is to place @Id on multiple properties of your entity. This approach is only supported by Hibernate (not JPA compliant) but does not require an extra embeddable component.
p5-1-2-1-2-2 = In this case Customer is its own identifier representation: it must implement Serializable and must implement <code>equals()</code> and <code>hashCode()</code>.
p5-1-2-1-2-3 = In <code>hbm.xml</code>, the same mapping is:

#		**********************************************************************************************************
#		5.1.2.1.3. Multiple id properties with with a dedicated identifier type
#		**********************************************************************************************************

title5-1-2-1-3 = 5.1.2.1.3. Multiple id properties with with a dedicated identifier type
p5-1-2-1-3-1 = @IdClass on an entity points to the class (component) representing the identifier of the class. The properties marked @Id on the entity must have their corresponding property on the @IdClass. The return type of search twin property must be either identical for basic properties or must correspond to the identifier class of the associated entity for an association.
wc5-1-2-1-3-1 = This approach is inherited from the EJB 2 days and we recommend against its use. But, after all it's your application and Hibernate supports it.
p5-1-2-1-3-2 = Customer and CustomerId do have the same properties customerNumber as well as <code>user.CustomerId</code> must be Serializable and implement <code>equals()</code> and <code>hashCode()</code>.
p5-1-2-1-3-3 = While not JPA standard, Hibernate let's you declare the vanilla associated property in the <code>@IdClass</code>.
p5-1-2-1-3-4 = This feature is of limited interest though as you are likely to have chosen the <code>@IdClass</code> approach to stay JPA compliant or you have a quite twisted mind.
p5-1-2-1-3-5 = Here are the equivalent on <code>hbm.xml</code> files:

#		**********************************************************************************************************
#		5.1.2.2. Identifier generator
#		**********************************************************************************************************

title5-1-2-2 = 5.1.2.2. Identifier generator
p5-1-2-2-1 = Hibernate can generate and populate identifier values for you automatically. This is the recommended approach over "business" or "natural" id (especially composite ids).
p5-1-2-2-2 = Hibernate offers various generation strategies, let's explore the most common ones first that happens to be standardized by JPA:
li5-1-2-2-1-1 = IDENTITY: supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type <code>long</code>, <code>short</code> or <code>int</code>.
li5-1-2-2-1-2 = SEQUENCE (called seqhilo in Hibernate): uses a hi/lo algorithm to efficiently generate identifiers of type <code>long</code>, <code>short</code> or <code>int</code>, given a named database sequence.
li5-1-2-2-1-3 = TABLE (called <code>AMultipleHiLoPerTableGenerator</code> in Hibernate) : uses a hi/lo algorithm to efficiently generate identifiers of type long, short or int, given a table and column as a source of hi values. The hi/lo algorithm generates identifiers that are unique only for a particular database.
li5-1-2-2-1-4 = AUTO: selects <code>IDENTITY</code>, <code>SEQUENCE</code> or <code>TABLE</code> depending upon the capabilities of the underlying database.
ic5-1-2-2-1 = We recommend all new projects to use the new enhanced identifier generators. They are deactivated by default for entities using annotations but can be activated using hibernate.id.new_generator_mappings=true. These new generators are more efficient and closer to the JPA 2 specification semantic.<br/>However they are not backward compatible with existing Hibernate based application (if a sequence or a table is used for id generation). See <a href="#c5-1-2-2">5.1.2.2. Identifier generator</a> for more information on how to activate them.
p5-1-2-2-3 = To mark an id property as generated, use the @GeneratedValue annotation. You can specify the strategy used (default to AUTO) by setting <code>strategy</code>.
p5-1-2-2-4 = SEQUENCE and TABLE require additional configurations that you can set using <code>@SequenceGenerator</code> and <code>@TableGenerator</code>:
li5-1-2-2-2-1 = <code>name</code>: name of the generator
li5-1-2-2-2-2 = <code>table / sequenceName</code>: name of the table or the sequence (defaulting respectively to hibernate_sequences and hibernate_sequence)
li5-1-2-2-2-3 = <code>catalog / schema</code>:
li5-1-2-2-2-4 = <code>initialValue</code>: the value from which the id is to start generating
li5-1-2-2-2-5 = <code>allocationSize</code>: the amount to increment by when allocating id numbers from the generator
p5-1-2-2-5 = In addition, the TABLE strategy also let you customize:
li5-1-2-2-3-1 = <code>pkColumnName</code>: the column name containing the entity identifier
li5-1-2-2-3-2 = <code>valueColumnName</code>: the column name containing the identifier value
li5-1-2-2-3-3 = <code>pkColumnValue</code>: the entity identifier
li5-1-2-2-3-4 = <code>uniqueConstraints</code>: any potential column constraint on the table containing the ids
p5-1-2-2-6 = To link a table or sequence generator definition with an actual generated property, use the same name in both the definition name and the <code>generator</code> value generator as shown below.
p5-1-2-2-7 = The scope of a generator definition can be the application or the class. Class-defined generators are not visible outside the class and can override application level generators. Application level generators are defined in JPA's XML deployment descriptors (see <a href="#c5-1-2-2">5.1.2.2. Identifier generator</a>):
p5-1-2-2-8 = If a JPA XML descriptor (like <code>META-INF/orm.xml</code>) is used to define the generators, <code>EMP_GEN</code> and <code>SEQ_GEN</code> are application level generators.
nc5-1-2-2-1 = Package level definition is not supported by the JPA specification. However, you can use the @GenericGenerator at the package level (see <a href="#c5-1-2-2">5.1.2.2. Identifier generator</a>).
p5-1-2-2-9 = These are the four standard JPA generators. Hibernate goes beyond that and provide additional generators or additional options as we will see below. You can also write your own custom identifier generator by implementing <code>org.hibernate.id.IdentifierGenerator</code>.
p5-1-2-2-10 = To define a custom generator, use the <code>@GenericGenerator</code> annotation (and its plural counter part <code>@GenericGenerators</code>) that describes the class of the identifier generator or its short cut name (as described below) and a list of key/value parameters. When using <code>@GenericGenerator</code> and assigning it via <code>@GeneratedValue.generator</code>, the <code>@GeneratedValue.strategy</code> is ignored: leave it blank.
p5-1-2-2-11 = The hbm.xml approach uses the optional <code>&lt;generator&gt;</code> child element inside <code>&lt;id&gt;</code>. If any parameters are required to configure or initialize the generator instance, they are passed using the <code>&lt;param&gt;</code> element.

#		**********************************************************************************************************
#		5.1.2.2.1. Various additional generators
#		**********************************************************************************************************

title5-1-2-2-1 = 5.1.2.2.1. Various additional generators
p5-1-2-2-1-1 = All generators implement the interface <code>org.hibernate.id.IdentifierGenerator</code>. This is a very simple interface. Some applications can choose to provide their own specialized implementations, however, Hibernate provides a range of built-in implementations. The shortcut names for the built-in generators are as follows:
dd5-1-2-2-1-1-1 = generates identifiers of type long, short or int that are unique only when no other process is inserting data into the same table. Do not use in a cluster.
dd5-1-2-2-1-1-2 = supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type <code>long</code>, <code>short</code> or <code>int</code>.
dd5-1-2-2-1-1-3 = uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in Interbase. The returned identifier is of type <code>long</code>, <code>short</code> or <code>int</code>
dd5-1-2-2-1-1-4 = uses a hi/lo algorithm to efficiently generate identifiers of type long, short or int, given a table and column (by default hibernate_unique_key and next_hi respectively) as a source of hi values. The hi/lo algorithm generates identifiers that are unique only for a particular database. 
dd5-1-2-2-1-1-5 = uses a hi/lo algorithm to efficiently generate identifiers of type long, short or int, given a named database sequence.
dd5-1-2-2-1-1-6 = Generates a 128-bit UUID based on a custom algorithm. The value generated is represented as a string of 32 hexidecimal digits. Users can also configure it to use a separator (config parameter "separator") which separates the hexidecimal digits into 5.1.2.2.1. Various additional generators. Note specifically that this is different than the IETF RFC 4122 representation of 8-4-4-4-12. If you need RFC 4122 compliant UUIDs, consider using "uuid2" generator discussed below.
dd5-1-2-2-1-1-7 = Generates a IETF RFC 4122 compliant (variant 2) 128-bit UUID. The exact "version" (the RFC term) generated depends on the pluggable "generation strategy" used (see below). Capable of generating values as java.util.UUID, java.lang.String or as a byte array of length 16 (byte[16]). The "generation strategy" is defined by the interface org.hibernate.id.UUIDGenerationStrategy. The generator defines 2 configuration parameters for defining which generation strategy to use:
dd5-1-2-2-1-1-7-1 = Names the UUIDGenerationStrategy class to use
dd5-1-2-2-1-1-7-2 = Names the UUIDGenerationStrategy instance to use 
p5-1-2-2-1-2 = Out of the box, comes with the following strategies:
li5-1-2-2-1-1-1 = <code>org.hibernate.id.uuid.StandardRandomStrategy</code> (the default) - generates "version 3" (aka, "random") UUID values via the randomUUID method of <code>java.util.UUID</code>
li5-1-2-2-1-1-2 = <code>org.hibernate.id.uuid.CustomVersionOneStrategy</code> - generates "version 1" UUID values, using IP address since mac address not available. If you need mac address to be used, consider leveraging one of the existing third party UUID generators which sniff out mac address and integrating it via the <code>org.hibernate.id.UUIDGenerationStrategy</code> contract. Two such libraries known at time of this writing include <a href="http://johannburkard.de/software/uuid/">http://johannburkard.de/software/uuid/</a> and <a href="http://commons.apache.org/sandbox/id/uuid.html">http://commons.apache.org/sandbox/id/uuid.html</a>
dd5-1-2-2-1-1-8 = uses a database-generated GUID string on MS SQL Server and MySQL.
dd5-1-2-2-1-1-9 = selects <code>identity</code>, <code>sequence</code> or hilo depending upon the capabilities of the underlying database.
dd5-1-2-2-1-1-10 = lets the application assign an identifier to the object before save() is called. This is the default strategy if no <generator> element is specified. 
dd5-1-2-2-1-1-11 = retrieves a primary key, assigned by a database trigger, by selecting the row by some unique key and retrieving the primary key value.
dd5-1-2-2-1-1-12 = uses the identifier of another associated object. It is usually used in conjunction with a <one-to-one> primary key association.
dd5-1-2-2-1-1-13 = a specialized sequence generation strategy that utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to return the generated identifier value as part of the insert statement execution. This strategy is only supported on Oracle 10g drivers targeted for JDK 1.4. Comments on these insert statements are disabled due to a bug in the Oracle drivers.

#		**********************************************************************************************************
#		5.1.2.2.2. Hi/lo algorithm
#		**********************************************************************************************************

title5-1-2-2-2 = 5.1.2.2.2. Hi/lo algorithm
p5-1-2-2-2-1 = The hilo and seqhilo generators provide two alternate implementations of the hi/lo algorithm. The first implementation requires a "special" database table to hold the next available "hi" value. Where supported, the second uses an Oracle-style sequence.
p5-1-2-2-2-2 = Unfortunately, you cannot use hilo when supplying your own Connection to Hibernate. When Hibernate uses an application server datasource to obtain connections enlisted with JTA, you must configure the <code>hibernate.transaction.manager_lookup_class</code>.

#		**********************************************************************************************************
#		5.1.2.2.3. UUID algorithm
#		**********************************************************************************************************

title5-1-2-2-3 = 5.1.2.2.3. UUID algorithm
p5-1-2-2-3-1 = The UUID contains: IP address, startup time of the JVM that is accurate to a quarter second, system time and a counter value that is unique within the JVM. It is not possible to obtain a MAC address or memory address from Java code, so this is the best option without using JNI.

#		**********************************************************************************************************
#		5.1.2.2.4. Identity columns and sequences
#		**********************************************************************************************************

title5-1-2-2-4 = 5.1.2.2.4. Identity columns and sequences
p5-1-2-2-4-1 = For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), you can use identity key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you can use sequence style key generation. Both of these strategies require two SQL queries to insert a new object. For example:
p5-1-2-2-4-2 = For cross-platform development, the native strategy will, depending on the capabilities of the underlying database, choose from the <code>identity</code>, <code>sequence</code> and <code>hilo</code> strategies.

#		**********************************************************************************************************
#		5.1.2.2.5. Assigned identifiers
#		**********************************************************************************************************

title5-1-2-2-5 = 5.1.2.2.5. Assigned identifiers
p5-1-2-2-5-1 = If you want the application to assign identifiers, as opposed to having Hibernate generate them, you can use the assigned generator. This special generator uses the identifier value already assigned to the object's identifier property. The generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do not specify <code>@GeneratedValue</code> nor &lt;generator&gt; elements.
p5-1-2-2-5-2 = The assigned generator makes Hibernate use unsaved-value="undefined". This forces Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <code>Interceptor.isUnsaved()</code>.

#		**********************************************************************************************************
#		5.1.2.2.6. Primary keys assigned by triggers
#		**********************************************************************************************************

title5-1-2-2-6 = 5.1.2.2.6. Primary keys assigned by triggers
p5-1-2-2-6-1 = Hibernate does not generate DDL with triggers. It is for legacy schemas only.
p5-1-2-2-6-2 = In the above example, there is a unique valued property named socialSecurityNumber. It is defined by the class, as a natural key and a surrogate key named person_id, whose value is generated by a trigger.

#		**********************************************************************************************************
#		5.1.2.2.7. Identity copy (foreign generator)
#		**********************************************************************************************************

title5-1-2-2-7 = 5.1.2.2.7. Identity copy (foreign generator)
p5-1-2-2-7-1 = Finally, you can ask Hibernate to copy the identifier from another associated entity. In the Hibernate jargon, it is known as a foreign generator but the JPA mapping reads better and is encouraged.
p5-1-2-2-7-2 = Or alternatively
p5-1-2-2-7-3 = In <code>hbm.xml</code> use the following approach:

#		**********************************************************************************************************
#		5.1.2.3. Enhanced identifier generators
#		**********************************************************************************************************

title5-1-2-3 = 5.1.2.3. Enhanced identifier generators
p5-1-2-3-1 = Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization Optimization means that you do not have to query the database for every request for a new identifier value. These two new generators are intended to take the place of some of the named generators described above, starting in 3.3.x. However, they are included in the current releases and can be referenced by FQN.
p5-1-2-3-2 = The first of these new generators is <code>org.hibernate.id.enhanced.SequenceStyleGenerator</code> which is intended, firstly, as a replacement for the sequence generator and, secondly, as a better portability generator than native. This is because native generally chooses between identity and sequence which have largely different semantics that can cause subtle issues in applications eyeing portability. <code>org.hibernate.id.enhanced.SequenceStyleGenerator</code>, however, achieves portability in a different manner. It chooses between a table or a sequence in the database to store its incrementing values, depending on the capabilities of the dialect being used. The difference between this and native is that table-based and sequence-based storage have the same exact semantic. In fact, sequences are exactly what Hibernate tries to emulate with its table-based generators. This generator has a number of configuration parameters:
li5-1-2-3-1-1 = <code>sequence_name</code> (optional, defaults to hibernate_sequence): the name of the sequence or table to be used.
li5-1-2-3-1-2 = <code>initial_value</code> (optional, defaults to 1): the initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typically named "STARTS WITH".
li5-1-2-3-1-3 = <code>increment_size</code> (optional - defaults to 1): the value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typically named "INCREMENT BY".
li5-1-2-3-1-4 = <code>force_table_use</code> (optional - defaults to false): should we force the use of a table as the backing structure even though the dialect might support sequence?
li5-1-2-3-1-5 = <code>value_column</code> (optional - defaults to next_val): only relevant for table structures, it is the name of the column on the table which is used to hold the value.
li5-1-2-3-1-6 = <code>prefer_sequence_per_entity</code> (optional - defaults to false): should we create separate sequence for each entity that share current generator based on its name?
li5-1-2-3-1-7 = <code>sequence_per_entity_suffix</code> (optional - defaults to _SEQ): suffix added to the name of a dedicated sequence.
li5-1-2-3-1-8 =  optimizer (optional - defaults to none): See Section 5.1.2.3.1, \u201CIdentifier generator optimization\u201D
p5-1-2-3-3 = The second of these new generators is <code>org.hibernate.id.enhanced.TableGenerator</code>, which is intended, firstly, as a replacement for the table generator, even though it actually functions much more like <code>org.hibernate.id.MultipleHiLoPerTableGenerator</code>, and secondly, as a re-implementation of <code>org.hibernate.id.MultipleHiLoPerTableGenerator</code> that utilizes the notion of pluggable optimizers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters:
li5-1-2-3-2-1 = <code>table_name</code> (optional - defaults to hibernate_sequences): the name of the table to be used.
li5-1-2-3-2-2 = <code>value_column_name</code> (optional - defaults to next_val): the name of the column on the table that is used to hold the value.
li5-1-2-3-2-3 = <code>segment_column_name</code> (optional - defaults to sequence_name): the name of the column on the table that is used to hold the "segment key". This is the value which identifies which increment value to use.
li5-1-2-3-2-4 = <code>segment_value</code> (optional - defaults to default): The "segment key" value for the segment from which we want to pull increment values for this generator.
li5-1-2-3-2-5 = <code>segment_value_length</code> (optional - defaults to 255): Used for schema generation; the column size to create this segment key column.
li5-1-2-3-2-6 = <code>initial_value</code> (optional - defaults to 1): The initial value to be retrieved from the table.
li5-1-2-3-2-7= <code>increment_size</code> (optional - defaults to 1): The value by which subsequent calls to the table should differ.
li5-1-2-3-2-8 = <code>optimizer</code> (optional - defaults to 5.1.2.3. Enhanced identifier generators): See <a href="#c5-1-2-3-1">Section 5.1.2.3.1, \u201CIdentifier generator optimization\u201D</a>.

#		**********************************************************************************************************
#		5.1.2.3.1. Identifier generator optimization
#		**********************************************************************************************************

title5-1-2-3-1 = 5.1.2.3.1. Identifier generator optimization
p5-1-2-3-1-1 = For identifier generators that store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you can group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<a href="#c5-1-2-3">Section 5.1.2.3, \u201CEnhanced identifier generators\u201D</a> support this operation.
li5-1-2-3-1-1-1 = <code>none</code> (generally this is the default if no optimizer was specified): this will not perform any optimizations and hit the database for each and every request.
li5-1-2-3-1-1-2 = <code>hilo</code>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the "group number". The increment_size is multiplied by that value in memory to define a group "hi value".
li5-1-2-3-1-1-3 = <code>pooled</code>: as with the case of hilo, this optimizer attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the "next group" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. Here, increment_size refers to the values coming from the database.
 
#		**********************************************************************************************************
#		5.1.2.4. Partial identifier generation
#		**********************************************************************************************************

title5-1-2-4 =  5.1.2.4. Partial identifier generation
p5-1-2-4-1 = Hibernate supports the automatic generation of some of the identifier properties. Simply use the @GeneratedValue annotation on one or several id properties.
wc5-1-2-4-1 = The Hibernate team has always felt such a construct as fundamentally wrong. Try hard to fix your data model before using this feature.
p5-1-2-4-2 = You can also generate properties inside an <code>@EmbeddedId</code> class.
 
#		**********************************************************************************************************
#		5.1.3. Optimistic locking properties (optional)
#		**********************************************************************************************************

title5-1-3 = 5.1.3. Optimistic locking properties (optional)
p5-1-3-1 = When using long transactions or conversations that span several database transactions, it is useful to store versioning data to ensure that if the same entity is updated by two conversations, the last to commit changes will be informed and not override the other conversation's work. It guarantees some isolation while still allowing for good scalability and works particularly well in read-often write-sometimes situations.
p5-1-3-2 = You can use two approaches: a dedicated version number or a timestamp.
p5-1-3-3 = A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other unsaved-value strategies are specified. Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys.
 
#		**********************************************************************************************************
#		5.1.3.1. Version number
#		**********************************************************************************************************

title5-1-3-1 = 5.1.3.1. Version number
p5-1-3-1-1 = You can add optimistic locking capability to an entity using the <code>@Version</code> annotation:
p5-1-3-1-2 = The version property will be mapped to the OPTLOCK column, and the entity manager will use it to detect conflicting updates (preventing lost updates you might otherwise see with the last-commit-wins strategy).
p5-1-3-1-3 = The version column may be a numeric. Hibernate supports any kind of type provided that you define and implement the appropriate <code>UserVersionType</code>.
p5-1-3-1-4 = The application must not alter the version number set up by Hibernate in any way. To artificially increase the version number, check in Hibernate Entity Manager's reference documentation <code>LockModeType.OPTIMISTIC_FORCE_INCREMENT</code> or <code>LockModeType.PESSIMISTIC_FORCE_INCREMENT</code>.
p5-1-3-1-5 = If the version number is generated by the database (via a trigger for example), make sure to use <code>@org.hibernate.annotations.Generated</code>(GenerationTime.ALWAYS).
p5-1-3-1-6 = To declare a version property in <code>hbm.xml</code>, use:
td5-1-3-1-1-1 = <code>column</code> (optional - defaults to the property name): the name of the column holding the version number.
td5-1-3-1-1-2 = <code>name</code>: the name of a property of the persistent class.
td5-1-3-1-1-3 = <code>type</code> (optional - defaults to integer): the type of the version number.
td5-1-3-1-1-4 = <code>access</code> (optional - defaults to property): the strategy Hibernate uses to access the property value.
td5-1-3-1-1-5 = <code>unsaved-value</code> (optional - defaults to undefined): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. Undefined specifies that the identifier property value should be used.
td5-1-3-1-1-6 = <code>generated</code> (optional - defaults to never): specifies that this version property value is generated by the database. See the discussion of <a href="#c5-5">generated properties</a> for more information.
td5-1-3-1-1-7 = <code>insert</code> (optional - defaults to true): specifies whether the version column should be included in SQL insert statements. It can be set to false if the database column is defined with a default value of 0.
 
#		**********************************************************************************************************
#		5.1.3.2. Timestamp
#		**********************************************************************************************************

title5-1-3-2 = 5.1.3.2. Timestamp
p5-1-3-2-1 = Alternatively, you can use a timestamp. Timestamps are a less safe implementation of optimistic locking. However, sometimes an application might use the timestamps in other ways as well.
p5-1-3-2-2 = Simply mark a property of type Date or Calendar as <code>@Version</code>.
p5-1-3-2-3 = When using timestamp versioning you can tell Hibernate where to retrieve the timestamp value from - database or JVM - by optionally adding the <code>@org.hibernate.annotations.Source</code> annotation to the property. Possible values for the value attribute of the annotation are <code>org.hibernate.annotations.SourceType.VM</code> and <code>org.hibernate.annotations.SourceType.DB</code>. The default is <code>SourceType.DB</code> which is also used in case there is no <code>@Source</code> annotation at all.
p5-1-3-2-4 = Like in the case of version numbers, the timestamp can also be generated by the database instead of Hibernate. To do that, use <code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS)</code>.
p5-1-3-2-5 = In <code>hbm.xml</code>, use the <code>&lt;timestamp&gt;</code> element:
td5-1-3-2-1-1 = <code>column</code> (optional - defaults to the property name): the name of a column holding the timestamp.
td5-1-3-2-1-2 = <code>name</code>: the name of a JavaBeans style property of Java type Date or Timestamp of the persistent class.
td5-1-3-2-1-3 = <code>access</code> (optional - defaults to property): the strategy Hibernate uses for accessing the property value.
td5-1-3-2-1-4 = <code>unsaved-value</code> (optional - defaults to null): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. Undefined specifies that the identifier property value should be used.
td5-1-3-2-1-5 = <code>source</code> (optional - defaults to vm): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the "next value". It is safer to use in clustered environments. Not all Dialects are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example).
td5-1-3-2-1-6 = <code>generated</code> (optional - defaults to never): specifies that this timestamp property value is actually generated by the database. See the discussion of generated properties for more information.
nc5-1-3-2-1 = <code>&lt;Timestamp&gt;</code> is equivalent to &lt;version type="timestamp"&gt;. And &lt;timestamp source="db"&gt; is equivalent to &lt;version type="dbtimestamp"&gt;
 
#		**********************************************************************************************************
#		5.1.4. Property
#		**********************************************************************************************************

title5-1-4 = 5.1.4. Property
p5-1-4-1 = You need to decide which property needs to be made persistent in a given entity. This differs slightly between the annotation driven metadata and the <code>hbm.xml</code> files.
 
#		**********************************************************************************************************
#		5.1.4.1. Property mapping with annotations
#		**********************************************************************************************************

title5-1-4-1 = 5.1.4.1. Property mapping with annotations
p5-1-4-1-1 = In the annotations world, every non static non transient property (field or method depending on the access type) of an entity is considered persistent, unless you annotate it as <code>@Transient</code>. Not having an annotation for your property is equivalent to the appropriate <code>@Basic</code> annotation.
p5-1-4-1-2 = The <code>@Basic</code> annotation allows you to declare the fetching strategy for a property. If set to LAZY, specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation, if your classes are not instrumented, property level lazy loading is silently ignored. The default is EAGER. You can also mark a property as not optional thanks to the <code>@Basic.optional</code> attribute. This will ensure that the underlying column are not nullable (if possible). Note that a better approach is to use the <code>@NotNull</code> annotation of the Bean Validation specification.
p5-1-4-1-3 = Let's look at a few examples:
p5-1-4-1-4 = counter, a transient field, and lengthInMeter, a method annotated as <code>@Transient</code>, and will be ignored by the <code>Hibernate.name</code>, <code>length</code>, and <code>firstname</code> properties are mapped persistent and eagerly fetched (the default for simple properties). The detailedComment property value will be lazily fetched from the database once a lazy property of the entity is accessed for the first time. Usually you don't need to lazy simple properties (not to be confused with lazy association fetching). The recommended alternative is to use the projection capability of JP-QL (Java Persistence Query Language) or Criteria queries.
p5-1-4-1-5 = JPA support property mapping of all basic types supported by Hibernate (all basic Java types , their respective wrappers and serializable classes). Hibernate Annotations supports out of the box enum type mapping either into a ordinal column (saving the enum ordinal) or a string based column (saving the enum string representation): the persistence representation, defaulted to ordinal, can be overridden through the <code>@Enumerated</code> annotation as shown in the note property example.
p5-1-4-1-6 = In plain Java APIs, the temporal precision of time is not defined. When dealing with temporal data you might want to describe the expected precision in database. Temporal data can have DATE, TIME, or TIMESTAMP precision (ie the actual date, only the time, or both). Use the <code>@Temporal</code> annotation to fine tune that.
p5-1-4-1-7 = <code>@Lob</code> indicates that the property should be persisted in a Blob or a Clob depending on the property type: java.sql.Clob, Character[], char[] and java.lang.String will be persisted in a Clob. java.sql.Blob, Byte[], byte[] and Serializable type will be persisted in a Blob.
p5-1-4-1-8 = If the property type implements <code>java.io.Serializable</code> and is not a basic type, and if the property is not annotated with <code>@Lob</code>, then the Hibernate serializable type is used.
 
#		**********************************************************************************************************
#		5.1.4.1.1. Type
#		**********************************************************************************************************

title5-1-4-1-1 = 5.1.4.1.1. Type
p5-1-4-1-1-1 = You can also manually specify a type using the @org.hibernate.annotations.Type and some parameters if needed. @Type.type could be:
li5-1-4-1-1-1-1 = The name of a Hibernate basic type: integer, string, character, date, timestamp, float, binary, serializable, object, blob etc.
li5-1-4-1-1-1-2 = The name of a Java class with a default basic type: int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob etc.
li5-1-4-1-1-1-3 = The name of a serializable Java class.
li5-1-4-1-1-1-4 = The class name of a custom type: com.illflow.type.MyCustomType etc.
p5-1-4-1-1-2 = If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4.
p5-1-4-1-1-3 = <code>@org.hibernate.annotations.TypeDef</code> and <code>@org.hibernate.annotations.TypeDefs</code> allows you to declare type definitions. These annotations can be placed at the class or package level. Note that these definitions are global for the session factory (even when defined at the class level). If the type is used on a single entity, you can place the definition on the entity itself. Otherwise, it is recommended to place the definition at the package level. In the example below, when Hibernate encounters a property of class PhoneNumer, it delegates the persistence strategy to the custom mapping type PhoneNumberType. However, properties belonging to other classes, too, can delegate their persistence strategy to PhoneNumberType, by explicitly using the <code>@Type</code> annotation.
nc5-1-4-1-1-1 = Package level annotations are placed in a file named <code>package-info.java</code> in the appropriate package. Place your annotations before the package declaration.
p5-1-4-1-1-4 = The following example shows the usage of the parameters attribute to customize the TypeDef.
p5-1-4-1-1-5 = When using composite user type, you will have to express column definitions. The <code>@Columns</code> has been introduced for that purpose.
 
#		**********************************************************************************************************
#		5.1.4.1.2. Access type
#		**********************************************************************************************************

title5-1-4-1-2 = 5.1.4.1.2. Access type
p5-1-4-1-2-1 = By default the access type of a class hierarchy is defined by the position of the <code>@Id</code> or <code>@EmbeddedId</code> annotations. If these annotations are on a field, then only fields are considered for persistence and the state is accessed via the field. If these annotations are on a getter, then only the getters are considered for persistence and the state is accessed via the getter/setter. That works well in practice and is the recommended approach.
nc5-1-4-1-2-1 = The placement of annotations within a class hierarchy has to be consistent (either field or on property) to be able to determine the default access type. It is recommended to stick to one single annotation placement strategy throughout your whole application.
p5-1-4-1-2-2 = However in some situations, you need to:
li5-1-4-1-2-1-1 = force the access type of the entity hierarchy
li5-1-4-1-2-1-2 = override the access type of a specific entity in the class hierarchy
li5-1-4-1-2-1-3 = override the access type of an embeddable type
p5-1-4-1-2-3 = The best use case is an embeddable class used by several entities that might not use the same access type. In this case it is better to force the access type at the embeddable class level.
p5-1-4-1-2-4 = To force the access type on a given class, use the <code>@Access</code> annotation as showed below:
p5-1-4-1-2-5 = You can also override the access type of a single property while keeping the other properties standard.
p5-1-4-1-2-6 = In this example, the default access type is FIELD except for the orderNumber property. Note that the corresponding field, if any must be marked as <code>@Transient</code> or transient.
nc5-1-4-1-2-1 = The annotation <code>@org.hibernate.annotations.AccessType</code> should be considered deprecated for FIELD and PROPERTY access. It is still useful however if you need to use a custom access type.
 
#		**********************************************************************************************************
#		5.1.4.1.3. Optimistic lock
#		**********************************************************************************************************

title5-1-4-1-3 = 5.1.4.1.3. Optimistic lock
p5-1-4-1-3-1 = It is sometimes useful to avoid increasing the version number even if a given property is dirty (particularly collections). You can do that by annotating the property (or collection) with <code>@OptimisticLock(excluded=true)</code>.
p5-1-4-1-3-2 = More formally, specifies that updates to this property do not require acquisition of the optimistic lock.
 
#		**********************************************************************************************************
#		5.1.4.1.4. Declaring column attributes
#		**********************************************************************************************************

title5-1-4-1-4 = 5.1.4.1.4. Declaring column attributes
p5-1-4-1-4-1 = The column(s) used for a property mapping can be defined using the <code>@Column</code> annotation. Use it to override default values (see the JPA specification for more information on the defaults). You can use this annotation at the property level for properties that are:
li5-1-4-1-4-1-1 = not annotated at all
li5-1-4-1-4-1-2 = annotated with <code>@Basic</code>
li5-1-4-1-4-1-3 = annotated with <code>@Version</code>
li5-1-4-1-4-1-4 =  annotated with <code>@Lob</code>
li5-1-4-1-4-1-5 =  annotated with <code>@Temporal</code>
p5-1-4-1-4-2 = The name property is mapped to the <code>flight_name</code> column, which is not nullable, has a length of 50 and is not updatable (making the property immutable).
p5-1-4-1-4-3 = This annotation can be applied to regular properties as well as <code>@Id</code> or <code>@Version</code> properties.
td5-1-4-1-4-1-1 = <code>name</code> (optional): the column name (default to the property name)
td5-1-4-1-4-1-2 = <code>unique</code> (optional): set a unique constraint on this column or not (default false)
td5-1-4-1-4-1-3 = <code>nullable</code> (optional): set the column as nullable (default true).
td5-1-4-1-4-1-4 = <code>insertable</code> (optional): whether or not the column will be part of the insert statement (default true)
td5-1-4-1-4-1-5 = <code>updatable</code> (optional): whether or not the column will be part of the update statement (default true)
td5-1-4-1-4-1-6 = <code>columnDefinition</code> (optional): override the sql DDL fragment for this particular column (non portable)
td5-1-4-1-4-1-7 = <code>table</code> (optional): define the targeted table (default primary table)
td5-1-4-1-4-1-8 = <code>length</code> (optional): column length (default 255)
td5-1-4-1-4-1-9 = <code>precision</code> (optional): column decimal precision (default 0)
td5-1-4-1-4-1-10 = <code>scale</code> (optional): column decimal scale if useful (default 0)
 
#		**********************************************************************************************************
#		5.1.4.1.5. Formula
#		**********************************************************************************************************

title5-1-4-1-5 = 5.1.4.1.5. Formula
p5-1-4-1-5-1 = Sometimes, you want the Database to do some computation for you rather than in the JVM, you might also create some kind of virtual column. You can use a SQL fragment (aka formula) instead of mapping a property into a column. This kind of property is read only (its value is calculated by your formula fragment).
p5-1-4-1-5-2 = The SQL fragment can be as complex as you want and even include subselects.
 
#		**********************************************************************************************************
#		5.1.4.1.6. Non-annotated property defaults
#		**********************************************************************************************************

title5-1-4-1-6 = 5.1.4.1.6. Non-annotated property defaults
p5-1-4-1-6-1 = If a property is not annotated, the following rules apply:
li5-1-4-1-6-1-1 = If the property is of a single type, it is mapped as <code>@Basic</code>
li5-1-4-1-6-1-2 = Otherwise, if the type of the property is annotated as <code>@Embeddable</code>, it is mapped as <code>@Embedded</code>
li5-1-4-1-6-1-3 = Otherwise, if the type of the property is Serializable, it is mapped as <code>@Basic</code> in a column holding the object in its serialized version
li5-1-4-1-6-1-4 = Otherwise, if the type of the property is java.sql.Clob or java.sql.Blob, it is mapped as @Lob with the appropriate <code>LobType</code>
 
#		**********************************************************************************************************
#		5.1.4.2. Property mapping with hbm.xml
#		**********************************************************************************************************

title5-1-4-2 = 5.1.4.2. Property mapping with <code>hbm.xml</code>
p5-1-4-2-1 = The <code>&lt;property&gt;</code> element declares a persistent JavaBean style property of the class.
td5-1-4-2-1-1 = <code>name</code>: the name of the property, with an initial lowercase letter.
td5-1-4-2-1-2 = <code>column</code> (optional - defaults to the property name): the name of the mapped database table column. This can also be specified by nested <column> element(s).
td5-1-4-2-1-3 = <code>type</code> (optional): a name that indicates the Hibernate type.
td5-1-4-2-1-4 = <code>update</code>, <code>insert</code> (optional - defaults to true): specifies that the mapped columns should be included in SQL UPDATE and/or INSERT statements. Setting both to false allows a pure "derived" property whose value is initialized from some other property that maps to the same column(s), or by a trigger or other application.
td5-1-4-2-1-5 = <code>formula</code> (optional): an SQL expression that defines the value for a computed property. Computed properties do not have a column mapping of their own.
td5-1-4-2-1-6 = <code>access</code> (optional - defaults to property): the strategy Hibernate uses for accessing the property value.
td5-1-4-2-1-7 = <code>lazy</code> (optional - defaults to false): specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation.
td5-1-4-2-1-8 = <code>unique</code> (optional): enables the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a property-ref.
td5-1-4-2-1-9 = <code>not-null</code> (optional): enables the DDL generation of a nullability constraint for the columns.
td5-1-4-2-1-10 = <code>optimistic-lock</code> (optional - defaults to true): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty.
td5-1-4-2-1-11 = <code>generated</code> (optional - defaults to never): specifies that this property value is actually generated by the database. See the discussion of <a href="#c5-5">generated properties</a> for more information.
p5-1-4-2-2 = typename could be:
li5-1-4-2-1-1 = The name of a Hibernate basic type: <code>integer</code>, <code>string</code>, <code>character</code>, <code>date</code>, <code>timestamp</code>, <code>float</code>, <code>binary</code>, <code>serializable</code>, <code>object</code>, <code>blob</code> etc.
li5-1-4-2-1-2 = The name of a Java class with a default basic type: <code>int</code>, <code>float</code>, <code>char</code>, <code>java.lang.String</code>, <code>java.util.Date</code>, <code>java.lang.Integer</code>, <code>java.sql.Clob</code> etc.
li5-1-4-2-1-3 = The name of a serializable Java class.
li5-1-4-2-1-4 = The class name of a custom type: <code>com.illflow.type.MyCustomType</code> etc.
p5-1-4-2-3 = If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4. In certain cases you will need the type attribute. For example, to distinguish between Hibernate.DATE and <code>Hibernate.TIMESTAMP</code>, or to specify a custom type.
p5-1-4-2-4 = The <code>access</code> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify access="field", Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <code>org.hibernate.property.PropertyAccessor</code>.
p5-1-4-2-5 = A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at load time. You declare the computation as an SQL expression. This then translates to a SELECT clause subquery in the SQL query that loads an instance:
p5-1-4-2-6 = You can reference the entity table by not declaring an alias on a particular column. This would be <code>customerId</code> in the given example. You can also use the nested <formula> mapping element if you do not want to use the attribute.
 
#		**********************************************************************************************************
#		5.1.5. Embedded objects (aka components)
#		**********************************************************************************************************

title5-1-5 = 5.1.5. Embedded objects (aka components)
p5-1-5-1 = Embeddable objects (or components) are objects whose properties are mapped to the same table as the owning entity's table. Components can, in turn, declare their own properties, components or collections
p5-1-5-2 = It is possible to declare an embedded component inside an entity and even override its column <code>mapping.Component</code> classes have to be annotated at the class level with the @Embeddable annotation. It is possible to override the column mapping of an embedded object for a particular entity using the <code>@Embedded</code> and <code>@AttributeOverride</code> annotation in the associated property:
p5-1-5-3 = An embeddable object inherits the access type of its owning entity (note that you can override that using the <code>@Access</code> annotation).
p5-1-5-4 = The <code>Person</code> entity has two component properties, homeAddress and bornIn. homeAddress property has not been annotated, but Hibernate will guess that it is a persistent component by looking for the <code>@Embeddable</code> annotation in the Address class. We also override the mapping of a column name (to bornCountryName) with the <code>@Embedded</code> and <code>@AttributeOverride</code> annotations for each mapped attribute of Country. As you can see, Country is also a nested component of Address, again using auto-detection by Hibernate and JPA defaults. Overriding columns of embedded objects of embedded objects is through dotted expressions.
p5-1-5-5 = Hibernate Annotations supports something that is not explicitly supported by the JPA specification. You can annotate a embedded object with the <code>@MappedSuperclass</code> annotation to make the superclass properties persistent (see <code>@MappedSuperclass</code> for more informations).
p5-1-5-6 = You can also use association annotations in an embeddable object (ie <code>@OneToOne</code>, <code>@ManyToOne</code>, <code>@OneToMany</code> or <code>@ManyToMany</code>). To override the association columns you can use <code>@AssociationOverride</code>.
p5-1-5-7 = If you want to have the same embeddable object type twice in the same entity, the column name defaulting will not work as several embedded objects would share the same set of columns. In plain JPA, you need to override at least one set of columns. Hibernate, however, allows you to enhance the default naming mechanism through the NamingStrategy interface. You can write a strategy that prevent name clashing in such a situation. DefaultComponentSafeNamingStrategy is an example of this.
p5-1-5-8 = If a property of the embedded object points back to the owning entity, annotate it with the <code>@Parent</code> annotation. Hibernate will make sure this property is properly loaded with the entity reference.
p5-1-5-9 = In XML, use the <code>&lt;component\&gt;</code> element.
td5-1-5-1-1 = <code>name</code>: the name of the property.
td5-1-5-1-2 = <code>class</code> (optional - defaults to the property type determined by reflection): the name of the component (child) class.
td5-1-5-1-3 = <code>insert</code>: do the mapped columns appear in SQL INSERTs?
td5-1-5-1-4 = <code>update</code>: do the mapped columns appear in SQL UPDATEs?
td5-1-5-1-5 = <code>access</code> (optional - defaults to property): the strategy Hibernate uses for accessing the property value.
td5-1-5-1-6 = <code>lazy</code> (optional - defaults to false): specifies that this component should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation.
td5-1-5-1-7 = <code>optimistic-lock</code> (optional - defaults to true): specifies that updates to this component either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when this property is dirty.
td5-1-5-1-8 = <code>unique</code> (optional - defaults to false): specifies that a unique constraint exists upon all mapped columns of the component.
p5-1-5-10 = The child <code>&lt;property&gt;</code> tags map properties of the child class to table columns.
p5-1-5-11 = The <code>&lt;component&gt;</code> element allows a &lt;parent&gt; subelement that maps a property of the component class as a reference back to the containing entity.
p5-1-5-12 = The <code>&lt;dynamic-component&gt;</code> element allows a Map to be mapped as a component, where the property names refer to keys of the map. See <a href="#c9-5">Section 9.5, \u201CDynamic components\u201D</a> for more information. This feature is not supported in annotations.
 
#		**********************************************************************************************************
#		5.1.6. Inheritance strategy
#		**********************************************************************************************************

title5-1-6 = 5.1.6. Inheritance strategy
p5-1-6-1 = Java is a language supporting polymorphism: a class can inherit from another. Several strategies are possible to persist a class hierarchy:
li5-1-6-1-1 = Single table per class hierarchy strategy: a single table hosts all the instances of a class hierarchy
li5-1-6-1-2 = Joined subclass strategy: one table per class and subclass is present and each table persist the properties specific to a given subclass. The state of the entity is then stored in its corresponding class table and all its superclasses 
li5-1-6-1-3 = Table per class strategy: one table per concrete class and subclass is present and each table persist the properties of the class and its superclasses. The state of the entity is then stored entirely in the dedicated table for its class.
 
#		**********************************************************************************************************
#		5.1.6.1. Single table per class hierarchy strategy
#		**********************************************************************************************************

title5-1-6-1 = 5.1.6.1. Single table per class hierarchy strategy
p5-1-6-1-1 = With this approach the properties of all the subclasses in a given mapped class hierarchy are stored in a single table.
p5-1-6-1-2 = Each subclass declares its own persistent properties and subclasses. Version and id properties are assumed to be inherited from the root class. Each subclass in a hierarchy must define a unique discriminator value. If this is not specified, the fully qualified Java class name is used.
p5-1-6-1-3 = In <code>hbm.xml</code>, for the table-per-class-hierarchy mapping strategy, the <code>&lt;subclass&gt;</code> declaration is used. For example:
td5-1-6-1-1 = <code>name</code>: the fully qualified class name of the subclass. 
td5-1-6-1-2 = <code>discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses.
td5-1-6-1-3 = <code>proxy</code> (optional): specifies a class or interface used for lazy initializing proxies.
td5-1-6-1-4 = <code>lazy</code> (optional - defaults to true): setting lazy="false" disables the use of lazy fetching.
p5-1-6-1-4 = For information about inheritance mappings see <a href="c10">Chapter 10, Inheritance mapping</a>.
 
#		**********************************************************************************************************
#		5.1.6.1.1. Discriminator
#		**********************************************************************************************************

title5-1-6-1-1 = 5.1.6.1.1. Discriminator
p5-1-6-1-1-1 = Discriminators are required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. Hibernate Core supports the follwoing restricted set of types as discriminator column: <code>string</code>, <code>character</code>, <code>integer</code>, <code>byte</code>, <code>short</code>, <code>boolean</code>, <code>yes_no</code>, <code>true_false</code>.
p5-1-6-1-1-2 = Use the <code>@DiscriminatorColumn</code> to define the discriminator column as well as the discriminator type.
nc5-1-6-1-1-1 = The enum DiscriminatorType used in <code>javax.persitence.DiscriminatorColumn</code> only contains the values <code>STRING</code>, <code>CHAR</code> and <code>INTEGER</code> which means that not all Hibernate supported types are available via the <code>@DiscriminatorColumn</code> annotation.
p5-1-6-1-1-3 = You can also use <code>@DiscriminatorFormula</code> to express in SQL a virtual discriminator column. This is particularly useful when the discriminator value can be extracted from one or more columns of the table. Both <code>@DiscriminatorColumn</code> and <code>@DiscriminatorFormula</code> are to be set on the root entity (once per persisted hierarchy).
p5-1-6-1-1-4 = <code>@org.hibernate.annotations.DiscriminatorOptions</code> allows to optionally specify Hibernate specific discriminator options which are not standardized in JPA. The available options are force and insert. The force attribute is useful if the table contains rows with "extra" discriminator values that are not mapped to a persistent class. This could for example occur when working with a legacy database. If force is set to true Hibernate will specify the allowed discriminator values in the SELECT query, even when retrieving all instances of the root class. The second option - insert - tells Hibernate whether or not to include the discriminator column in SQL INSERTs. Usually the column should be part of the INSERT statement, but if your discriminator column is also part of a mapped composite identifier you have to set this option to false.
tc5-1-6-1-1-1 = There is also a <code>@org.hibernate.annotations.ForceDiscriminator</code> annotation which is deprecated since version 3.6. Use <code>@DiscriminatorOptions</code> instead.
p5-1-6-1-1-5 = Finally, use <code>@DiscriminatorValue</code> on each class of the hierarchy to specify the value stored in the discriminator column for a given entity. If you do not set <code>@DiscriminatorValue</code> on a class, the fully qualified class name is used.
p5-1-6-1-1-6 = In <code>hbm.xml</code>, the <code>&lt;discriminator&gt;</code> element is used to define the discriminator column or formula:
td5-1-6-1-1-1-1 = <code>column</code> (optional - defaults to class): the name of the discriminator column.
td5-1-6-1-1-1-2 = <code>type</code> (optional - defaults to string): a name that indicates the Hibernate type
td5-1-6-1-1-1-3 = <code>force</code> (optional - defaults to false): "forces" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the root class.
td5-1-6-1-1-1-4 = <code>insert</code> (optional - defaults to true): set this to false if your discriminator column is also part of a mapped composite identifier. It tells Hibernate not to include the column in SQL INSERTs.
td5-1-6-1-1-1-5 = <code>formula</code> (optional): an arbitrary SQL expression that is executed when a type has to be evaluated. It allows content-based discrimination.
p5-1-6-1-1-7 = Actual values of the discriminator column are specified by the discriminator-value attribute of the <code>&lt;class&gt;</code> and <code>&lt;subclass&gt;</code> elements.
p5-1-6-1-1-8 = The <code>formula</code> attribute allows you to declare an arbitrary SQL expression that will be used to evaluate the type of a row. For example:
 
#		**********************************************************************************************************
#		5.1.6.2. Joined subclass strategy
#		**********************************************************************************************************

title5-1-6-2 = 5.1.6.2. Joined subclass strategy
p5-1-6-2-1 = Each subclass can also be mapped to its own table. This is called the table-per-subclass mapping strategy. An inherited state is retrieved by joining with the table of the superclass. A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier. The primary key of this table is also a foreign key to the superclass table and described by the <code>@PrimaryKeyJoinColumns</code> or the <code>&lt;key&gt;</code> element.
nc5-1-6-2-1 = The table name still defaults to the non qualified class name. Also if <code>@PrimaryKeyJoinColumn</code> is not set, the primary key / foreign key columns are assumed to have the same names as the primary key columns of the primary table of the superclass.
p5-1-6-2-2 = In <code>hbm.xml</code>, use the <code>&lt;joined-subclass&gt;</code> element. For example:
td5-1-6-2-1-1 = <code>name</code>: the fully qualified class name of the subclass.
td5-1-6-2-1-2 = <code>table</code>: the name of the subclass table. 
td5-1-6-2-1-3 = <code>proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies.
td5-1-6-2-1-4 = <code>lazy</code> (optional, defaults to true): setting lazy="false" disables the use of lazy fetching.
p5-1-6-2-3 = Use the <code>&lt;key&gt;</code> element to declare the primary key / foreign key column. The mapping at the start of the chapter would then be re-written as:
p5-1-6-2-4 = For information about inheritance mappings see <a href="#c10">Chapter 10, Inheritance mapping</a>.
 
#		**********************************************************************************************************
#		5.1.6.3. Table per class strategy
#		**********************************************************************************************************

title5-1-6-3 = 5.1.6.3. Table per class strategy
p5-1-6-3-1 = A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class as a separate entity root. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the union subclass mapping.
p5-1-6-3-2 = Or in <code>hbm.xml</code>:
td5-1-6-3-1-1 = <code>name</code>: the fully qualified class name of the subclass. 
td5-1-6-3-1-2 = <code>table</code>: the name of the subclass table.
td5-1-6-3-1-3 = <code>proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies.
td5-1-6-3-1-4 = <code>lazy</code> (optional, defaults to true): setting lazy="false" disables the use of lazy fetching.
p5-1-6-3-3 = No discriminator column or key column is required for this mapping strategy.
p5-1-6-3-4 = For information about inheritance mappings see <a href="#c10">Chapter 10, Inheritance mapping</a>.
 
#		**********************************************************************************************************
#		5.1.6.4. Inherit properties from superclasses
#		**********************************************************************************************************

title5-1-6-4 = 5.1.6.4. Inherit properties from superclasses
p5-1-6-4-1 = This is sometimes useful to share common properties through a technical or a business superclass without including it as a regular mapped entity (ie no specific table for this entity). For that purpose you can map them as <code>@MappedSuperclass</code>.
p5-1-6-4-2 = In database, this hierarchy will be represented as an Order table having the id, lastUpdate and lastUpdater columns. The embedded superclass property mappings are copied into their entity subclasses. Remember that the embeddable superclass is not the root of the hierarchy though.
nc5-1-6-4-1 = Properties from superclasses not mapped as <code>@MappedSuperclass</code> are ignored.
nc5-1-6-4-2 = The default access type (field or methods) is used, unless you use the <code>@Access</code> annotation.
nc5-1-6-4-3 = The same notion can be applied to <code>@Embeddable</code> objects to persist properties from their superclasses. You also need to use <code>@MappedSuperclass</code> to do that (this should not be considered as a standard EJB3 feature though)
nc5-1-6-4-4 = It is allowed to mark a class as <code>@MappedSuperclass</code> in the middle of the mapped inheritance hierarchy.
nc5-1-6-4-5 =  Any class in the hierarchy non annotated with <code>@MappedSuperclass</code> nor <code>@Entity</code> will be ignored.
p5-1-6-4-3 = You can override columns defined in entity superclasses at the root entity level using the <code>@AttributeOverride</code> annotation.
p5-1-6-4-4 = The altitude property will be persisted in an fld_altitude column of table Plane and the propulsion association will be materialized in a fld_propulsion_fk foreign key column.
p5-1-6-4-5 = You can define <code>@AttributeOverride(s)</code> and <code>@AssociationOverride(s)</code> on <code>@Entity</code> classes, <code>@MappedSuperclass</code> classes and properties pointing to an <code>@Embeddable</code> object.
p5-1-6-4-6 = In <code>hbm.xml</code>, simply map the properties of the superclass in the <code>&lt;class&gt;</code> element of the entity that needs to inherit them.
 
#		**********************************************************************************************************
#		5.1.6.5. Mapping one entity to several tables
#		**********************************************************************************************************

title5-1-6-5 = 5.1.6.5. Mapping one entity to several tables
p5-1-6-5-1 = While not recommended for a fresh schema, some legacy databases force your to map a single entity on several tables.
p5-1-6-5-2 = Using the @SecondaryTable or @SecondaryTables class level annotations. To express that a column is in a particular table, use the table parameter of <code>@Column</code> or <code>@JoinColumn</code>.
p5-1-6-5-3 = In this example, name will be in MainCat. storyPart1 will be in Cat1 and storyPart2 will be in Cat2. Cat1 will be joined to MainCat using the cat_id as a foreign key, and Cat2 using id (ie the same column name, the MainCat id column has). Plus a unique constraint on storyPart2 has been set.
p5-1-6-5-4 = There is also additional tuning accessible via the <code>@org.hibernate.annotations.Table</code> annotation:
li5-1-6-5-1-1 = <code>fetch</code>: If set to JOIN, the default, Hibernate will use an inner join to retrieve a secondary table defined by a class or its superclasses and an outer join for a secondary table defined by a subclass. If set to SELECT then Hibernate will use a sequential select for a secondary table defined on a subclass, which will be issued only if a row turns out to represent an instance of the subclass. Inner joins will still be used to retrieve a secondary defined by the class and its superclasses.
li5-1-6-5-1-2 = <code>inverse</code>: If true, Hibernate will not try to insert or update the properties defined by this join. Default to false. 
li5-1-6-5-1-3 = <code>optional</code>: If enabled (the default), Hibernate will insert a row only if the properties defined by this join are non-null and will always use an outer join to retrieve the properties.
li5-1-6-5-1-4 = <code>foreignKey</code>: defines the Foreign Key name of a secondary table pointing back to the primary table.
p5-1-6-5-5 = Make sure to use the secondary table name in the appliesto property
p5-1-6-5-6 = In <code>hbm.xml</code>, use the <code>&lt;join&gt;</code> element.
td5-1-6-5-1-1 = <code>table</code>: the name of the joined table.
td5-1-6-5-1-2 = <code>schema</code> (optional): overrides the schema name specified by the root <hibernate-mapping> element.
td5-1-6-5-1-3 = <code>catalog</code> (optional): overrides the catalog name specified by the root <hibernate-mapping> element.
td5-1-6-5-1-4 = <code>fetch</code> (optional - defaults to join): if set to join, the default, Hibernate will use an inner join to retrieve a <join> defined by a class or its superclasses. It will use an outer join for a <join> defined by a subclass. If set to select then Hibernate will use a sequential select for a <join> defined on a subclass. This will be issued only if a row represents an instance of the subclass. Inner joins will still be used to retrieve a <join> defined by the class and its superclasses.
td5-1-6-5-1-5 = <code>inverse</code> (optional - defaults to false): if enabled, Hibernate will not insert or update the properties defined by this join.
td5-1-6-5-1-6 = <code>optional</code> (optional - defaults to false): if enabled, Hibernate will insert a row only if the properties defined by this join are non-null. It will always use an outer join to retrieve the properties.
p5-1-6-5-7 = For example, address information for a person can be mapped to a separate table while preserving value type semantics for all properties:
p5-1-6-5-8 = This feature is often only useful for legacy data models. We recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later.
 
#		**********************************************************************************************************
#		5.1.7. Mapping one to one and one to many associations
#		**********************************************************************************************************

title5-1-7 = 5.1.7. Mapping one to one and one to many associations
p5-1-7-1 = To link one entity to an other, you need to map the association property as a to one association. In the relational model, you can either use a foreign key or an association table, or (a bit less common) share the same primary key value between the two entities.
p5-1-7-2 = To mark an association, use either <code>@ManyToOne</code> or <code>@OnetoOne</code>.
p5-1-7-3 = <code>@ManyToOne</code> and <code>@OneToOne</code> have a parameter named targetEntity which describes the target entity name. You usually don't need this parameter since the default value (the type of the property that stores the association) is good in almost all cases. However this is useful when you want to use interfaces as the return type instead of the regular entity.
p5-1-7-4 = Setting a value of the cascade attribute to any meaningful value other than nothing will propagate certain operations to the associated object. The meaningful values are divided into three categories.
li5-1-7-1-1 = basic operations, which include: <code>persist</code>, <code>merge</code>, <code>delete</code>, <code>save-update</code>, <code>evict</code>, <code>replicate</code>, <code>lock</code> and <code>refresh</code>;
li5-1-7-1-2 = special values: delete-orphan or all ; 
li5-1-7-1-3 = comma-separated combinations of operation names: <code>cascade="persist"</code>,<code>merge</code>,<code>evict</code>. or <code>cascade="all,delete-orphan"</code>. See <a href="#c11-11">Section 11.11, \u201CTransitive persistence\u201D</a> for a full explanation. Note that single valued many-to-one associations do not support orphan delete.
p5-1-7-5 = By default, single point associations are eagerly fetched in JPA 2. You can mark it as lazily fetched by using <code>@ManyToOne(fetch=FetchType.LAZY)</code> in which case Hibernate will proxy the association and load it when the state of the associated entity is reached. You can force Hibernate not to use a proxy by using <code>@LazyToOne(NO_PROXY)</code>. In this case, the property is fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. <code>lazy="false"</code> specifies that the association will always be eagerly fetched.
p5-1-7-6 = With the default JPA options, single-ended associations are loaded with a subsequent select if set to LAZY, or a SQL JOIN is used for EAGER associations. You can however adjust the fetching strategy, ie how data is fetched by using <code>@Fetch</code>. FetchMode can be SELECT (a select is triggered when the association needs to be loaded) or JOIN (use a SQL JOIN to load the association while loading the owner entity). JOIN overrides any lazy attribute (an association loaded through a JOIN strategy cannot be lazy).
 
#		**********************************************************************************************************
#		5.1.7.1. Using a foreign key or an association table
#		**********************************************************************************************************

title5-1-7-1 = 5.1.7.1. Using a foreign key or an association table
p5-1-7-1-1 = An ordinary association to another persistent class is declared using a
li5-1-7-1-1-1 = <code>@ManyToOne</code> if several entities can point to the the target entity
li5-1-7-1-1-2 = <code>@OneToOne</code>. if only a single entity can point to the the target entity
p5-1-7-1-2 = and a foreign key in one table is referencing the primary key column(s) of the target table. 
p5-1-7-1-3 = The <code>@JoinColumn</code> attribute is optional, the default value(s) is the concatenation of the name of the relationship in the owner side, _ (underscore), and the name of the primary key column in the owned side. In this example <code>company_id</code> because the property name is company and the column id of Company is id.
p5-1-7-1-4 = You can also map a to one association through an association table. This association table described by the <code>@JoinTable</code> annotation will contains a foreign key referencing back the entity table (through <code>@JoinTable.joinColumns</code>) and a a foreign key referencing the target entity table (through <code>@JoinTable.inverseJoinColumns</code>).
nc5-1-7-1-1-1 = You can use a SQL fragment to simulate a physical join column using the <code>@JoinColumnOrFormula / @JoinColumnOrformulas</code> annotations (just like you can use a SQL fragment to simulate a property column via the <code>@Formula</code> annotation).
p5-1-7-1-5 = You can mark an association as mandatory by using the optional=false attribute. We recommend to use Bean Validation's @NotNull annotation as a better alternative however. As a consequence, the foreign key column(s) will be marked as not nullable (if possible).
p5-1-7-1-6 = When Hibernate cannot resolve the association because the expected associated element is not in database (wrong id on the association column), an exception is raised. This might be inconvenient for legacy and badly maintained schemas. You can ask Hibernate to ignore such elements instead of raising an exception using the <code>@NotFound</code> annotation.
p5-1-7-1-7 = Sometimes you want to delegate to your database the deletion of cascade when a given entity is deleted. In this case Hibernate generates a cascade delete constraint at the database level.
p5-1-7-1-8 = Foreign key constraints, while generated by Hibernate, have a fairly unreadable name. You can override the constraint name using <code>@ForeignKey</code>. 
p5-1-7-1-9 = Sometimes, you want to link one entity to an other not by the target entity primary key but by a different unique key. You can achieve that by referencing the unique key column(s) in <code>@JoinColumn.referenceColumnName</code>.
p5-1-7-1-10 = This is not encouraged however and should be reserved to legacy mappings.
p5-1-7-1-11 = In <code>hbm.xml</code>, mapping an association is similar. The main difference is that a <code>@OneToOne</code> is mapped as <code>&lt;many-to-one unique="true"/&gt;</code>, let's dive into the subject.
td5-1-7-1-1-1 = <code>name</code>: the name of the property. 
td5-1-7-1-1-2 = <code>column</code> (optional): the name of the foreign key column. This can also be specified by nested <code>&lt;column&gt;</code> element(s).
td5-1-7-1-1-3 = <code>class</code> (optional - defaults to the property type determined by reflection): the name of the associated class.
td5-1-7-1-1-4 = <code>cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object.
td5-1-7-1-1-5 = <code>fetch</code> (optional - defaults to select): chooses between outer-join fetching or sequential select fetching.
td5-1-7-1-1-6 = <code>update, insert</code> (optional - defaults to true): specifies that the mapped columns should be included in SQL UPDATE and/or INSERT statements. Setting both to false allows a pure "derived" association whose value is initialized from another property that maps to the same column(s), or by a trigger or other application.
td5-1-7-1-1-7 = <code>property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used.
td5-1-7-1-1-8 = <code>access</code> (optional - defaults to property): the strategy Hibernate uses for accessing the property value.
td5-1-7-1-1-9 = <code>unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. By allowing this to be the target of a property-ref, you can make the association multiplicity one-to-one.
td5-1-7-1-1-10 = <code>not-null</code> (optional): enables the DDL generation of a nullability constraint for the foreign key columns.
td5-1-7-1-1-11 = <code>optimistic-lock</code> (optional - defaults to true): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty.
td5-1-7-1-1-12 = <code>lazy</code> (optional - defaults to proxy): by default, single point associations are proxied. <code>lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. lazy="false" specifies that the association will always be eagerly fetched.
td5-1-7-1-1-13 = <code>not-found</code> (optional - defaults to exception): specifies how foreign keys that reference missing rows will be handled. ignore will treat a missing row as a null association.
td5-1-7-1-1-14 = <code>entity-name</code> (optional): the entity name of the associated class.
td5-1-7-1-1-15 = <code>formula</code> (optional): an SQL expression that defines the value for a computed foreign key.
p5-1-7-1-12 = Setting a value of the cascade attribute to any meaningful value other than none will propagate certain operations to the associated object. The meaningful values are divided into three categories. First, basic operations, which include: persist, merge, delete, save-update, evict, replicate, lock and refresh; second, special values: delete-orphan; and third,all comma-separated combinations of operation names: <code>cascade="persist,merge,evict"</code> or <code>cascade="all,delete-orphan"</code>. See <a href="#c11-11">Section 11.11, \u201CTransitive persistence\u201D</a> for a full explanation. Note that single valued, <code>many-to-one</code> and <code>one-to-one</code>, associations do not support orphan delete.
p5-1-7-1-13 = Here is an example of a typical many-to-one declaration:
p5-1-7-1-14 = The <code>property-ref</code> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is a complicated and confusing relational model. For example, if the Product class had a unique serial number that is not the primary key. The unique attribute controls Hibernate's DDL generation with the SchemaExport tool.
p5-1-7-1-15 = Then the mapping for OrderItem might use:
p5-1-7-1-16 = This is not encouraged, however.
p5-1-7-1-17 = If the referenced unique key comprises multiple properties of the associated entity, you should map the referenced properties inside a named <code>&lt;properties&gt;</code> element.
p5-1-7-1-18 = If the referenced unique key is the property of a component, you can specify a property path:
 
#		**********************************************************************************************************
#		5.1.7.2. Sharing the primary key with the associated entity
#		**********************************************************************************************************

title5-1-7-2 = 5.1.7.2. Sharing the primary key with the associated entity
p5-1-7-2-1 = The second approach is to ensure an entity and its associated entity share the same primary key. In this case the primary key column is also a foreign key and there is no extra column. These associations are always one to one.
nc5-1-7-2-1 = Many people got confused by these primary key based one to one associations. They can only be lazily loaded if Hibernate knows that the other side of the association is always present. To indicate to Hibernate that it is the case, use <code>@OneToOne(optional=false)</code>.
p5-1-7-2-2 = In <code>hbm.xml</code>, use the following mapping.
td5-1-7-2-1-1 = <code>name</code>: the name of the property. 
td5-1-7-2-1-2 = <code>class</code> (optional - defaults to the property type determined by reflection): the name of the associated class.
td5-1-7-2-1-3 = <code>cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object.
td5-1-7-2-1-4 = <code>constrained</code> (optional): specifies that a foreign key constraint on the primary key of the mapped table and references the table of the associated class. This option affects the order in which save() and delete() are cascaded, and determines whether the association can be proxied. It is also used by the schema export tool.
td5-1-7-2-1-5 = <code>fetch</code> (optional - defaults to select): chooses between outer-join fetching or sequential select fetching.
td5-1-7-2-1-6 = <code>property-ref</code> (optional): the name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used.
td5-1-7-2-1-7 = <code>access</code> (optional - defaults to property): the strategy Hibernate uses for accessing the property value.
td5-1-7-2-1-8 = <code>formula</code> (optional): almost all one-to-one associations map to the primary key of the owning entity. If this is not the case, you can specify another column, columns or expression to join on using an SQL formula. See <a href="#c5-1-7-2">org.hibernate.test.onetooneformula</a> for an example.
td5-1-7-2-1-9 = <code>lazy</code> (optional - defaults to proxy): by default, single point associations are proxied. <code>lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. <code>lazy="false"</code> specifies that the association will always be eagerly fetched. Note that if <code>constrained="false"</code>, proxying is impossible and Hibernate will eagerly fetch the association.
td5-1-7-2-1-10 = <code>entity-name</code> (optional): the entity name of the associated class.
p5-1-7-2-3 = Primary key associations do not need an extra table column. If two rows are related by the association, then the two table rows share the same primary key value. To relate two objects by a primary key association, ensure that they are assigned the same identifier value.
p5-1-7-2-4 = For a primary key association, add the following mappings to <code>Employee</code> and <code>Person</code> respectively:
p5-1-7-2-5 = Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE tables are equal. You use a special Hibernate identifier generation strategy called <code>foreign</code>:
p5-1-7-2-6 = A newly saved instance of Person is assigned the same primary key value as the Employee instance referred with the <code>employee</code> property of that <code>Person</code>.
 
#		**********************************************************************************************************
#		5.1.8. Natural-id
#		**********************************************************************************************************

title5-1-8 = 5.1.8. Natural-id
p5-1-8-1 = Although we recommend the use of surrogate keys as primary keys, you should try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. It is also immutable. Map the properties of the natural key as <code>@NaturalId</code> or map them inside the <natural-id> element. Hibernate will generate the necessary unique key and nullability constraints and, as a result, your mapping will be more self-documenting.
p5-1-8-2 = Or in XML,
p5-1-8-3 = It is recommended that you implement <code>equals()</code> and <code>hashCode()</code> to compare the natural key properties of the entity.
p5-1-8-4 = This mapping is not intended for use with entities that have natural primary keys.
li5-1-8-1-1 = <code>mutable</code> (optional - defaults to false): by default, natural identifier properties are assumed to be immutable (constant).
 
#		**********************************************************************************************************
#		5.1.9. Any
#		**********************************************************************************************************

title5-1-9 = 5.1.9. Any
p5-1-9-1 = There is one more type of property mapping. The <code>@Any</code> mapping defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases. For example, for audit logs, user session data, etc.
p5-1-9-2 = The <code>@Any</code> annotation describes the column holding the metadata information. To link the value of the metadata information and an actual entity type, The @AnyDef and @AnyDefs annotations are used. The metaType attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by idType. You must specify the mapping from values of the metaType to class names.
p5-1-9-3 = Note that <code>@AnyDef</code> can be mutualized and reused. It is recommended to place it as a package metadata in this case.
p5-1-9-4 = The <code>hbm.xml</code> equivalent is:
nc5-1-9-1 = You cannot mutualize the metadata in <code>hbm.xml</code> as you can in annotations.
td5-1-9-1-1 = <code>name</code>: the property name.
td5-1-9-1-2 = <code>id-type</code>: the identifier type.
td5-1-9-1-3 = <code>meta-type</code> (optional - defaults to string): any type that is allowed for a discriminator mapping.
td5-1-9-1-4 = <code>cascade</code> (optional- defaults to none): the cascade style.
td5-1-9-1-5 = <code>access</code> (optional - defaults to property): the strategy Hibernate uses for accessing the property value.
td5-1-9-1-6 = <code>optimistic-lock</code> (optional - defaults to true): specifies that updates to this property either do or do not require acquisition of the optimistic lock. It defines whether a version increment should occur if this property is dirty.
 
#		**********************************************************************************************************
#		5.1.10. Properties
#		**********************************************************************************************************

title5-1-10 = 5.1.10. Properties
p5-1-10-1 = The <code>&lt;properties&gt;</code> element allows the definition of a named, logical grouping of the properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a property-ref. It is also a convenient way to define a multi-column unique constraint. For example:
td5-1-10-1-1 = <code>name</code>: the logical name of the grouping. It is not an actual property name.
td5-1-10-1-2 = <code>insert</code>: do the mapped columns appear in SQL INSERTs?
td5-1-10-1-3 = <code>update</code>: do the mapped columns appear in SQL UPDATEs?
td5-1-10-1-4 = <code>optimistic-lock</code> (optional - defaults to true): specifies that updates to these properties either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when these properties are dirty.
td5-1-10-1-5 = <code>unique</code> (optional - defaults to false): specifies that a unique constraint exists upon all mapped columns of the component.
p5-1-10-2 = For example, if we have the following <code>&lt;properties&gt;</code> mapping:
p5-1-10-3 = You might have some legacy data association that refers to this unique key of the <code>Person</code> table, instead of to the primary key:
nc5-1-10-1 = When using annotations as a mapping strategy, such construct is not necessary as the binding between a column and its related column on the associated table is done directly
p5-1-10-4 = The use of this outside the context of mapping legacy data is not recommended.
 
#		**********************************************************************************************************
#		5.1.11. Some hbm.xml specificities
#		**********************************************************************************************************

title5-1-11 = 5.1.11. Some hbm.xml specificities
p5-1-11-1 = The hbm.xml structure has some specificities naturally not present when using annotations, let's describe them briefly.
 
#		**********************************************************************************************************
#		5.1.11.1. Doctype
#		**********************************************************************************************************

title5-1-11-1 = 5.1.11.1. Doctype
p5-1-11-1-1 = All XML mappings should declare the doctype shown. The actual DTD can be found at the URL above, in the directory <code>hibernate-x.x.x/src/org/hibernate</code> , or in <code>hibernate3.jar</code>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check the DTD declaration against the contents of your classpath.
 
#		**********************************************************************************************************
#		5.1.11.1.1. EntityResolver
#		**********************************************************************************************************

title5-1-11-1-1 = 5.1.11.1.1. EntityResolver
p5-1-11-1-1-1 = Hibernate will first attempt to resolve DTDs in its classpath. It does this is by registering a custom <code>org.xml.sax.EntityResolver</code> implementation with the SAXReader it uses to read in the xml files. This custom EntityResolver recognizes two different systemId namespaces:
li5-1-11-1-1-1-1 = a <code>hibernate namespace</code> is recognized whenever the resolver encounters a systemId starting with <code>http://www.hibernate.org/dtd/</code>. The resolver attempts to resolve these entities via the classloader which loaded the Hibernate classes.
li5-1-11-1-1-1-2 = a <code>user namespace</code> is recognized whenever the resolver encounters a systemId using a <code>classpath:// URL protocol</code>. The resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes.
p5-1-11-1-1-2 = The following is an example of utilizing user namespacing:
p5-1-11-1-1-3 = Where <code>types.xml</code> is a resource in the <code>your.domain</code> package and contains a custom typedef.
 
#		**********************************************************************************************************
#		5.1.11.2. Hibernate-mapping
#		**********************************************************************************************************

title5-1-11-2 = 5.1.11.2. Hibernate-mapping
p5-1-11-2-1 = This element has several optional attributes. The schema and catalog attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If they are specified, tablenames will be qualified by the given schema and catalog names. If they are missing, tablenames will be unqualified. The default-cascade attribute specifies what cascade style should be assumed for properties and collections that do not specify a cascade attribute. By default, the auto-import attribute allows you to use unqualified class names in the query language.
td5-1-11-2-1-1 = <code>schema</code> (optional): the name of a database schema.
td5-1-11-2-1-2 = <code>catalog</code> (optional): the name of a database catalog.
td5-1-11-2-1-3 = <code>default-cascade</code> (optional - defaults to none): a default cascade style.
td5-1-11-2-1-4 = <code>default-access</code> (optional - defaults to property): the strategy Hibernate should use for accessing all properties. It can be a custom implementation of PropertyAccessor.
td5-1-11-2-1-5 = <code>default-lazy</code> (optional - defaults to true): the default value for unspecified lazy attributes of class and collection mappings.
td5-1-11-2-1-6 = <code>auto-import</code> (optional - defaults to true): specifies whether we can use unqualified class names of classes in this mapping in the query language.
td5-1-11-2-1-7 = <code>package</code> (optional): specifies a package prefix to use for unqualified class names in the mapping document.
p5-1-11-2-2 = If you have two persistent classes with the same unqualified name, you should set <code>auto-import="false"</code>. An exception will result if you attempt to assign two classes to the same "imported" name.
p5-1-11-2-3 = The <code>hibernate-mapping</code> element allows you to nest several persistent &lt;class&gt; mappings, as shown above. It is, however, good practice (and expected by some tools) to map only a single persistent class, or a single class hierarchy, in one mapping file and name it after the persistent superclass. For example, <code>Cat.hbm.xml</code>, <code>Dog.hbm.xml</code>, or if using inheritance, <code>Animal.hbm.xml</code>.
 
#		**********************************************************************************************************
#		5.1.11.3. Key
#		**********************************************************************************************************

title5-1-11-3 = 5.1.11.3. Key
p5-1-11-3-1 = The <code>&lt;key&gt;</code> element is featured a few times within this guide. It appears anywhere the parent mapping element defines a join to a new table that references the primary key of the original table. It also defines the foreign key in the joined table:
td5-1-11-3-1-1 = <code>column</code> (optional): the name of the foreign key column. This can also be specified by nested <code>&lt;column&gt;</code> element(s).
td5-1-11-3-1-2 = <code>on-delete</code> (optional - defaults to noaction): specifies whether the foreign key constraint has database-level cascade delete enabled.
td5-1-11-3-1-3 = <code>property-ref</code> (optional): specifies that the foreign key refers to columns that are not the primary key of the original table. It is provided for legacy data.
td5-1-11-3-1-4 = <code>not-null</code> (optional): specifies that the foreign key columns are not nullable. This is implied whenever the foreign key is also part of the primary key.
td5-1-11-3-1-5 = <code>update</code> (optional): specifies that the foreign key should never be updated. This is implied whenever the foreign key is also part of the primary key.
td5-1-11-3-1-6 = <code>unique</code> (optional): specifies that the foreign key should have a unique constraint. This is implied whenever the foreign key is also the primary key.
p5-1-11-3-2 = For systems where delete performance is important, we recommend that all keys should be defined <code>on-delete="cascade"</code>. Hibernate uses a database-level ON CASCADE DELETE constraint, instead of many individual DELETE statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data.
p5-1-11-3-3 = The <code>not-null</code> and <code>update</code> attributes are useful when mapping a unidirectional one-to-many association. If you map a unidirectional <code>one-to-many</code> association to a non-nullable foreign key, you must declare the key column using <code>&lt;key not-null="true"&gt;</code>. 
 
#		**********************************************************************************************************
#		5.1.11.4. Import
#		**********************************************************************************************************

title5-1-11-4 = 5.1.11.4. Import
p5-1-11-4-1 = If your application has two persistent classes with the same name, and you do not want to specify the fully qualified package name in Hibernate queries, classes can be "imported" explicitly, rather than relying upon <code>auto-import="true"</code>. You can also import classes and interfaces that are not explicitly mapped:
td5-1-11-4-1-1 = <code>class</code>: the fully qualified class name of any Java class.
td5-1-11-4-1-2 = <code>rename</code> (optional - defaults to the unqualified class name): a name that can be used in the query language.
nc5-1-11-4-1 = This feature is unique to hbm.xml and is not supported in annotations.
 
#		**********************************************************************************************************
#		5.1.11.5. Column and formula elements
#		**********************************************************************************************************

title5-1-11-5 = 5.1.11.5. Column and formula elements
p5-1-11-5-1 = Mapping elements which accept a column attribute will alternatively accept a <code>&lt;column&gt;</code> subelement. Likewise, <code>&lt;formula&gt;</code> is an alternative to the formula attribute. For example:
p5-1-11-5-2 = Most of the attributes on <code>column</code> provide a means of tailoring the DDL during automatic schema generation. The read and write attributes allow you to specify custom SQL that Hibernate will use to access the column's value. For more on this, see the discussion of column read and write expressions.
p5-1-11-5-3 = The <code>column</code> and <code>formula</code> elements can even be combined within the same property or association mapping to express, for example, exotic join conditions.
 
#		**********************************************************************************************************
#		5.2. Hibernate types
#		**********************************************************************************************************

title5-2 = 5.2. Hibernate types
 
#		**********************************************************************************************************
#		5.2.1. Entities and values
#		**********************************************************************************************************

title5-2-1 = 5.2.1. Entities and values
p5-2-1-1 = In relation to the persistence service, Java language-level objects are classified into two groups:
p5-2-1-2 = An <code>entity</code> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model, where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted. Saves and deletions, however, can be cascaded from a parent entity to its children. This is different from the ODMG model of object persistence by reachability and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They can also be versioned.
p5-2-1-3 = An entity's persistent state consists of references to other entities and instances of value types. Values are primitives: collections (not what is inside a collection), components and certain immutable objects. Unlike entities, values in particular collections and components, are persisted and deleted by reachability. Since value objects and primitives are persisted and deleted along with their containing entity, they cannot be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections.
p5-2-1-4 = Until now, we have been using the term "persistent class" to refer to entities. We will continue to do that. Not all user-defined classes with a persistent state, however, are entities. A component is a user-defined class with value semantics. A Java property of type java.lang.String also has value semantics. Given this definition, all types (classes) provided by the JDK have value type semantics in Java, while user-defined types can be mapped with entity or value type semantics. This decision is up to the application developer. An entity class in a domain model will normally have shared references to a single instance of that class, while composition or aggregation usually translates to a value type.
p5-2-1-5 = We will revisit both concepts throughout this reference guide.
p5-2-1-6 = The challenge is to map the Java type system, and the developers' definition of entities and value types, to the SQL/database type system. The bridge between both systems is provided by Hibernate. For entities, <code>&lt;class&gt;</code>, <code>&lt;subclass&gt;</code> and so on are used. For value types we use <code>&lt;property&gt;</code>, <code>&lt;component&gt;</code>etc., that usually have a type attribute. The value of this attribute is the name of a Hibernate mapping type. Hibernate provides a range of mappings for standard JDK value types out of the box. You can write your own mapping types and implement your own custom conversion strategies.
p5-2-1-7 = With the exception of collections, all built-in Hibernate types support null semantics.
 
#		**********************************************************************************************************
#		5.2.2. Basic value types
#		**********************************************************************************************************

title5-2-2 = 5.2.2. Basic value types
p5-2-2-1 = The built-in basic mapping types can be roughly categorized into the following:
dd5-2-2-1-1 = Type mappings from Java primitives or wrapper classes to appropriate (vendor-specific) SQL column types. boolean, <code>yes_no</code> and <code>true_false</code> are all alternative encodings for a Java boolean or <code>java.lang.Boolean</code>.
dd5-2-2-1-2 = A type mapping from <code>java.lang.String</code> to VARCHAR (or Oracle VARCHAR2).
dd5-2-2-1-3 = Type mappings from <code>java.util.Date</code> and its subclasses to SQL types DATE, TIME and TIMESTAMP (or equivalent).
dd5-2-2-1-4 = Type mappings from <code>java.util.Calendar</code> to SQL types TIMESTAMP and DATE (or equivalent).
dd5-2-2-1-5 = Type mappings from <code>java.math.BigDecimal</code> and <code>java.math.BigInteger</code> to NUMERIC (or Oracle NUMBER).
dd5-2-2-1-6 = Type mappings from <code>java.util.Locale</code>, <code>java.util.TimeZone</code> and <code>java.util.Currency</code> to VARCHAR (or Oracle VARCHAR2). Instances of Locale and Currency are mapped to their ISO codes. Instances of TimeZone are mapped to their ID.
dd5-2-2-1-7 = A type mapping from <code>java.lang.Class</code> to VARCHAR (or Oracle VARCHAR2). A Class is mapped to its fully qualified name.
dd5-2-2-1-8 = Maps byte arrays to an appropriate SQL binary type.
dd5-2-2-1-9 = Maps long Java strings to a SQL LONGVARCHAR or TEXT type.
dd5-2-2-1-10 = Maps long byte arrays to a SQL LONGVARBINARY.
dd5-2-2-1-11 = Maps serializable Java types to an appropriate SQL binary type. You can also indicate the Hibernate type serializable with the name of a serializable Java class or interface that does not default to a basic type.
dd5-2-2-1-12 = Type mappings for the JDBC classes <code>java.sql.Clob</code> and <code>java.sql.Blob</code>. These types can be inconvenient for some applications, since the blob or clob object cannot be reused outside of a transaction. Driver support is patchy and inconsistent.
dd5-2-2-1-13 = Maps long Java strings to a SQL CLOB type. When read, the CLOB value is immediately materialized into a Java string. Some drivers require the CLOB value to be read within a transaction. Once materialized, the Java string is available outside of the transaction.
dd5-2-2-1-14 = Maps long Java byte arrays to a SQL BLOB type. When read, the BLOB value is immediately materialized into a byte array. Some drivers require the BLOB value to be read within a transaction. Once materialized, the byte array is available outside of the transaction.
dd5-2-2-1-15 = Type mappings for what are considered mutable Java types. This is where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call Date.setTime() for an instance mapped as imm_timestamp. To change the value of the property, and have that change made persistent, the application must assign a new, nonidentical, object to the property.
p5-2-2-2 = Unique identifiers of entities and collections can be of any basic type except binary, blob and clob. Composite identifiers are also allowed. See below for more information.
p5-2-2-3 = The basic value types have corresponding Type constants defined on <code>org.hibernate.Hibernate</code>. For example, <code>Hibernate.STRING</code> represents the string type.
 
#		**********************************************************************************************************
#		5.2.3. Custom value types
#		**********************************************************************************************************

title5-2-3 = 5.2.3. Custom value types
p5-2-3-1 = It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <code>java.lang.BigInteger</code> to VARCHAR columns. Hibernate does not provide a built-in type for this. Custom types are not limited to mapping a property, or collection element, to a single table column. So, for example, you might have a Java property <code>getName()/setName()</code> of type <code>java.lang.String</code> that is persisted to the columns FIRST_NAME, INITIAL, SURNAME.
p5-2-3-2 = To implement a custom type, implement either <code>org.hibernate.UserType</code> or org.hibernate.CompositeUserType and declare properties using the fully qualified classname of the type. View <code>org.hibernate.test.DoubleStringType</code>  to see the kind of things that are possible.
p5-2-3-3 = Notice the use of <code>&lt;column&gt;</code> tags to map a property to multiple columns.
p5-2-3-4 = The <code>CompositeUserType</code>, <code>EnhancedUserType</code>, <code>UserCollectionType</code>, and <code>UserVersionType</code> interfaces provide support for more specialized uses.
p5-2-3-5 = You can even supply parameters to a UserType in the mapping file. To do this, your UserType must implement the <code>org.hibernate.usertype.ParameterizedType</code> interface. To supply parameters to your custom type, you can use the <code>&lt;type&gt;</code> element in your mapping files.
p5-2-3-6 = The <code>UserType</code> can now retrieve the value for the parameter named default from the Properties object passed to it.
p5-2-3-7 = If you regularly use a certain UserType, it is useful to define a shorter name for it. You can do this using the <code>&lt;typedef&gt;</code> element. Typedefs assign a name to a custom type, and can also contain a list of default parameter values if the type is parameterized.
p5-2-3-8 = It is also possible to override the parameters supplied in a typedef on a case-by-case basis by using type parameters on the property mapping.
p5-2-3-9 = Even though Hibernate's rich range of built-in types and support for components means you will rarely need to use a custom type, it is considered good practice to use custom types for non-entity classes that occur frequently in your application. For example, a <code>MonetaryAmount</code> class is a good candidate for a <code>CompositeUserType</code>, even though it could be mapped as a component. One reason for this is abstraction. With a custom type, your mapping documents would be protected against changes to the way monetary values are represented.
 
#		**********************************************************************************************************
#		5.3. Mapping a class more than once
#		**********************************************************************************************************

title5-3 = 5.3. Mapping a class more than once
p5-3-1 = It is possible to provide more than one mapping for a particular persistent class. In this case, you must specify an entity name to disambiguate between instances of the two mapped entities. By default, the entity name is the same as the class name. Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity.
p5-3-2 = Associations are now specified using <code>entity-name</code> instead of class.
nc5-3-1 = This feature is not supported in Annotations
 
#		**********************************************************************************************************
#		5.4. SQL quoted identifiers
#		**********************************************************************************************************

title5-4 = 5.4. SQL quoted identifiers
p5-4-1 = You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL Dialect. This is usually double quotes, but the SQL Server uses brackets and MySQL uses backticks.
 
#		**********************************************************************************************************
#		5.5. Generated properties
#		**********************************************************************************************************

title5-5 = 5.5. Generated properties
p5-5-1 = Generated properties are properties that have their values generated by the database. Typically, Hibernate applications needed to refresh objects that contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select afterwards to retrieve the generated values.
p5-5-2 = Properties marked as generated must additionally be non-insertable and non-updateable. Only <a href="#c5-5">versions</a>, <a href="#c5-1-3-2">timestamps</a>, and <a href="#c5-1-4">simple properties</a>, can be marked as generated.
p5-5-3 = <code>never</code> (the default): the given property value is not generated within the database.
p5-5-4 = <code>insert</code>: the given property value is generated on insert, but is not regenerated on subsequent updates. Properties like created-date fall into this category. Even though version and timestamp properties can be marked as generated, this option is not available.
p5-5-5 = <code>always</code>: the property value is generated both on insert and on update.
p5-5-6 = To mark a property as generated, use <code>@Generated</code>.
 
#		**********************************************************************************************************
#		5.6. Column transformers: read and write expressions
#		**********************************************************************************************************

title5-6 = 5.6. Column transformers: read and write expressions
p5-6-1 = Hibernate allows you to customize the SQL it uses to read and write the values of columns mapped to <a href="#c5-1-4">simple properties</a>. For example, if your database provides a set of data encryption functions, you can invoke them for individual columns like this:
p5-6-2 = or in XML
nc5-6-1 = You can use the plural form <code>@ColumnTransformers</code> if more than one columns need to define either of these rules.
p5-6-3 = If a property uses more that one column, you must use the <code>forColumn</code> attribute to specify which column, the expressions are targeting.
p5-6-4 = Hibernate applies the custom expressions automatically whenever the property is referenced in a query. This functionality is similar to a derived-property <code>formula</code> with two differences:
li5-6-1-1 =  The property is backed by one or more columns that are exported as part of automatic schema generation.
li5-6-1-2 = The property is read-write, not read-only.
p5-6-5 = The <code>write</code> expression, if specified, must contain exactly one '?' placeholder for the value.
 
#		**********************************************************************************************************
#		5.7. Auxiliary database objects
#		**********************************************************************************************************

title5-7 = 5.7. Auxiliary database objects
p5-7-1 = Auxiliary database objects allow for the CREATE and DROP of arbitrary database objects. In conjunction with Hibernate's schema evolution tools, they have the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, any SQL command that can be run via a <code>java.sql.Statement.execute()</code> method is valid (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining auxiliary database objects:
p5-7-2 = The first mode is to explicitly list the CREATE and DROP commands in the mapping file:
p5-7-3 = The second mode is to supply a custom class that constructs the CREATE and DROP commands. This custom class must implement the <code>org.hibernate.mapping.AuxiliaryDatabaseObject</code> interface.
p5-7-4 = Additionally, these database objects can be optionally scoped so that they only apply when certain dialects are used.
nc5-7-1 = This feature is not supported in Annotations