#preface
preface = Preface
# 1
c1 = 1. Tutorial
c1-1 = 1.1. Part 1 - The first Hibernate Application
c1-1-1 = 1.1.1. Setup
c1-1-2 = 1.1.2. The first class
c1-1-3 = 1.1.3. The mapping file
c1-1-4 = 1.1.4. Hibernate configuration
c1-1-5 = 1.1.5. Building with Maven
c1-1-6 = 1.1.6. Startup and helpers
c1-1-7 = 1.1.7. Loading and storing objects
c1-2 = 1.2. Part 2 - Mapping associations
c1-2-1 = 1.2.1. Mapping the Person class
c1-2-2 = 1.2.2. A unidirectional Set-based association
c1-2-3 = 1.2.3. Working the association
c1-2-4 = 1.2.4. Collection of values
c1-2-5 = 1.2.5. Bi-directional associations
c1-2-6 = 1.2.6. Working bi-directional links
c1-3 = 1.3. Part 3 - The EventManager web application
c1-3-1 = 1.3.1. Writing the basic servlet
c1-3-2 = 1.3.2. Processing and rendering
c1-3-3 = 1.3.3. Deploying and testing
c1-4 = 1.4. Summary
#2
c2 = 2. Architecture
c2-1 = 2.1. Overview
c2-1-1 = 2.1.1. Minimal architecture
c2-1-2 = 2.1.2. Comprehensive architecture
c2-1-3 = 2.1.3. Basic APIs
c2-2 = 2.2. Contextual sessions
#3
c3 = 3. Configuration
c3-1 = 3.1. Programmatic configuration
c3-2 = 3.2. Obtaining a SessionFactory
c3-3 = 3.3. JDBC connections
c3-4 = 3.4. Optional configuration properties
c3-4-1 = 3.4.1. SQL Dialects
c3-4-2 = 3.4.2. Outer Join Fetching
c3-4-3 = 3.4.3. Binary Streams
c3-4-4 = 3.4.4. Second-level and query cache
c3-4-5 = 3.4.5. Query Language Substitution
c3-4-6 = 3.4.6. Hibernate statistics
c3-5 = 3.5. Logging
c3-6 = 3.6. Implementing a NamingStrategy
c3-7 = 3.7. Implementing a PersisterClassProvider
c3-8 = 3.8. XML configuration file
c3-9 = 3.9. Java EE Application Server integration
c3-9-1 = 3.9.1. Transaction strategy configuration
c3-9-2 = 3.9.2. JNDI-bound SessionFactory
c3-9-3 = 3.9.3. Current Session context management with JTA
#4
c4 = 4. Persistent Classes
c4-1 = 4.1. A simple POJO example
c4-1-1 = 4.1.1. Implement a no-argument constructor
c4-1-2 = 4.1.2. Provide an identifier property
c4-1-3 = 4.1.3. Prefer non-final classes (semi-optional)
c4-1-4 = 4.1.4. Declare accessors and mutators for persistent fields (optional)
c4-2 = 4.2. Implementing inheritance
c4-3 = 4.3. Implementing equals() and hashCode()
c4-4 = 4.4. Dynamic models
c4-5 = 4.5. Tuplizers
c4-6 = 4.6. EntityNameResolvers
#5
c5 = 5. Basic O/R Mapping
c5-1 = 5.1. Mapping declaration
c5-1-1 = 5.1.1. Entity
c5-1-2 = 5.1.2. Identifiers
c5-1-3 = 5.1.3. Optimistic locking properties (optional)
c5-1-4 = 5.1.4. Property
c5-1-5 = 5.1.5. Embedded objects (aka components)
c5-1-6 = 5.1.6. Inheritance strategy
c5-1-7 = 5.1.7. Mapping one to one and one to many associations
c5-1-8 = 5.1.8. Natural-id
c5-1-9 = 5.1.9. Any
c5-1-10 = 5.1.10. Properties
c5-1-11 = 5.1.11. Some hbm.xml specificities
c5-2 = 5.2. Hibernate types
c5-2-1 = 5.2.1. Entities and values
c5-2-2 = 5.2.2. Basic value types
c5-2-3 = 5.2.3. Custom value types
c5-3 = 5.3. Mapping a class more than once
c5-4 = 5.4. SQL quoted identifiers
c5-5 = 5.5. Generated properties
c5-6 = 5.6. Column transformers: read and write expressions
c5-7 = 5.7. Auxiliary database objects
#6
c6 = 6. Types
c6-1 = 6.1. Value types
c6-1-1 = 6.1.1. Basic value types
c6-1-2 = 6.1.2. Composite types
c6-1-3 = 6.1.3. Collection types
c6-2 = 6.2. Entity types
c6-3 = 6.3. Significance of type categories
c6-4 = 6.4. Custom types
c6-4-1 = 6.4.1. Custom types using org.hibernate.type.Type
c6-4-2 = 6.4.2. Custom types using org.hibernate.usertype.UserType
c6-4-3 = 6.4.3. Custom types using org.hibernate.usertype.CompositeUserType
c6-5 = 6.5. Type registry
#7
c7 = 7. Collection mapping
c7-1 = 7.1. Persistent collections
c7-2 = 7.2. How to map collections
c7-2-1 = 7.2.1. Collection foreign keys
c7-2-2 = 7.2.2. Indexed collections
c7-2-3 = 7.2.3. Collections of basic types and embeddable objects
c7-3 = 7.3. Advanced collection mappings
c7-3-1 = 7.3.1. Sorted collections
c7-3-2 = 7.3.2. Bidirectional associations
c7-3-3 = 7.3.3. Bidirectional associations with indexed collections
c7-3-4 = 7.3.4. Ternary associations
c7-3-5 = 7.3.5. Using an &lt;idbag&gt;
c7-4 = 7.4. Collection examples
#8
c8 = 8. Association Mappings
c8-1 = 8.1. Introduction
c8-2 = 8.2. Unidirectional associations
c8-2-1 = 8.2.1. Many-to-one
c8-2-2 = 8.2.2. One-to-one
c8-2-3 = 8.2.3. One-to-many
c8-3 = 8.3. Unidirectional associations with join tables
c8-3-1 = 8.3.1. One-to-many
c8-3-2 = 8.3.2. Many-to-one
c8-3-3 = 8.3.3. One-to-one
c8-3-4 = 8.3.4. Many-to-many
c8-4 = 8.4. Bidirectional associations
c8-4-1 = 8.4.1. one-to-many / many-to-one
c8-4-2 = 8.4.2. One-to-one
c8-5 = 8.5. Bidirectional associations with join tables
c8-5-1 = 8.5.1. one-to-many / many-to-one
c8-5-2 = 8.5.2. one to one
c8-5-3 = 8.5.3. Many-to-many
c8-6 = 8.6. More complex association mappings
#9
c9 = 9. Component Mapping
c9-1 = 9.1. Dependent objects
c9-2 = 9.2. Collections of dependent objects
c9-3 = 9.3. Components as Map indices
c9-4 = 9.4. Components as composite identifiers
c9-5 = 9.5. Dynamic components
#10
c10 = 10. Inheritance mapping
c10-1 = 10.1. The three strategies
c10-1-1 = 10.1.1. Table per class hierarchy
c10-1-2 = 10.1.2. Table per subclass
c10-1-3 = 10.1.3. Table per subclass: using a discriminator
c10-1-4 = 10.1.4. Mixing table per class hierarchy with table per subclass
c10-1-5 = 10.1.5. Table per concrete class
c10-1-6 = 10.1.6. Table per concrete class using implicit polymorphism
c10-1-7 = 10.1.7. Mixing implicit polymorphism with other inheritance mappings
c10-2 = 10.2. Limitations
#11
c11 = 11. Working with objects
c11-1 = 11.1. Hibernate object states
c11-2 = 11.2. Making objects persistent
c11-3 = 11.3. Loading an object
c11-4 = 11.4. Querying
c11-4-1 = 11.4.1. Executing queries
c11-4-2 = 11.4.2. Filtering collections
c11-4-3 = 11.4.3. Criteria queries
c11-4-4 = 11.4.4. Queries in native SQL
c11-5 = 11.5. Modifying persistent objects
c11-6 = 11.6. Modifying detached objects
c11-7 = 11.7. Automatic state detection
c11-8 = 11.8. Deleting persistent objects
c11-9 = 11.9. Replicating object between two different datastores
c11-10 = 11.10. Flushing the Session
c11-11 = 11.11. Transitive persistence
c11-12 = 11.12. Using metadata
#12
c12 = 12. Read-only entities
c12-1 = 12.1. Making persistent entities read-only
c12-1-1 = 12.1.1. Entities of immutable classes
c12-1-2 = 12.1.2. Loading persistent entities as read-only
c12-1-3 = 12.1.3. Loading read-only entities from an HQL query/criteria
c12-1-4 = 12.1.4. Making a persistent entity read-only
c12-2 = 12.2. Read-only affect on property type
c12-2-1 = 12.2.1. Simple properties
c12-2-2 = 12.2.2. Unidirectional associations
c12-2-3 = 12.2.3. Bidirectional associations
#13
c13 = 13. Transactions and Concurrency
c13-1 = 13.1. Session and transaction scopes
c13-1-1 = 13.1.1. Unit of work
c13-1-2 = 13.1.2. Long conversations
c13-1-3 = 13.1.3. Considering object identity
c13-1-4 = 13.1.4. Common issues
c13-2 = 13.2. Database transaction demarcation
c13-2-1 = 13.2.1. Non-managed environment
c13-2-2 = 13.2.2. Using JTA
c13-2-3 = 13.2.3. Exception handling
c13-2-4 = 13.2.4. Transaction timeout
c13-3 = 13.3. Optimistic concurrency control
c13-3-1 = 13.3.1. Application version checking
c13-3-2 = 13.3.2. Extended session and automatic versioning
c13-3-3 = 13.3.3. Detached objects and automatic versioning
c13-3-4 = 13.3.4. Customizing automatic versioning
c13-4 = 13.4. Pessimistic locking
c13-5 = 13.5. Connection release modes
#14
c14 = 14. Interceptors and events
c14-1 = 14.1. Interceptors
c14-2 = 14.2. Event system
c14-3 = 14.3. Hibernate declarative security
#15
c15 = 15. Batch processing
c15-1 = 15.1. Batch inserts
c15-2 = 15.2. Batch updates
c15-3 = 15.3. The StatelessSession interface
c15-4 = 15.4. DML-style operations
#16
c16 = 16. HQL: The Hibernate Query Language
c16-1 = 16.1. Case Sensitivity
c16-2 = 16.2. The from clause
c16-3 = 16.3. Associations and joins
c16-4 = 16.4. Forms of join syntax
c16-5 = 16.5. Referring to identifier property
c16-6 = 16.6. The select clause
c16-7 = 16.7. Aggregate functions
c16-8 = 16.8. Polymorphic queries
c16-9 = 16.9. The where clause
c16-10 = 16.10. Expressions
c16-11 = 16.11. The order by clause
c16-12 = 16.12. The group by clause
c16-13 = 16.13. Subqueries
c16-14 = 16.14. HQL examples
c16-15 = 16.15. Bulk update and delete
c16-16 = 16.16. Tips & Tricks
c16-17 = 16.17. Components
c16-18 = 16.18. Row value constructor syntax
#17
c17 = 17. Criteria Queries
c17-1 = 17.1. Creating a Criteria instance
c17-2 = 17.2. Narrowing the result set
c17-3 = 17.3. Ordering the results
c17-4 = 17.4. Associations
c17-5 = 17.5. Dynamic association fetching
c17-6 = 17.6. Components
c17-7 = 17.7. Collections
c17-8 = 17.8. Example queries
c17-9 = 17.9. Projections, aggregation and grouping
c17-10 = 17.10. Detached queries and subqueries
c17-11 = 17.11. Queries by natural identifier
#18
c18 = 18. Native SQL
c18-1 = 18.1. Using a SQLQuery
c18-1-1 = 18.1.1. Scalar queries
c18-1-2 = 18.1.2. Entity queries
c18-1-3 = 18.1.3. Handling associations and collections
c18-1-4 = 18.1.4. Returning multiple entities
c18-1-5 = 18.1.5. Returning non-managed entities
c18-1-6 = 18.1.6. Handling inheritance
c18-1-7 = 18.1.7. Parameters
c18-2 = 18.2. Named SQL queries
c18-2-1 = 18.2.1. Using return-property to explicitly specify column/alias names
c18-2-2 = 18.2.2. Using stored procedures for querying
c18-3 = 18.3. Custom SQL for create, update and delete
c18-4 = 18.4. Custom SQL for loading
#19
c19 = 19. Filtering data
c19-1 = 19.1. Hibernate filters
#20
c20 = 20. Improving performance
c20-1 = 20.1. Fetching strategies
c20-1-1 = 20.1.1. Working with lazy associations
c20-1-2 = 20.1.2. Tuning fetch strategies
c20-1-3 = 20.1.3. Single-ended association proxies
c20-1-4 = 20.1.4. Initializing collections and proxies
c20-1-5 = 20.1.5. Using batch fetching
c20-1-6 = 20.1.6. Using subselect fetching
c20-1-7 = 20.1.7. Fetch profiles
c20-1-8 = 20.1.8. Using lazy property fetching
c20-2 = 20.2. The Second Level Cache
c20-2-1 = 20.2.1. Cache mappings
c20-2-2 = 20.2.2. Strategy: read only
c20-2-3 = 20.2.3. Strategy: read/write
c20-2-4 = 20.2.4. Strategy: nonstrict read/write
c20-2-5 = 20.2.5. Strategy: transactional
c20-2-6 = 20.2.6. Cache-provider/concurrency-strategy compatibility
c20-3 = 20.3. Managing the caches
c20-4 = 20.4. The Query Cache
c20-4-1 = 20.4.1. Enabling query caching
c20-4-2 = 20.4.2. Query cache regions
c20-5 = 20.5. Bytecode Enhancement
c20-5-1 = 20.5.1. Implementing org.hibernate.engine.spi.ManagedEntity interface
c20-5-2 = 20.5.2. Runtime instrument
c20-5-3 = 20.5.3. Build-time instrument
c20-6 = 20.6. Understanding Collection performance
c20-6-1 = 20.6.1. Taxonomy
c20-6-2 = 20.6.2. Lists, maps, idbags and sets are the most efficient collections to update
c20-6-3 = 20.6.3. Bags and lists are the most efficient inverse collections
c20-6-4 = 20.6.4. One shot delete
c20-7 = 20.7. Monitoring performance
c20-7-1 = 20.7.1. Monitoring a SessionFactory
c20-7-2 = 20.7.2. Metrics
#21
c21 = 21. Toolset Guide
c21-1 = 21.1. Automatic schema generation
c21-1-1 = 21.1.1. Customizing the schema
c21-1-2 = 21.1.2. Running the tool
c21-1-3 = 21.1.3. Properties
c21-1-4 = 21.1.4. Using Ant
c21-1-5 = 21.1.5. Incremental schema updates
c21-1-6 = 21.1.6. Using Ant for incremental schema updates
c21-1-7 = 21.1.7. Schema validation
c21-1-8 = 21.1.8. Using Ant for schema validation
#22
c22 = 22. Additional modules
c22-1 = 22.1. Bean Validation
c22-1-1 = 22.1.1. Adding Bean Validation
c22-1-2 = 22.1.2. Configuration
c22-1-3 = 22.1.3. Catching violations
c22-1-4 = 22.1.4. Database schema
c22-2 = 22.2. Hibernate Search
c22-2-1 = 22.2.1. Description
c22-2-2 = 22.2.2. Integration with Hibernate Annotations
#23
c23 = 23. Example: Parent/Child
c23-1 = 23.1. A note about collections
c23-2 = 23.2. Bidirectional one-to-many
c23-3 = 23.3. Cascading life cycle
c23-4 = 23.4. Cascades and unsaved-value
c23-5 = 23.5. Conclusion
#24
c24 = 24. Example: Weblog Application
c24-1 = 24.1. Persistent Classes
c24-2 = 24.2. Hibernate Mappings
c24-3 = 24.3. Hibernate Code
#25
c25 = 25. Example: Various Mappings
c25-1 = 25.1. Employer/Employee
c25-2 = 25.2. Author/Work
c25-3 = 25.3. Customer/Order/Product
c25-4 = 25.4. Miscellaneous example mappings
c25-4-1 = 25.4.1. "Typed" one-to-one association
c25-4-2 = 25.4.2. Composite key example
c25-4-3 = 25.4.3. Many-to-many with shared composite key attribute
c25-4-4 = 25.4.4. Content based discrimination
c25-4-5 = 25.4.5. Associations on alternate keys
#26
c26 = 26. Best Practices
#27
c27 = 27. Database Portability Considerations
c27-1 = 27.1. Portability Basics
c27-2 = 27.2. Dialect
c27-3 = 27.3. Dialect resolution
c27-4 = 27.4. Identifier generation
c27-5 = 27.5. Database functions
c27-6 = 27.6. Type mappings