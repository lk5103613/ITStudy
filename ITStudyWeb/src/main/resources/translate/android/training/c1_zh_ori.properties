
#		**********************************************************************************************************
#		Getting Started
#		**********************************************************************************************************

title1 = 入门指南
p1-1 = 欢迎来到Android开发者培训教程。在这里你可以找到一系列的课程，这些课程讲解了如何使用可以重用于你的应用示例代码来完成特定的任务。这些课程分为几组， 左侧菜单栏的顶层菜单就是。
p1-2 = 这是第一组, 入门指南, 教你最基本的Android应用开发。如果你是一个Android应用开发新手，你应该按顺序依次完成这些课程：

#		**********************************************************************************************************
#		Building Your First App
#		**********************************************************************************************************

title1-1 = 创建你的首个Android应用
p1-1-1 = 欢迎来到Android应用程序开发！
p1-1-2 = 本课程教你如何创建你的第一个android 应用。你将会学到怎样创建一个Android项目，并且运行你的应用程序的调试版本。你还会学到一些Android应用设计的一些基本原理，包括怎样创建一个简单的用户界面并处理用户输入。 
sub_title1-1-1 = 搭建开发环境
p1-1-3 = 在开始本课程之前，请确认你已经搭建好了开发环境。你需要：
p1-1-4 = 1. 下载 <a href="http://developer.android.com/sdk/index.html">Android Studio</a>.
p1-1-5 = 2. 使用<a href="http://developer.android.com/tools/help/sdk-manager.html">SDK Manager</a>下载最新的SDK tools 和 platforms。
nc1-1-1 = 注意: 尽管大部分的培训课程期望你使用Android Studio, 一些程序包含二选一的说明， 作为替代方法，可以在命令行使用SDK tools。
p1-1-6 = 这个课程以创建一个小的Android 应用的教程的方式来教你一些关于Android开发的基本知识，因此你应该按部就班的学习本课程。

#		**********************************************************************************************************
#		Creating an Android Project
#		**********************************************************************************************************

title1-1-1 = 创建一个Android项目
p1-1-1-1 = 一个Android项目包含了你的Android应用的所有源代码文件。
p1-1-1-2 = 本节将分别展示使用Android Studio和SDK Tools创建新的项目。
nc1-1-1-1 = 注意: 你应该已经装好了Android SDK，如果你使用Android Studio, 那么你就应该已经装上了Android Studio。如果这些你都没有，在学习本节之前，请参考向导来安装Android SDK。
sub_title1-1-1-1 = 使用Android Studio创建项目
p1-1-1-3 = 使用 Android Studio, 创建一个新项目:
li1-1-1-1-1 = 如果你没有打开一个项目, 在 <strong>欢迎</strong> 界面， 点击 <strong>New Project</strong>。
li1-1-1-1-2 = 如果你已经打开了一个界面, 从 File 菜单, 选择 <strong>New Project</strong>。
p1-1-1-4 = 下面配置你的新项目，填写在图片1中字段然后点击<strong>Next</strong>.
p1-1-1-5 = 如果你使用和图片中相同的值，那么跟着这个课程步骤非常的简单。
li1-1-1-2-1 = <strong>Application Name</strong> 给用户展示的应用名。这个项目我们使用 "My First App"。
li1-1-1-2-2 = <strong>Company domain</strong> 提供了包名限定； Android Studio将会记住每个新项目的这个限定。
li1-1-1-2-3 = <strong>Package name</strong> 是项目的全限定名（命名规则和Java规范相同）。包名在Android系统中必须是唯一的。你可以独立的使用应用名或者公司域名来<strong>修改</strong>这个值。
li1-1-1-2-4 = <strong>Project location</strong> 项目文在在你的系统中存放的位置。
p1-1-1-6 = 在 <strong>Select the form factors your app will run on</strong>下面, 选择平台是手机还是平板。
p1-1-1-7 = 选项 <strong>Minimum SDK</strong>, 选择 <strong>API 8: Android 2.2 (Froyo)</strong>。
p1-1-1-8 = Minimum Required SDK 是你的应用程序支持的Android最低版本对应的API级别。为了支持更多的设备，你应该设置为能够提供你的应用程序核心功能所需要的特性的最低版本。如果你的应用的一些特性只在某些android新版本上支持，但是对这个应用的核心功能来讲不重要，那么你可以只在支持这个特性的版本上面开启这个特性（将在支持平台版本中讨论）。
p1-1-1-9 = 剩下所有的其他选项 (TV, Wear, and Glass) 不勾选，然后点击 <strong>Next</strong>。
p1-1-1-10 = 在 <strong>Add an activity to your project</strong>下面, 选择 <strong>Blank Activity</strong> 然后点击<strong>Next</strong>。
p1-1-1-11 = 在 <strong>Describe the new activity for your project</strong>下面, 不要修改默认的内容，然后点击<strong>Finish</strong>。
p1-1-1-12 = 现在你的Android项目是基本的“Hello World”应用，项目中包含了一些默认的文件。花点时间来看一下比较重要的文件内容： 
dt1-1-1-1 = <code>app/src/main/res/layout/activity_my.xml</code>
dd1-1-1-1 = 这个是在你使用Android Studio创建项目时添加的Activity的XML布局文件。按照创建新项目的步骤，Android Studio提供了布局文件的两种视图， 一种是文本形式，另一种是UI界面。这个文件包含了一些默认的设置和一个TextVeiw元素，展示消息“Hello World”。
dt1-1-1-2 = <code>app/src/main/java/com.mycompany.myfirstapp/MyActivity.java</code>
dd1-1-1-2 = 当创建新项目的流程结束时，将会打开该文件的一个新标签。 当你选择这个文件时，可以看到被创建的Activity 类的定义。当你编译并且运行这个应用时，这个Activity类会启动这个activity并且加载布局文件显示“Hello World!”。
dt1-1-1-3 = <code>app/src/res/AndroidManifest.xml</code>
dd1-1-1-3 = 这个manifest文件描述了这个应用的基本特性，并且定义了他的每个组件。在跟着这篇教程学习是你还会遇到这个文件，并且为你的应用添加更多的组件。
dt1-1-1-4 = <code>app/build.gradle</code>
dd1-1-1-4 = Android Studio 使用Gradle来编译和构建你的应用。你的项目的每个模块都会有一个<code>build.gradle</code>文件。通常情况下你只需关心某个模块的<code>build.gradle</code>文件，在本例中是app或者应用模块。在这里设置应用构建依赖，包括<code>defaultConfig</code>的设置：
li1-1-1-3-1 = <code>compiledSdkVersion</code> 是你的应用编译时使用的版本。默认是android sdk可以使用的最新版本。(应该是Android 4.1 或以上；如果没有以上可使用的版本，你必须使用SDK Manager安装一个。)你仍然可以构建你的应用去支持老版本，但是设置为最新的版本，你就可以使用一些新的特性，并且在新设备上面可以提高用户体验。
li1-1-1-3-2 = <code>applicationId</code> 是创建应用过程中使用的应用的全限定包名。
li1-1-1-3-3 = <code>minSdkVersion</code> 是在创建新项目过程中指定的SDK最小版本。这是你的应用支持的最早的版本。
li1-1-1-3-4 = <code>targetSdkVersion</code> 指定你测试应用程序使用的Android最高版本。当有Android新版本可用时，你应该在新版本中测试你的应用，并且将该值修改为最新的API等级，然后就可以使用心得平台特性。参考“不同平台版本的支持” 获取更多信息。
p1-1-1-13 = 参考“使用Gradle构建你的项目”获取更多关于Gradle的信息。
p1-1-1-14 = 注意<code>/res</code> 子目录同样包含应用的资源：
dt1-1-1-5 = <code>drawable-hdpi/</code>
dd1-1-1-5 =  drawable 对象的目录文件 (例如bitmaps)，被设计用于高分辨率(hdpi)的屏幕。 其他的drawable目录用于其他不同分辨率的屏幕。当你运行默认的应用时，你可以看到 ic_launcher.png 显示出来。
dt1-1-1-6 = <code>layout/</code>
dd1-1-1-6 = 存放你的应用的用户界面的文件件，像上面讨论的activity_my.xml，它描述了MyActivity类的基本布局。
dt1-1-1-7 = <code>values/</code>
dd1-1-1-7 = 存放其他的XML的文件夹，这些XML包含了一些资源集合，例如字符串和颜色的定义。 strings.xml 文件定义了在你运行默认的app是展示的"Hello world!" 字符串。
p1-1-1-15 = 运行这个app, 继续学习<a href="#c1-1-2">下一节</a>.
sub_title1-1-1-2 = 使用命令行工具创建项目
p1-1-1-16 = 如果你没有使用Android Studio 工具，你可以从命令行掉用SDK tools来创建android项目：
p1-1-1-17 = 将目录切换到Android SDK\u2019s <code>tools/</code> 所在路径.
p1-1-1-18 = 执行:
p1-1-1-19 = 这将会列出你已经下载的所有可用的Android SDK平台组件。找到那个你想用于编译项目的平台。记录下target id。我们推荐使用尽可能高的版本。你仍然可以构建你的应用来支持老版本，但是设置为最新版本可以使你的应用在新设备上有更好的体验。
p1-1-1-20 = 如果你没有看到任何的目标列表, 你需要使用Android SDK Manager去安装一些。参考 <a href="http://developer.android.com/sdk/installing/adding-packages.html">Adding SDK Packages</a>.
p1-1-1-21 = 执行:
p1-1-1-22 = 修改 <code>&lt;target-id&gt;</code> 为target列表中的某个target id(上一步)然后修改<code>&lt;path-to-workspace&gt;</code> 为保存你的Android 项目的地址
tc1-1-1-1 = 提示: 将 platform-tools/ 和 tools/ 目录添加到环境变量PATH中。
p1-1-1-23 = 现在你的android项目是一个基础的“Hello World”应用，它包含了一些默认的文件。要想运行这个App，请继续学习<a href="#c1-1-2">下一节</a>。

#		**********************************************************************************************************
#		Running Your App
#		**********************************************************************************************************

title1-1-2 = 运行你的应用
p1-1-2-1 = 如果你按照<a href="#c1-1-1">上一节</a> 的内容创建了一个Android应用，它包含了一些能让你的应用直接运行起来的默认的“Hello World”资源文件。
p1-1-2-2 = 怎样运行你的应用取决于两件事：你是否拥有一台真实的android设备以及你是否使用了Android Studio。本节内容教你怎样使用Android Studio或者使用命令行在一个真实设备或者模拟器上安装和运行应用。
sub_title1-1-2-1 = 在真实设备上运行
p1-1-2-3 = 如果你有一个运行的Android设备，下面演示怎样安装和运行App。
p1-1-2-4 = 配置你的设备
li1-1-2-1-1 = 使用USB连接线将你的设备连接到开发环境。如果你在Windows环境下开发，你也许需要为你的设备安装适当的USB驱动。关于安装驱动的帮助，参考OEM USB驱动文档。
li1-1-2-1-2 = 在你的设备上开启 <strong>USB debugging</strong> 。
li1-1-2-2-1 = 在许多Android 3.2或者更老的设备上，你可以在<strong>Settings > Applications > Development</strong>下找到该设置。
li1-1-2-2-2 = 在Android4.0及以上，是在 <strong>Settings > Developer options</strong>下。
nc1-1-2-1 = 注意: 在Android4.2及以上，<strong>Developer options</strong>默认情况下是隐藏的。要想让它可见，到 <strong>Settings > About phone</strong> 然后点击 <strong>Build number</strong> 七次。然后返回前面的界面找到<strong>Developer options</strong>。
p1-1-2-5 = 从Android Studio安装应用
li1-1-2-3-1 = 选择你的项目中的某个文件然后点击工具栏上的 <code>Run</code> 。
li1-1-2-3-2 = 在出现的<strong>Choose Device</strong> 窗口, 选择<strong>Choose a running device</strong>按钮, 选择你的设备然后点击 <strong>OK</strong> 。
p1-1-2-6 = Android Studio 会在链接的设备上安装这个app并且打开它。
p1-1-2-7 = 使用命令行运行app
li1-1-2-4-1 = 将目录切换到Android项目的根目录然后执行：
li1-1-2-4-2 = 确保Android SDK<code>platform-tools/</code> 目录应配置到PATH环境变量中，然后执行：
li1-1-2-4-3 = 在你的设备上找到 MyFirstApp 然后打开它。
p1-1-2-8 = 以上就是怎样构建你的App并且在设备上运行！开始开发，请继续学习 <a href="#c1-1-3">下一节</a>。
sub_title1-1-2-2 = 在模拟器上运行
p1-1-2-9 = 无论你是使用Android Studio还是命令行，要想在模拟器上运行app首先你需要创建一个Android虚拟设备（AVD）。AVD是一个android模拟器的配置，这样你就可以模拟一个真实的设备。
p1-1-2-10 = 创建一个 AVD
li1-1-2-5-1 = 加载Android Virtual Device Manager:
li1-1-2-6-1 = 在Android Studio, 选择 <strong>Tools > Android > AVD Manager</strong>, 或者点击在工具栏中的AVD Manager 图标。
li1-1-2-6-2 = 或者, 从命令行，切换目录到<code>&lt;sdk&gt;/tools/</code> 然后执行:
nc1-1-2-2 = 注意: 从命令行启动的AVD Manager的版本和Android Studio中的不一样，所以下面的指令不在适用。
li1-1-2-5-2 = 在 AVD Manager主界面(图片 1), 点击 <strong>Create Virtual Device</strong>。
li1-1-2-5-3 = 在Select Hardware 窗口, 选择一个设备配置，例如Nexus 6, 然后点击<strong>Next</strong>。
li1-1-2-5-4 = 选择期望的AVD系统版本然后点击<strong>Next</strong>。
li1-1-2-5-5 = 核实配置设置，然后点击<strong>Finish</strong>。
p1-1-2-11 = 关于 AVD的更多信息, 参考使用AVD Manager管理AVD。
p1-1-2-12 = 从Android Studio运行程序
li1-1-2-7-1 = 在Android Studio, 选择你的项目然后点击工具栏上的<strong>Run</strong>。
li1-1-2-7-2 = 在 <strong>Choose Device</strong> 窗口,点击<strong>Launch emulator</strong> 按钮。
li1-1-2-7-3 = 从 <strong>Android virtual device</strong> 下拉菜单中， 选择你已经创建好的模拟器，然后点击<strong>OK</strong>。
p1-1-2-13 = 模拟器启动需要花费一些时间。你应该解锁屏幕。完成之后My First App会出现在模拟器屏幕上。
p1-1-2-14 = 使用命令行运行app
li1-1-2-8-1 = 将目录切换到Android项目的根目录然后执行：
li1-1-2-8-2 = 确认Android SDK <code>platform-tools/</code> 目录已经配置到PATH环境变量中，然后执行:
li1-1-2-8-3 = 在模拟器上，找到 MyFirstApp 然后打开它。
p1-1-2-15 = 以上就是怎样在模拟器上构建和运行你的Android应用！想开始开发，请继续学习  <a href="#c1-1-3">下一节</a>。

#		**********************************************************************************************************
#		Building a Simple User Interface
#		**********************************************************************************************************

title1-1-3 = 构建一个简单的用户界面
p1-1-3-1 = 在本节中，你将创建一个XML布局，里面包括一个Text 文本和一个按钮。在下一节中，你的应用程序将会在点击按钮的时候响应用户点击，并且发送text文本到另一个Activity中。
p1-1-3-2 = android应用的图形用户界面通过使用View和ViewGroup的层叠来实现。View对象是普通的UI小部件例如按钮，文本框。ViewGroup对象是不可见的视图容器，用于定义如何布局子视图，例如网格和纵向的列表。
p1-1-3-3 = Android提供View和ViewGroup的子类XML标签，因此你可以使用层叠的UI标签来创建你的UI界面。
p1-1-3-4 = 布局都是ViewGroup的子类。在本次的联系中你将会使用到LinearLayout。
sub_title1-1-3-1 = 创建一个线性布局
li1-1-3-1-1-1-1 = 在Android Studio中, 在 <code>res/layout</code> 目录打开 <code>activity_my.xml</code> 文件。 
li1-1-3-1-1-1-2 = 当你创建这个项目时你选择BlankActivity模板提供了以RelativeLayout为根视图，并包含TextView子视图的<code>activity_my.xml</code> 文件。
li1-1-3-1-1-2-1 = 在 <strong>Preview</strong> 版面, 点击Hide图标关闭Preview版面。
li1-1-3-1-1-2-2 = 在 Android Studio中, 当你打开一个布局文件，首先展示的是Preview面板。点击面板中的元素在设计面板打开 WYSIWYG 工具。在本节，你将会直接操作XML。
li1-1-3-1-1-3 = 删除&lt;TextView&gt; 元素。
li1-1-3-1-1-4 = 修改&lt;RelativeLayout&gt; 元素为&lt;LinearLayout&gt;。
li1-1-3-1-1-5 = 添加android:orientation 属性并且设置为<code>"horizontal"</code>。
li1-1-3-1-1-6 = 删除<code>android:padding</code>属性和<code>tools:context</code> 属性。
p1-1-3-1-1 = 结果像这样：
p1-1-3-1-2 = LinearLayout 是一个控件组(ViewGroup的子类)，它让子视图水平或者垂直布局，这通过 <code>android:orientation</code> 属性来指定。LinearLayout的每个子视图按照他在XML中的顺序在屏幕上显示。
p1-1-3-1-3 = 另外两个属性，<code>android:layout_width</code> 和 <code>android:layout_height</code>,对于每个View都是必须的属性，他们指定了View的尺寸。
p1-1-3-1-4 = 因为LinearLayout是布局的根视图，他应该覆盖全部的应用可用的屏幕区域，通过设置为 <code>"match_parent"</code>来实现。这个值表示该控件应该扩张他的宽度和高度来匹配它的父控件的宽度和高度。
p1-1-3-1-5 = Layout属性的更多信息参考 Layout指南。
sub_title1-1-3-2 = 添加一个文本框
p1-1-3-2-1 = 和其他任何的View对象一样,你必须明确的定义XML属性来指定EditText对象的属性。
li1-1-3-2-1-1 = 在 <code>activity_my.xml</code> 文件中, 在 &lt;LinearLayout&gt; 元素内部, 定义一个&lt;EditText&gt; 元素， 并且给它添加值为<code>@+id/edit_message</code>的<code>id</code>属性。
li1-1-3-2-1-2 = 指定 <code>layout_width</code> 和 <code>layout_height</code> 属性为<code>wrap_content</code>。
li1-1-3-2-1-3 = 指定<code>hint</code> 属性，内容为<code>edit_message</code>。
p1-1-3-2-2 = &lt;EditText&gt; 看起来是这个样子的:
p1-1-3-2-3 = 这是你添加的&lt;EditText&gt; 的属性:
dt1-1-3-2-1 = <code>android:id</code>
dd1-1-3-2-1-1 = 这个属性指定了View的唯一标识，这样你就可以在你的App内核代码中通过id来引用这个View，例如读取和操作这个对象(在下一节中将会有详细的介绍) 。
dd1-1-3-2-1-2 = 当你在XML中引用其他资源对象的时候需要使用at 标志 (<code>@</code>)。后面跟着资源类型 (在这里是<code>id</code>), 一个斜杠, 然后是资源的名字(<code>edit_message</code>)。
dd1-1-3-2-1-3 = 只有在你第一次定义一个资源Id的时候需要在资源类型前面使用+号(<code>+</code>)。当你编译这个App时，SDK tools会使用这个Id名在你的项目的gen/R.java文件中创建一个新的资源ID，这个资源ID指向EditText元素。通过这种方式声明一次资源ID，其他的对这个Id的引用都不需要使用+号。只有在指定一个新的资源Id的时候需要使用+号，但是对于具体的资源像String或者layout不需要使用。参考侧边导航获取关于资源对象的更多信息。
dt1-1-3-2-2 = <code>android:layout_width</code> 和 <code>android:layout_height</code>
dd1-1-3-2-2 = 代替使用具体的width和height，<code>"wrap_content"</code> 这个值指定了视图的大小应该适应视图的内容所需要的大小。如果你使用 <code>"match_parent"</code>, 那么 <code>EditText</code> 元素将会充满屏幕，因为它将会匹配父LinearLayout的大小。更多信息请参考Layouts指南。
dt1-1-3-2-3 = <code>androi:hint</code>
dd1-1-3-2-3 = 当文本字段为空时，默认显示的字符串。代替在使用硬编码指定一个字符串值，<code>"@string/edit_message"</code> 的值指向一个在特殊文件中指定的string资源。因为这是指向一个确定的资源(不仅仅是一个标示符), 所以不需要+ 号。然而，因为你还没有定义这个String资源，一开始将会看到编译错误。在下一节中通过定义String资源可以解决这个错误。
nc1-1-3-2-1 = 注意: 这个string资源和元素Id有相同的名字： <code>edit_message</code>。然而，资源的引用通常通过资源类型划分(例如id或者string)，因此使用相同的名字不会引起冲突。
sub_title1-1-3-3 = 添加String资源
p1-1-3-3-1 = 默认情况下，你的Android项目会包含一个string资源文件<code>res/values/strings.xml</code>。这里，你将会添加一个新的string名为<code>"edit_message"</code>，然后把value设置为"Enter a message"。
li1-1-3-3-1-1 = 在 Android Studio中, 从<code>res/values</code> 目录, 打开 <string>strings.xml</code>。
li1-1-3-3-1-2 = 添加一行名为<code>"edit_message"</code> 值为 "Enter a message"的字符串。
li1-1-3-3-1-3-1 = 添加一行名为<code>"button_send"</code> 值为"Send"的字符串。
li1-1-3-3-1-3-2 = 在下一节中你将会创建使用这些字符串的按钮。
li1-1-3-3-1-4 = 移除<code>"hello world"</code> 这行字符串。
p1-1-3-3-2 = 最终的<code>strings.xml</code> 如下:
p1-1-3-3-3 = 在用户界面的的文本，通常每个字符串定义为资源。String 资源可以使你在同一个位置管理所以的UI文本，这样就可以更加简单的查找和修改文本。将这些字符串提出来，也可以让你的应用本地化到不同的语言，只要指定对应的string资源即可。
p1-1-3-3-4 = 更多关于使用资源文件本地化应用到不同的语言的信息，参考支持不同设备的有关课程。
sub_title1-1-3-4 = 添加一个按钮
li1-1-3-4-1-1 = 在 Android Studio中, 从 <code>res/layout</code> 目录, 编辑 <code>activity_my.xml</code> 文件。
li1-1-3-4-1-2 = 在<code>&lt;LinearLayout&gt;</code> 元素内部, 定义一个<code>&lt;Button&gt;</code> 元素 直接跟在 <code>&lt;EditText&gt;</code> 元素的后面。
li1-1-3-4-1-3 = 把按钮的width和height设置为<code>"wrap_content"</code>，这样按钮就有可以自适应按钮上文本内容的大小。
li1-1-3-4-1-4 = 使用<code>android:text</code>属性定义按钮上的文本标签；设置它的值为你在前面章节中定义的<code>button_send</code> 字符串资源。
p1-1-3-4-1 = 你的&lt;LinearLayout&gt;应该如下：
nc1-1-3-4-1 = 注意: 这个按钮不需要android:id 属性,因为在activity代码中不需要引用它。
p1-1-3-4-2 = 目前为止，布局文件中定义了 <code>EditText</code> 和 <code>Button</code>。小控件的大小自适应他们内容所需要的大小，如图2所示。
p1-1-3-4-3 = 按钮看起来没问题，但是文本框好像文本框有点问题，因为也许用户想输入更多的内容。让文本框自动适应未使用的屏幕宽度看起来不错。你可以在<code>LinearLayout</code>上使用weight属性实现，只需使用 <code>android:layout_weight</code>属性即可。
p1-1-3-4-4 = 这个weight值是一个数值，他指定了每个视图应该占用的剩余空间的大小，与兄弟视图的数量有关。这点有点像饮料配方材料的数量："两份碳酸水，一份果汁" 这意味着饮料里面三分之二是碳酸水。例如，如果你把一个View的weight属性设置为2，另外一个设置为1，那么总和是3，因此第一个View占屏幕剩余空间的2/3，第二个view填充剩下的空间。如果你添加了第三个view然后给它的weight属性设置为1，那么第一个view（weight为2的）就占有剩余空间的1/2，那么剩下的两个分别占有1/4的空间。
p1-1-3-4-5 = 所有view默认的weight值是0，因此如果你只指定一个view的weight的值大于0，那么这个视图将会占有除其他view所需空间之外剩下的所有空间。
sub_title1-1-3-5 = 让输入框填充屏幕大小
p1-1-3-5-1 = 要让你的<code>EditText</code>元素沾满剩余空间，你需要这样做：
li1-1-3-5-1-1 = 打开 <code>activity_my.xml</code> 文件, 设置 <code>&lt;EditText&gt;</code> 元素的 <code>layout_weight</code> 属性值为1。
li1-1-3-5-1-2-1 = 并且, 设置 <code>&lt;EditText&gt;</code> 元素的 <code>layout_width</code>属性值为<code>0dp</code>。
li1-1-3-5-1-2-2 = 为了提高layout的效率，当你指定了weight的时候，你需要修改EditText的width为0(0dp)。把width设置为0 可以提高layout的性能，是因为使用"wrap_content"作为宽度需要系统做额外的不需要的计算，因为weight的值也需要另外的宽度计算来填充剩余的空间。
li1-1-3-5-1-2-3 = 图3展示了你给<code>EditText</code>元素添加了weight之后的结果。
p1-1-3-5-2 = 现在你完成的<code>activity_my.xml</code> 布局文件呢内容应该如下：
sub_title1-1-3-6 = 运行你的App
p1-1-3-6-1 = 这个布局由默认的Activity类引用，这个类是在你创建这个项目的时候由SDK tools创建的。 运行你的app来看最终结果：
li1-1-3-6-1-1 = 在Android Studio中, 点击工具栏上的<strong>Run</strong>。
li1-1-3-6-1-2 = 或者在命令行，切换目录到项目的根目录然后执行：
p1-1-3-6-2 = 继续 <a href="#c1-1-4">下一节</a>来学习怎样响应按钮点击，从text读取内容，开启其他的activity，等更多的内容。

#		**********************************************************************************************************
#		Starting Another Activity
#		**********************************************************************************************************

title1-1-4 = 打开其他的 Activity
p1-1-4-1 = 在完成了 <a href="#c1-1-3">上一节</a>的学习之后, 你已经有了一个app， 这个app展示了一个带有一个文本框和一个按钮的activity(单个屏幕)。在本节中，在点击第二个按钮的时候将会打开一个新的activity。
sub_title1-1-4-1 = 响应第二个按钮
li1-1-4-1-1-1 = 在Android Studio中, 从 <code>res/layout</code> 目录,编辑<code>activity_my.xml</code> 文件。
li1-1-4-1-1-2-1 = 找到 <code>&lt;Button&gt;</code> 元素,添加 <code>android:onClick</code> 属性。
li1-1-4-1-1-2-2 = <code>android:onClick</code> 的值是 <code>"sendMessage"</code>, 是在你activity中的方法的名字，在你点击了按钮之后系统将会调用这个方法。
li1-1-4-1-1-3 = 在 <code>java/com.mycompany.myfirstapp</code> 目录, 打开MyActivity.java 文件。
li1-1-4-1-1-4-1 = 在 MyActivity 类中, 添加如下的<code>sendMessage()</code> 方法块。
li1-1-4-1-1-4-2 = 为了让系统把这个方法和在<code>android:onClick</code>中指定的方法名对应，方法名必须如下所示，另外，这个方法应该：
li1-1-4-1-2-1 = 是 public的
li1-1-4-1-2-2 = 返回值为void
li1-1-4-1-2-3 = 只有一个为View的参数 (指向被点击的View)
p1-1-4-2 = 下面, 你需要填充这个方法，读取文本的内容，并且把文本内容传递到其他的activity。
sub_title1-1-4-2 = 创建一个Intent
li1-1-4-2-1-1-1 = 在 <code>MyActivity.java</code>中, <code>sendMessage()</code> 方法内部, 创建一个Intent使用下面的代码来开启一个名为<code>DisplayMessageActivity</code> 的activity：
nc1-1-4-2-1 = 注意: 对于<code>DisplayMessageActivity</code> 的引用将会抛出一个错误如果你使用像Android Studio这样的IDE的时候，因为这个类还不存在。现在忽略这个错误；你马上就可以创建这个类了。
li1-1-4-2-1-1-2 = 这里使用的构造函数有两个参数：
li1-1-4-2-2-1 = Context 作为第一个参数(使用this是因为Activity类是Context的子类) 
li1-1-4-2-2-2 = 系统将把Intent传递给app组件的类(这个例子中是将要被打开的activity)
li1-1-4-2-1-1-3 = Android Studio 指示你必须导入Intent类。
li1-1-4-2-1-2 = 在文件头, 引入 Intent 类:
tc1-1-4-2-1 = 提示: 在 Android Studio中, 使用 Alt + Enter (在Mac中是option + return ) 来引入缺失的类。
li1-1-4-2-1-3 = 在 <code>sendMessage()</code> 方法内, 使用 <code>findViewById()</code> 来获取 EditText 元素。
li1-1-4-2-1-4-1 = 在文件头, 引入<code>EditText</code> 类。
li1-1-4-2-1-4-2 =  在 Android Studio中, 使用 Alt + Enter (在Mac中是option + return ) 来引入缺失的类。
li1-1-4-2-1-5-1 = 把文本付给本地变量 <code>message</code> , 然后使用the <code>putExtra()</code> 方法添加text值到intent中。
li1-1-4-2-1-5-2 = Intent可以持有键值对类型的数据被称为Extras。<code>putExtra()</code> 方法第一个参数是key，第二个参数是值。
li1-1-4-2-1-6-1 = 在 <code>MyActivity</code> 类的顶部,添加 <code>EXTRA_MESSAGE</code> 的定义如下:
li1-1-4-2-1-6-2 = 为了在下一个activity中获取extra值，你应该使用public的常量来定义extra的可以。把你包名作为extras的key的前缀是很好的做法。这样在你的应用和其他app交互的时候就可以保证你的key的唯一性，
li1-1-4-2-1-7 = 在<code>sendMessage()</code> 方法中,调用 <code>startActivity()</code> 方法结束这个intent, 把在步骤1中创建的intent传递给它。
p1-1-4-2-1 = 加上新的代码，完成的被第二个按钮调用的 <code>sendMessage()</code> 方法如下：
p1-1-4-2-2 = 系统接收了这个调用并且打开了一个被这个Intent指定的Activity的实例。现在你需要创建<code>DisplayMessageActivity</code> 类来让app运行。
sub_title1-1-4-3 = 创建第二个 Activity
p1-1-4-3-1 = 所有的Activity的子类必须实现<code>onCreate()</code> 方法。 在这个方法中activity接收带有message的intent，然后提取message。并且在 <code>onCreate()</code> 方法中必须使用<code>setContentView()</code>方法来定义activity布局。这是activity初始化activity组件的地方。
p1-1-4-3-2 = 使用 Android Studio创建一个新的Activity
p1-1-4-3-3 = 在你创建一个新的Activity的时候Android Studio 会自动创建<code>onCreate()</code> 方法。
li1-1-4-3-1-1 = 在Android Studio中, 在java 目录, 选择包, <strong>com.mycompany.myfirstapp</strong>, 右击, 选择 <strong>New > Activity > Blank Activity</strong>。
li1-1-4-3-1-2-1 = 在 <strong>Choose options</strong> 窗口, 填写activity的详细信息:
li1-1-4-3-2-1 = <strong>Activity Name</strong>: DisplayMessageActivity
li1-1-4-3-2-2 = <strong>Layout Name</strong>: activity_display_message
li1-1-4-3-2-3 = <strong>Title</strong>: My Message
li1-1-4-3-2-4 = <strong>Hierarchical Parent</strong>: com.mycompany.myfirstapp.MyActivity
li1-1-4-3-2-5 = <strong>Package name</strong>: com.mycompany.myfirstapp
li1-1-4-3-1-2-2 = 点击 <strong>Finish</strong>.
li1-1-4-3-1-3-1 = 打开 <code>DisplayMessageActivity.java</code> 文件。
li1-1-4-3-1-3-2 = 类中已经包含了所需的 <code>onCreate()</code> 方法的实现。在后面你将会修改这个方法实现。它同时也包含了<code>onOptionsItemSelected()</code>方法实现,这个方法用于处理action bar的行为。现在暂时不要修改这两个方法。
li1-1-4-3-1-4-1 = 删除 <code>onCreateOptionsMenu()</code> 方法。
li1-1-4-3-1-4-2 = 在这个实例中不需要它。
p1-1-4-3-4 = 如果你是使用 Android Studio开发, 你现在就可以运行app了，但是什么都没有发生。点击第二个按钮打开第二个activity，它使用了模板提供的默认的“Hello World”布局。 后面你将会修改这个activity展示自定义的视图。 
p1-1-4-3-5 = 不使用Android Studio创建activity
p1-1-4-3-6 = 如果你使用不同的 IDE 或者使用命令行工具, 按照如下操作:
li1-1-4-3-3-1 = 在项目的<code>src/</code>目录创建一个名为 <code>DisplayMessageActivity.java</code> 的新文件，就在之前 <code>MyActivity.java</code> 文件的旁边.
li1-1-4-3-3-2 = 在文件中添加下面的代码：
nc1-1-4-3-1 = 注意: 如果你使用的是其他的IDE而不是Android Studio，你的项目中不包含<code>setContentView()</code>所需要的<code>setContentView()</code>布局。这没什么问题，因为你在后面可以修改它从而不使用这个布局。
li1-1-4-3-3-3 = 找到你的 <code>strings.xml</code> 文件, 像下面一样添加activity的title：
li1-1-4-3-3-4 = 找到manifest 文件, <code>AndroidManifest.xml</code>, 在 <code>Application </code>元素中, 为<code>DisplayMessageActivity</code>类添加<code>&lt;activity&gt;</code> 元素, 如下所示:
p1-1-4-3-7 =  <code>android:parentActivityName</code> 属性声明了在这个app的逻辑结构中这个activity的父activity的名字。系统将会使用这值实现默认的导航行为，例如在android 4.1（API16）及以上的向上导航。在旧版本中你也可以实现相同的导航操作，只需要使用Support liberary并且添加如下所示的 <code>&lt;meta-data&gt;</code> 元素。
nc1-1-4-3-2 = 注意: 你的Android SDK 应该已经包含了最新的 Android Support Library, 这在你添加Android SDK包的时候就已经安装好了。当在Android Studio中使用模板的时候，Support Library会自动被添加到你的app项目中 (你可以在android dependencies列表中看到library的jar文件)。如果你没有使用Android Studio, 你需要按照配置Support Library的步骤手动的添加这个library到你的项目，然后再返回到这里。
p1-1-4-3-8 = 如果你是使用其他的IDE而不是Android Studio，不要担心这个app还不能编译。在后面你将很快会修改这个activity来展示自定义的视图。
sub_title1-1-4-4 = 接收 Intent
p1-1-4-4-1 = 每一个 <code>Activity</code> 都是通过<code>Intent</code>调用, 不管用户是以怎样的方式导航到这里。你都可以通过调用<code>getIntent()</code> 方法得到开启这个Activity的intent，并且接收intent携带的数据。
li1-1-4-4-1-1 = 在<code>java/com.mycompany.myfirstapp</code> 目录, 修改 <code>DisplayMessageActivity.java</code> 文件。
li1-1-4-4-1-2 = 在<code>onCreate()</code> 方法中, 删除下面的行:
li1-1-4-4-1-3 = 得到intent 并把它复制给局部变量。
li1-1-4-4-1-4-1 = 在文件的开始, 导入 Intent 类。
li1-1-4-4-1-4-2 = 在 Android Studio中, 使用 Alt + Enter (在Mac中是option + return)来导入需要的类。
li1-1-4-4-1-5 = 使用<code>getStringExtra()</code>方法提取通过<code>MyActivity</code>传递过来的消息。
sub_title1-1-4-5 = 展示消息
li1-1-4-5-1-1 = 在 <code>onCreate()</code> 方法, 创建一个<code>TextView</code> 对象。
li1-1-4-5-1-2 = 使用<code>setText()</code>设置文本内容。
li1-1-4-5-1-3 = 然后添加<code>TextView</code>， 并把它传递给 <code>setContentView()</code>，让它作为这个activity布局的根视图。
li1-1-4-5-1-4-1 = 在文件的开始, 导入<code>TextView</code> 类。
li1-1-4-5-1-4-2 = 在 Android Studio中, 使用 Alt + Enter (在Mac中是option + return)来导入需要的类。
p1-1-4-5-1 = 已经完成的<code>DisplayMessageActivity</code>中的 <code>onCreate()</code> 方法如下：
p1-1-4-5-2 = 你现在可以运行这个app了。当它打开的时候，在文本框中输入一些消息，点击Send，输入的消息会在第二个activity中显示。
p1-1-4-5-3 = 到此为止, 你已经创建了你的第一个Android app!
p1-1-4-5-4 = 想要学习更多的内容, 点击下面的链接到<a href="#c1-2">下一课</a>。
#		**********************************************************************************************************
#		Adding the Action Bar
#		**********************************************************************************************************
title1-2 = 添加Action Bar
p1-2-1 = 在你的App的Activity中，Action bar是中的其中一个最重要的设计元素。它提供了多种用户界面功能，这些功能保持了你的app和其他的Android app的一致性，从而让用户感到熟悉。主要的功能包括： 
li1-2-1-1 = 在你的应用中标识和指示用户位置的专用空间。
li1-2-1-2 = 可以预见性的添加功能 (例如 Search)。
li1-2-1-3 = 支持导航和视图切换 (使用tab或者下拉列表)。
p1-2-2 = 本次课程提供对于基础action bar的快速指南。关于action bar的更多特性，请参考Action bar指南。

#		**********************************************************************************************************
#		Setting Up the Action Bar
#		**********************************************************************************************************

title1-2-1 = 配置Action Bar
p1-2-1-1 = 最基本的形式, action bar 会在左边展示activity的标题和应用图标。即使是以最简单的形式，action bar对所有的activity来讲也是非常有用的，他可以让用户知道他们所在的位置，并且能够保持你的应用的一致性。
p1-2-1-2 = 配置一个基础的action bar需要给你的app设定主题来使Action bar可用。怎样设置这个主题取决于你的应用所支持的android 版本。因此根据你的应用所支持的最低android版本，我们把这一课分为两小节。
sub_title1-2-1-1 = 只支持 Android 3.0 及以上
p1-2-1-1-1 = 从Android 3.0 (API 11)开始, action bar被包含在了所有使用<code>Theme.Holo</code>主题（或者他的子主题）的activity中，并且当<code>targetSdkVersion</code> 或者 <code>minSdkVersion</code> 其中一个大于<code>"11"</code>的时候它是默认使用的主题。
p1-2-1-1-2 = 因此要想为你的activity添加action bar，只需要把上面的两个属性其中一个设置为<code>11</code>以上。例如：
nc1-2-1-1 = 注意: 如果你自定义了一个主题，要确保它把<code>Theme.Holo</code>或者它的子主题中的其中一个作为parent。详细信息参考“给action bar添加样式”。
p1-2-1-1-3 = 现在你的应用使用 <code>Theme.Holo</code>主题，并且所有的activity都显示了action bar。就这样。 
sub_title1-2-1-2 = 支持 Android 2.1及以上
p1-2-1-2-1 = 当运行在Android3.0之前(低至2.1)的系统时，要想添加Action bar，需要在你的应用中导入Android Support Library. 
p1-2-1-2-2 = 开始之前，请阅读Support Library的配置文档来配置<strong>v7 appcompat</strong> 资源库 (只要你下载了这个资源包，参考添加资源库的说明即可)。
p1-2-1-2-3 = 在你的应用中整合了Support Library之后：
li1-2-1-2-1-1 = 修改你的Activity继承<code>ActionBarActivity</code>。例如:
li1-2-1-2-1-2 = 在manifest 文件中, 修改u<code>&lt;application&gt;</code> 元素或者某个 <code>&lt;activity&gt;</code> 元素来使用其中一个Theme.AppCompat主题。例如：
nc1-2-1-2-1 = 注意: 如果你创建了自定义主题，请确保以其中一个<code>Theme.AppCompat</code>作为它的父主题。详细信息，请参考“给Action bar添加样式”。
p1-2-1-2-4 = 现在当你运行在Android2.1(API level 7)及以上的时候activity中已经添加好了action bar。
p1-2-1-2-5 = 记住要在manifest中正确设置应用的Api级别：

#		**********************************************************************************************************
#		Adding Action Buttons
#		**********************************************************************************************************

title1-2-2 = 添加 Action 按钮
p1-2-2-1 = 与当前上下文相关的最重要的行为项，可以在Action bar中添加按钮。那些直接在action bar中显示的图标或者文本被称为action 按钮。那些没有显示在action bar的或者不是十分重要的action都被隐藏在 action overflow。
sub_title1-2-2-1 = 在XML中定义Action
p1-2-2-1-1 = 所有action buttons 和其他的action overflow中可用的项都定义在<code>menu resource</code>中。给action bar添加action, 需要在你的<code>res/menu/</code>目录下创建一个新的XML文件。
p1-2-2-1-2 = 为每个你想在action bar中添加的项添加 <code>&lt;item&gt;</code> 元素。例如：
p1-2-2-1-3 = 在这里定义Search action应该在显示为action按钮，当action bar的空间足够的话。但是Settin 项应该一直显示在action overflow中。(默认情况下，所有的action 都出现在overflow中，但是为你的每个action 项显示的指定设计意图是非常好的做法。)
p1-2-2-1-4 = icon属性需要一个图片的资源id。跟在<code>@drawable/</code> 后面的图片名称必须是你在项目的<code>res/drawable/</code>目录下保存的图片的名称。例如，"<code>@drawable/ic_action_search</code>" 引用了 <code>ic_action_search.png</code>。相似的，title属性使用了字符串资源，这个资源定义在你的项目的<code>res/values/</code>目录下的XML文件中，在“构建一个简单的用户界面”中有讨论到。
nc1-2-2-1-1 = 住哟: 当为你的应用创建icon或者其他的图片的时候，非常重要的是，要提供针对每个屏幕尺寸来讲最优的多个图片版本。这些内容将会在“支持不同的屏幕”中有详细的讲解。
p1-2-2-1-5 = <strong>如果你的应用使用了 Support Library</strong> 来兼容像Android2.1这样的低版本，showAsAction 属性在android：命名空间下是不可用的。代替的，这个属性由Support Library支持，你必须定义自己的XML命名空间，然后把这个命名空间作为属性前缀。(自定义的XML命名空间应该依赖于你的应用的名字，但是你可以取任何你想要的名字，它只在它所在的文件范围内可用。) 例如:
sub_title1-2-2-2 = 在action bar上添加 Action
p1-2-2-2-1 = 要想把  menu items 添加到 action bar上, 需要实现你的Activity中的<code>onCreateOptionsMenu()</code> 回调方法来获取menu资源，然后把menu资源填充到给定的 <code>Menu</code> 对象中。例如:
sub_title1-2-2-3 = 响应 Action 按钮
p1-2-2-3-1 = 当用户点击其中一个action 按钮或者点击在action overflow中的其他项的时候，系统会调用activity的<code>onOptionsItemSelected()</code> 回调方法。在这个方法的实现中，调用给定MenuItem的 <code>getItemId()</code>方法来确定点击的是哪一个按钮，返回的id值和你定义的<code>&lt;item&gt;</code>元素的android:id属性相同。
sub_title1-2-2-4 = 响应Action 按钮
p1-2-2-4-1 = 当用户点击其中一个action 按钮或者点击在action overflow中的其他项的时候，系统会调用activity的<code>onOptionsItemSelected()</code> 回调方法。在这个方法的实现中，调用给定MenuItem的 <code>getItemId()</code>方法来确定点击的是哪一个按钮，返回的id值和你定义的<code>&lt;item&gt;</code>元素的android:id属性相同。
sub_title1-2-2-5 = 为低等级的activity添加返回按钮
p1-2-2-5-1 = 不是所有的界面都是你程序的主要入口(那些不是你主屏幕的activity)，应该提供用户一种方式，通过点击action bar上面的返回按钮来导航到逻辑上的应用的层次结构中的父窗口。
p1-2-2-5-2 = 当运行在Android 4.1 (API level 16) 及以上时, 或者当使用Support Library的<code>ActionBarActivity</code> 时，实现返回导航只需要你在manifest文件中声明父activity，然后为action bar打开up按钮。 
p1-2-2-5-3 = 例如, 下面演示如何在manifest中声明activity的父activity：
p1-2-2-5-4 = 然后通过调用<code>setDisplayHomeAsUpEnabled()</code>方法，应用icon作为up按钮：
p1-2-2-5-5 = 因为现在系统已经知道<code>MainActivity</code>是<code>DisplayMessageActivity</code>的父activity, 当用户点击Up按钮的时候，系统会导航正确的导航到父activity，你不需要处理Up按钮的事件。
p1-2-2-5-6 = 关于Up导航的更多信息，参考“提供返回导航”。

#		**********************************************************************************************************
#		Styling the Action Bar
#		**********************************************************************************************************

title1-2-3 = 给Action Bar添加样式
p1-2-3-1 = action bar提供给用户一种相似的可预见的方式来执行action和实现应用导航，但是这并不意味着它需要和其他的app长得完全一样。如果你想为你的action bar添加样式来匹配你的品牌，你可以简单的使用android的样式和主题资源。
p1-2-3-2 = Android 包含了一些内置的activity主题，包括“dark” 或者“light”的action bar样式。你也可以继承这些主题进一步定制你的action bar的外观。
nc1-2-3-1 = 注意: 如果你为Action bar使用了Support Library APIs，那么你必须使用或者复写Theme.AppCompat 类型的样式（而不是使用在API 11及以上可以用的Tmeme.Holo 类型）。 在这种情况下，每个样式属性都需要声明两遍：一次是使用系统样式属性(android: 属性)，另一次是使用包含在Support Library 中的样式属性(appcompat.R.attr properties\u2014这个属性的上下文实际上是你的应用)。 详细内容参考下面的例子。
sub_title1-2-3-1 = 使用Android 主题
p1-2-3-1-1 = 针对action bar的颜色，Android 包含了两个基本的activity主题：
li1-2-3-1-1-1 = <code>Theme.Holo</code> 用于 "dark" 主题。
li1-2-3-1-1-2 = <code>Theme.Holo.Light</code> 用于"light" 主题。
p1-2-3-1-2 = 你可以在你的整个应用或者某个activity上使用这个主题，只需要在manifest文件中的<code>&lt;application&gt;</code>元素或者某个<code>&lt;activity&gt;</code>元素指定<code>android:theme</code>即可。
p1-2-3-1-3 = 例如:
p1-2-3-1-4 = 你也可以让action bar是暗色的，而其他的activity内容是亮色的，只需要指定<code>Theme.Holo.Light.DarkActionBar</code> 主题即可。
p1-2-3-1-5 = 当使用Support Library时, 你必须使用<code>Theme.AppCompat</code> :
li1-2-3-1-1-1 = <code>Theme.AppCompat</code> 是 "dark" 主题。
li1-2-3-1-1-2 = <code>Theme.AppCompat.Light</code> 是 "light" 主题。
li1-2-3-1-1-3 = <code>Theme.AppCompat.Light.DarkActionBar</code> 是“light”主题，带有“dark”的action bar。
p1-2-3-1-6 = 要确保action bar的icon和action bar的颜色像匹配。为了更好的帮助你，Action bar 的icon包包含了标准的action图标可以使用，这些图标适用于Holo light 的和dark的action bar。
sub_title1-2-3-2 = 自定义背景
p1-2-3-2-1 = 要想修改action bar的背景，需要你为activity自定义一个主题，在这个主题中需要覆写<code>actionBarStyle</code>属性。这个属性指定了其他的样式，在这个样式中你可以修改 <code>background</code>属性，指定一个drawable资源作为action bar的背景。
p1-2-3-2-2 = 如果你的action bar <code>navigation tabs</code> 或者 <code>split action bar</code>, 那么你也可以分别使用code>backgroundStacked</code> 和 <code>backgroundSplit</code>属性来指定他们的背景。
cc1-2-3-2-1 = 警告: 为你的自定义主题制定一个适当的父主题是非常重要的，这样你就可以使用父主题中定义的样式。如果没有父主题，你的action bar将没有任何的样式，除非你明确声明它们的样式。
p1-2-3-2-3 = 只对Android 3.0 及以上
p1-2-3-2-4 = 当只需要支持 Android 3.0 及以上时, 你可以像如下那样定义action bar的背景颜色：
p1-2-3-2-5 = 然后再整个app或者某个activity上使用这个主题：
p1-2-3-2-6 = 对于Android 2.1 及以上
p1-2-3-2-7 = 当使用Support Library时, 实现上面功能相同的主题必须向下面这样：
p1-2-3-2-8 = 然后再整个app或者某个activity上使用这个主题：
sub_title1-2-3-3 = 自定义文本颜色
p1-2-3-3-1 = 要想修改action bar中文字的颜色。你需要分别为每个文本元素覆写它对应的属性：
li1-2-3-3-1-1 = Action bar 标题: 创建一个自定义样式指定textColor属性，并且给在<code>actionBarStyle</code>中定义的<code>titleTextStyle</code>属性指定这个样式。
nc1-2-3-3-1 = 注意: 用于<code>titleTextStyle</code>的自定义样式应该使用 <code>TextAppearance.Holo.Widget.ActionBar.Title</code>做为它的父样式。
li1-2-3-3-1-2 = Action bar tabs: 在你的activity主题中覆写 <code>actionBarTabTextStyle</code>。
li1-2-3-3-1-3 = Action buttons: 在你的activity中覆写 <code>actionMenuTextColor</code>属性。
p1-2-3-3-2 = 只对Android 3.0 及以上
p1-2-3-3-3 = 当只需要支持 Android 3.0 及其以上时, 你的XML样式文件应该是这样的：
p1-2-3-3-4 = 对于 Android 2.1及以上
p1-2-3-3-5 = 当使用了Support Library时,你的XML样式文件应该是这样的：
sub_title1-2-3-4 = 自定义Tab Indicator
p1-2-3-4-1 = 要想修改用于<code>navigation tabs</code>的指示器，需要创建一个activity主题，主题中需要覆写<code>actionBarTabStyle</code> 属性。这个属性指向其他的样式文件，在这个样式文件中覆写了<code>background</code>属性，这个属性应该指定为一个state-list drawable。
nc1-2-3-4-1 = 注意: 这个state-list drawable是非常重要的，这样的话当前选中的tab就通过和其他tab不同的背景颜色表明了它的状态。关于怎样创建一个drawable资源的更多信息，请阅读State List文档。
p1-2-3-4-2 = 例如, 这里有一个 state-list drawable， 他为一个action bar的tab指定了不同状态下的背景：
p1-2-3-4-3 = 对于 Android 3.0 及以上
p1-2-3-4-4 = 当只需要支持 Android 3.0 及其以上时, 你的XML样式文件应该是这样的：
p1-2-3-4-5 = 对于 Android 2.1及以上
p1-2-3-4-6 = 当使用了Support Library时,你的XML样式文件应该是这样的：

#		**********************************************************************************************************
#		Overlaying the Action Bar
#		**********************************************************************************************************

title1-2-4 = 叠加的 Action Bar
p1-2-4-1 = 默认情况下, action bar 出现在activity窗口的顶部，略微的减少了activity可用布局空间。如果在与用户交互的过程中，你想要隐藏或者展示这个action bar, 你可以调用ActionBar的 <code>hide()</code> 和 <code>show()</code>方法来实现。然而，这将会导致你的activity重新计算并且根据新尺寸重新绘制布局。
p1-2-4-2 = 为了避免在action bar显示或者隐藏的时候重新计算布局的尺寸，你应该把action bar 设置为叠加模式。当使用了叠加模式时，activity的布局会占用全部的可用空间，就像action bar不存在一样，系统会在你的布局的上一层绘制action bar。 这样会将布局的顶部遮盖住一部分，但是当action bar显示或者隐藏的时候系统就不需要重新计算布局的尺寸，实现了无缝过渡。
tc1-2-4-1 = 提示: 如果你希望布局在action bar后面部分可见，那么你需要给action bar创建自定义样式，并且给它指定一个不完全透明的背景，如图1展示的那样。关于怎样定义action bar的背景的更多信息，请参考<a href="#c1-2-3">给Action Bar添加样式</a>。
sub_title1-2-4-1 = 开启叠加模式
p1-2-4-1-1 = 要想把action bar设置为叠加模式，你需要创建自定义的主题，并且需要继承action bar的主题，在自定义主题中要设置<code>android:windowActionBarOverlay</code>属性为<code>true</code>。
p1-2-4-1-2 = 只支持 Android 3.0 及以上
p1-2-4-1-3 = 如果你的 <code>minSdkVersion</code> 设置为 11 或者以上, y你的自定义主题应该使用 <code>Theme.Holo</code> 主题 (或者它的子主题) as 作为父主题。例如:
p1-2-4-1-4 = 对于Android 2.1 及以上
p1-2-4-1-5 = 如果你的app使用了Support Library用于兼容android 3.0以下的版本，你的自定义主题应该使用 <code>Theme.AppCompat</code>(或者它的子主题)主题作为父主题。例如:
p1-2-4-1-6 = 另外需要注意的是，这个主题包含了对<code>windowActionBarOverlay</code>样式的两个定义：一个是带有<code>android:</code>前缀的，另一个是没有前缀的。带有android：前缀的那个适用于Android平台中支持这个属性的版本，不带前缀的那个适用于需要从Support Library中读取样式的较老一点的版本。
sub_title1-2-4-2 = 指定布局的上边距
p1-2-4-2-1 = 当Action bar处于叠加模式时，应该会挡住布局中应该保持可见部分。要想确保这些内容都一直保持在action bar的下面，则需要给这个视图的顶部添加margin或者padding，值的大小应该为指定的<code>actionBarSize</code>的值。例如:
p1-2-4-2-2 = 如果你在action bar中使用了 Support Library ，你需要移除<code>android:</code> 前缀。例如:
p1-2-4-2-3 = 这样的话, 没有前缀的<code>?attr/actionBarSize</code> 的值就适用于所有的版本，包括 Android 3.0及其以上。

#		**********************************************************************************************************
#		Supporting Different Devices
#		**********************************************************************************************************

title1-3 = 支持不同的设备
p1-3-1 = 在这个世界上，Android设备有非常多的外观和尺寸。设备的类型也非常的多，你有责任让你的app适用于大多数的设备。 为了在Android上更加的成功，你的app需要适应不同设备的配置变更。 其中一些重要的变更是不同的语言，屏幕尺寸，和不同的Android平台。
p1-3-2 = 本节课就教你怎样使用基础的平台特性。包括怎样利用可选择的资源以及其他的特性，这样你的应用就可以仅使用一个apk就可以在更多的设备上提升用户体验。

#		**********************************************************************************************************
#		Supporting Different Languages
#		**********************************************************************************************************

title1-3-1 = 支持不同的语言
p1-3-1-1 = 把UI上的字符串从你的app代码中提取到一个单独的文件中通常是很好的做法。在Android 项目中使用资源文件就使它更加的简单。
p1-3-1-2 = 如果你是使用 Android SDK Tools 创建Android项目(参考 创建一个Android 项目), 工具会在项目的顶层创建 <code>res/</code> 目录。在<code>res/</code> 目录中，真对不同的资源类型，有不同的资源目录。也有一些不同的资源文件，例如<code>res/values/strings.xml</code>, 在这里面保存了你的字符串值。
sub_title1-3-1-1 = 创建本地目录和String文件
p1-3-1-1-1 = 为了添加多语言的支持,需要在  <code>res/</code>内创建额外的<code>values</code>目录，并且目录名以连字符和ISO语言代码结尾。例如 ，<code>values-es/</code>是一个包含了简单资源的目录，它适用于那些语言码是“es”的地区。Android在运行时根据本地设置加载对应的资源。更多信息，请参考“提供可选择的资源”。
p1-3-1-1-2 = 一旦你需要支持某种语言，你就需要创建一个子的资源目录，并且黄建对应的string资源文件。例如:
p1-3-1-1-3 = 根据每个locale添加字符串值到适当的文件
p1-3-1-1-4 = 在运行时, Android system 会根据当前设备的locale设置使用相应的字符串资源。
p1-3-1-1-5 = 例如, 下面对一些针对不同语言的string资源文件。
p1-3-1-1-6 = English (默认的 locale), <code>/values/strings.xml:</code>
p1-3-1-1-7 = Spanish, <code>/values-es/strings.xml:</code>
p1-3-1-1-8 = French, <code>/values-fr/strings.xml:</code>
nc1-3-1-1-1 = 注意: 你可以使用locale限定词（或者配置限定词）在任何则资源类型，例如，你想要为不同的地区提供不同的drawable图片。更多信息参考本地化。 
sub_title1-3-1-2 = 使用 String 资源
p1-3-1-2-1 = 你可以在你的代码中引用string资源，其他的XML文件中通过<code>&lt;string&gt;</code>元素的<code>name</code> 属性指定的资源名来引应资源。
p1-3-1-2-2 = 在你的代码中，你可以通过 <code>R.string.&lt;string_name&gt;</code>语法来引用资源。有各种各样的方法按照这种方式接收字符串资源。
p1-3-1-2-3 = 例如:
p1-3-1-2-4 = 在其他的XML文件中,无论和是你希望引用一个字符串时，你都可以使用<code>@string/&lt;string_name&gt;</code>来引用字符串资源。
p1-3-1-2-5 = 例如:

#		**********************************************************************************************************
#		Supporting Different Screens
#		**********************************************************************************************************

title1-3-2 = Android 使用两个通用属性来给设备屏幕分类：尺寸和 密度。 你应该预料到你的应用将会被安装在不同屏幕分辩率和尺寸的设备上。因此，你应该包含一些可选择的资源，这样的话就可以在不同尺寸和分辨率的屏幕上优化你的应用的外观。
p1-3-2-1 = ndroid 使用两个通用属性来给设备屏幕分类：尺寸和 密度。 你应该预料到你的应用将会被安装在不同屏幕分辩率和尺寸的设备上。因此，你应该包含一些可选择的资源，这样的话就可以在不同尺寸和分辨率的屏幕上优化你的应用的外观。
li1-3-2-1-1 = 有四个等级的尺寸：small, normal, large, xlarge
li1-3-2-1-2 = 有四个等级的密度: low (ldpi), medium (mdpi), high (hdpi), extra high (xhdpi)
p1-3-2-2 = 你应该为不同的屏幕定义不同的布局和图片，你应该把这些可选的资源放在独立的目录中，和你存放不同语言的字符串一样。
p1-3-2-3 = 另外需要注意的是屏幕的方向（横屏还是竖屏）被认为是屏幕大小的变体，因此很多app应该修改布局来提高在不同方向上的用户体验。
sub_title1-3-2-1 = 创建不同的布局
p1-3-2-1-1 = 为了提升在不同屏幕上的用户体验，你应该为你想要支持的不同的屏幕尺寸创建独立的布局文件。每个布局文件应该被保存在合适和资源目录中，并且以-<code>&lt;screen_size&gt;</code> 后缀结尾命名。例如，大屏幕的独立的布局应该保存在<code>res/layout-large/</code>下。
nc1-3-2-1-1 = 注意: Android会自动缩放你的布局来更好的适应屏幕。因此， 对于不同尺寸屏幕的布局，你不需要担心UI元素的绝对大小，你需要关心的是影响用户体验的布局结构(例如哪些比较重要的视图的尺寸和相对于兄弟视图的位置)。
p1-3-2-1-2 = 例如, 在这个项目中包含了一个默认的布局和一个可用于大屏幕的布局：
p1-3-2-1-3 = 文件的名字必须完全相同，但是因为要给对应的屏幕提供一个优化的UI，所以文件内容是不同的。
p1-3-2-1-4 = 像往常一样在应用中引用你的布局：
p1-3-2-1-5 = 根据你的应用所运行在的设备屏幕的大小，系统会从适当的资源目录中加载布局文件。更多关于Android是怎样选择合适的资源的内容请参考“资源使用指南”。
p1-3-2-1-6 = 另外一个例子, 这里有一个项目，这个项目中为横向屏幕提供了可选的布局文件：
p1-3-2-1-7 = 默认情况下, <code>layout/main.xml</code> 文件使用于竖屏。
p1-3-2-1-8 = 如果你想为横屏提供一个特定的布局，同时要适应大屏幕时，那么你需要使用<code>large</code> 和 <code>land</code> 限定词:
nc1-3-2-1-2 = 注意: Android 3.2 及以上支持一种定义屏幕尺寸的更方便的方式，它允许你根据独立像素的最小宽度和高度来指定资源文件。本次课程不涉及这项新技术。更多信息，请参考“多屏幕设计” 。
sub_title1-3-2-2 = 创建不同的Bitmaps
p1-3-2-2-1 = 你应该一直使用那些可以在每个密度等级都可以正确缩放的bitmap资源：low, medium, high 和 extra-high 密度。这样有助于你在所有不同的屏幕密度上面实现比较好的图形效果。
p1-3-2-2-2 = 要想生成这样的图片，你应该把你的raw资源做成矢量格式，使用下面的缩放比例来为每个密度等级制作图片：
li1-3-2-2-1-1 = xhdpi: 2.0
li1-3-2-2-1-2 = hdpi: 1.5
li1-3-2-2-1-3 = mdpi: 1.0 (底线)
li1-3-2-2-1-4 = ldpi: 0.75
p1-3-2-2-3 = 这意味着，如果你为xhdpi的设备生成200x200的图片，那么你应该同样的为hdpi的屏幕生成150x150的图片，为mdpi的屏幕生成100x100的图片，为ldpi的屏幕生成75x75的图片资源。
p1-3-2-2-4 = 然后, 把这些文件放到对应的资源目录中：
p1-3-2-2-5 = 在你想引用 <code>@drawable/awesomeimage</code>的任何时候, 系统将会根据屏幕的密度选择最适合的bitmap资源。
nc1-3-2-2-1 = 注意: 低密度(ldpi) 的资源通常是必须的。当你提供了hdpi的资源时，系统会自动的把他们缩放到一半来适应ldpi的屏幕。
p1-3-2-2-6 = 更多关于怎样为你的应用创建icon资源的小技巧和指南请参考“图标设计指南”。

#		**********************************************************************************************************
#		Supporting Different Platform Versions
#		**********************************************************************************************************

title1-3-3 = 支持不同的平台版本
p1-3-3-1 = 然而，最新的android版本通常为你的app提供了很好的API，你应该继续支持android的老版本，直到有更多的设备获得了更新。本节将会教你怎样在支持老版本的同时使用新的API的特性。
p1-3-3-2 = Android平台版本记录会定期的更新，来展示在每个Android版本在设备上的占用比例，这些数据是基于连接到google商店的设备数量。一般情况下，你的应用的最新版本应该支持90%左右的活跃设备。
tc1-3-3-1 = 提示: 为了在更多的Android版本中提供更好的特性和功能，你应该在你的应用中使用Android Support Library，这样的话就可以在比较老的平台上使用一些当前平台的API功能。 
sub_title1-3-3-1 = 指定 最小 和 目标 API 等级
p1-3-3-1-1 = <code>AndroidManifest.xml</code> 文件描述了你的应用的详细信息，以及你的应用所支持的Android版本的信息。尤其是<code>&lt;uses-sdk&gt;</code> <code>minSdkVersion</code> 和 <code>targetSdkVersion</code> 属性，他们定义了你的应用可兼容的最低的API等级，以及你的设计和测试你应用所需的最高的API等级。
p1-3-3-1-2 = 例如:
p1-3-3-1-3 = 因为 Android新版本发布了，需要修改一些样式和行为。为了让你的应用能够更好的使用这些变化并且确保你的应用适应每个用户设备的样式， 你应该设置 <code>targetSdkVersion</code>的值为最新的Android版本。
sub_title1-3-3-2 = 在运行时检查系统版本
p1-3-3-2-1 = 在 <code>Build</code>常量类里面，Android为每个平台版本提供了一个不同的代码。在你的应用中使用这些代码作为构建条件来确保这些依赖于更高的API等级的代码只有在系统支持这些API时才执行。
nc1-3-3-2-1 = 注意: 当在解析 XML 资源时, Android 会忽略那些当前设备不支持的 XML 属性。所以你可以放心的使用那些只在新版本中支持的XML属性，而不需要担心在就的版本中使用这些代码时会产生错误。例如,如果你设置了<code>targetSdkVersion="11"</code>, 在Android 3.0 及其以上，你的应用中会默认包含的<code>ActionBar</code> 。然后添加了为action bar添加了menu 项，你需要在你的XML资源文件中设置 <code>android:showAsAction="ifRoom"</code> 。在跨版本的XML中这样做是安全的，因为那些比较老的版本会简单的忽略掉  <code>showAsAction</code>这个属性 (仅此而已，你不需要额外的按照版本分成<code>res/menu-v11/</code>)。
sub_title1-3-3-3 = 使用平台样式和主题
p1-3-3-3-1 = Android 提供了比较好的用户体验的主题，它指定了你的应用的外观，并且感觉应用就像底层操作系统一样。通过配置manifest文件这些主题可以使用在你的应用中。通过使用这种内置的样式和主题，在每次更新的版本的时候，你的应用程序就会自然的符合新的Android的样式和感觉。
p1-3-3-3-2 = 要想让你的activity看起来想一个dialog：
p1-3-3-3-3 = 使你的activity有一个透明的背景：
p1-3-3-3-4 = 使用你在 <code>/res/values/styles.xml</code>文件中的自定义主题：
p1-3-3-3-5 = 在整个应用中使用某个主题(所有的activity)，需要在<code>&lt;application&gt;</code>元素上添加<code>android:theme</code> 属性：
p1-3-3-3-6 = 关于创建和使用主题的更多信息，参考“样式和主题指南”。

#		**********************************************************************************************************
#		Managing the Activity Lifecycle
#		**********************************************************************************************************

title1-4 = 管理Activity 生命周期
p1-4-1 = 在用户使用，退出，返回你的应用时，activity实例在他的不同的生命周期状态之间转换。例如，当activity第一次启动时，它位于系统的最前面，并且与用户交互。 在这个过程中，android系统会调用activity的一系列的生命周期函数，在这些函数中你设置了用户界面以及一些其他的组件。如果用户打开了其他的activity或者切换到其他的应用，系统就会调用你的activity的另外的一些生命周期函数来把它放到后台(此时activity是不可见的，但是它的实例和状态一直保存着)。
p1-4-2 = 在生命周期回调方法中, 在用户离开或者进入这个activity的时候，你可以指定activity的行为。例如，如果你要构建一个直播视频播放器，在用户切换到其他应用的时候，你应该暂停播放并且停止网络连接。当用户返回的时候，你可以重新连接到网络然后允许用户在同一位置重新开始播放。
p1-4-3 = 本节课介绍activity实例中比较重要的生命周期函数，以及怎样使用这些生命周期函数来让你的activity做一些用户希望的事情，而不会在不需要的时候占用系统资源。

#		**********************************************************************************************************
#		Starting an Activity
#		**********************************************************************************************************

title1-4-1 = 打开一个Activity
p1-4-1-1 = 和通过main()方法启动的那些应用的编程方式不同，Android系统的启动代码是在activity中，通过调用一些特殊的回调方法，这些方法对应了activity特定的生命周期状态。有一系列的回调方法来启动一个activity，也有一系列的回调方法来销毁一个activity。
p1-4-1-2 = 本次课程概述了一些重要的生命周期函数，并且教你在创建一个新的activity实例的时候怎样处理第一个生命周期函数。
sub_title1-4-1-1 = 理解生命周期回调函数
p1-4-1-1-1 = 在Activity的生命周期中，系统会按照顺序调用一系列的生命周期，就像建造金字塔一样。就是这样，activity生命周期中的每一阶段就像在建造金字塔中的单独一步一样。在系统创建一个新的activity实例的同时，每个回调方法都在一步步的推进activity的状态。金子塔的最顶端就对应activity已经运行在最前端的并且可以和用户交互的状态。
p1-4-1-1-2 = 在用户想要离开这个 activity时,为了销毁这个activity，系统会调用另外的方法来让activity的状态回退到金字塔的底部。 在某些情况下，activity只会移动步骤中的一部分到达金字塔的底部然后等待(例如当用户切换到其他的应用的时候)，在这个状态下activity可以重新回到顶部(如果用户回到这个activity)并且恢复用户离开时的环境。
p1-4-1-1-3 = 根据你的activity的复杂程度，你的应用也可以不需要实现全部的生命周期函数。然而，理解每一个生命周期方法是非常重要的，并且实现这些方法来确保你的应用按照用户期望的方式执行。实现activity的生命周期方法来在以下几个方面确保你的应用的行为，包括： 
li1-4-1-1-1-1 = 在使用你的应用的时候，忽然接到电话或者切换到其他应用的时候不会崩溃。
li1-4-1-1-1-2 = 在用户没有使用它的时候不占用宝贵的系统资源。
li1-4-1-1-1-3 = 在用户退出然后再进入的时候不会丢失用户状态。
li1-4-1-1-1-4 = 当在恒竖屏切换的时候不会导致应用崩溃，并且不会丢失用户进度。
p1-4-1-1-4 = 在后面的课程中你将会学到，在图一中展示了一些activity在不同状态下转换的情况。然而，这些状态中只有三个是静态的。这就是说，activity只可以停留在这三个中的一个状态下：
dt1-4-1-1-1-1 = Resumed
dd1-4-1-1-1-1 = 在这个状态下, activity处于前台并且用户可以和它交互。(某些情况下也叫做"running" 状态。)
dt1-4-1-1-1-2 = Paused
dd1-4-1-1-1-2 = 在这个状态下, 这个activity被其他的activity挡住，但其他的activity是半透明的，或者没有完全遮盖住屏幕。在Paused状态下的activity不能相应用户输入也不会执行任何的代码。
dt1-4-1-1-1-3 = Stopped
dd1-4-1-1-1-3 = 在这个状态下, activity完全被隐藏了，并且对用户不可见；通常认为它处于后台。当处于stopped的状态时，activity实例和它所有的状信息包括一些变量的值被保存下来，但是仍然不能执行任何的代码。
p1-4-1-1-5 = 其他的状态 (Created 和 Started) 都是瞬时的状态，并且系统会迅速的调用下一个声明周期回调方法来转变到下一个状态。就是说，在系统调用了<code>onCreate()</code>之后会立即调用<code>onStart()</code>方法，然后就会迅速的执行 <code>onResume()</code>方法。
p1-4-1-1-6 = 这些是对基本的activity生命周期来讲的。现在你将开始学习一些特殊的生命周期行为。
sub_title1-4-1-2 = 指定应用的 Launcher Activity
p1-4-1-2-1 = 当用户在Home界面选择你的应用图标的时候，系统会调用你的应用中声明为“launcher”(或者main)的activity的 <code>onCreate()</code> 方法。这就是那个指向你的应用界面，作为你的应用入口点的activity。 
p1-4-1-2-2 = 你可以在位于项目根目录的manifest文件<code>AndroidManifest.xml</code>中定义哪一个activity作为main activity。
p1-4-1-2-3 = 应用的main activity必须在manifest文件中声明，并且使用<code>&lt;intent-filter&gt;</code>元素来指定 MAIN action和 LAUNCHER category。例如：
nc1-4-1-2-1 = 注意: 当你使用Android SDK工具创建了一个新的android项目的时候，默认的项目文件会包含一个Activity类，并且这个类在manifest文件中有带有这个filter的声明。
p1-4-1-2-4 = 如果你的所有activity中没有一个声明了 MAIN action 活着 LAUNCHER category, 那么你的应用的图标将不会出现在Home 界面的应用列表中。
sub_title1-4-1-3 = 创建一个新实例
p1-4-1-3-1 = 大多数的应用都会包含一些不同的activity来让用户执行不同的操作。无论一个activity是不是创建的main activity，在用户点击你的应用图标的时候或者响应用户操作打开你的应用中的其他的activity ，系统都会通过调用<code>onCreate()</code> 方法为每一个activity创建实例。
p1-4-1-3-2 = 你必须实现<code>onCreate()</code> 方法来执行基本的应用启动逻辑，这些逻辑只能在activity整个生命周期中执行一次。例如，在你的<code>onCreate()</code> 方法实现中应该定义用户界面，并且可能会初始化一些全局变量。
p1-4-1-3-3 = 例如, 下面的例子中，在 <code>onCreate()</code> 方法中执行了一些基本的activity 配置，包括定义用户界面(定义在XML布局文件中)，定义成员变量，以及配置一些UI。
cc1-4-1-3-1 = 注意: 仅在Android 2.0及其以上使用<code>SDK_INT</code>来阻止在老的版本中执行新的API代码。老板本将会跑出一个运行时异常。
p1-4-1-3-4 = 一旦执行完<code>onCreate()</code> 方法, 系统会调用<code>onStart()</code>，紧接着就会调用 <code>onResume()</code> 方法。 你的Activity将永远不会以Created和Started的状态存在。从技术上来讲, activity 在当调用<code>onStart()</code>的时候已经对用户可见, 但是<code>onResume()</code> 紧紧跟在它后面，并且activity会一直处于Resumed的状态，直到某些操作改变了它。例如当接到电话的时候，或者用户切换到其他的activity的时候，又或者在设备屏幕休眠的时候。
p1-4-1-3-5 = 在下面的课程中, 你将会看当从Paused或者Stopped的状态恢复一个activity时， 其他的启动方法，像 <code>onStart()</code> 和 <code>onResume()</code>,起到怎样的作用。
nc1-4-1-3-1 = 注意: <code>onCreate()</code> 方法有一个<code>savedInstanceState</code>参数，在后面的课程“恢复一个Activity”中会有讲到。
sub_title1-4-1-4 = 销毁Activity
p1-4-1-4-1 = Activity的第一个生命周期函数是 <code>onCreate()</code>, 最后一个生命周期函数是<code>onDestroy()</code>。当系统调用activity的这个方法的时候，就以为这activity实例将要从内存中完全被移除。
p1-4-1-4-2 = 大多数的应用不需要实现这个方法，因为本地的类引用会随着activity一起被销毁，并且你应该在activity的<code>onPause()</code> 和 <code>onStop()</code>方法中执行大部分的清理工作。 然而，如果你的应用包含在<code>onCreate()</code> 中创建的后台线程或者其他的长期运行的资源，如果不正确的关闭的话将会导致内存泄露。
nc1-4-1-4-1 = 注意: 在所有情况下系统都会在调用了<code>onPause()</code> 和 <code>onStop()</code>之后调用<code>onDestroy()</code>方法，除了一种情况：当你在<code>onCreate()</code>方法中调用<code>finish()</code>时。在某些情况下，例如当你的临时决定加载另外的activity时，你可能会在activity的<code>onCreate()</code>方法中调用<code>finish()</code>方法来结束这个activity。在这种情况下，系统会直接调用<code>onDestroy()</code>方法，而不再会调用其他的生命周期函数。

#		**********************************************************************************************************
#		Pausing and Resuming an Activity
#		**********************************************************************************************************

title1-4-2 = Pausing 和 Resuming 一个activity
p1-4-2-1 = 在正常的app使用过程中, 处于前台的activity会被某些其他的视图组件遮挡住，从而导致这个activity 暂停。例如，当一个半透明的activity打开时(例如以dialog的形式), 前一个activity会被暂停。只要这个activity是可见的但是不能获得用户焦点，那么它就保持paused状态。
p1-4-2-2 = 然而, 一旦activity被完全挡住并且不可见，那么他就停止了(在下一节中讨论)。
p1-4-2-3 = 当你的Activity进入了Paused状态, 系统会调用activity的 <code>onPause()</code> 方法，在这个方法中你可以停止正在进行的，在暂停状态下不应该继续执行的操作(例如video) 或者保存那些应该被永久保存的数据，万一用户执意要离开你的应用。如果用户从paused状态返回到你的activity，系统就会调用<code>onResume()</code>方法来唤醒他。
nc1-4-2-1 = 注意: 当activity收到要调用 <code>onPause()</code>时, 可能就表明了这个activity将会被暂停一段时间，并且用户有可能再次返回这个activity。然而，首先应该得到的指示是用户离开了你的activity。
sub_title1-4-2-1 = 暂停 Activity
p1-4-2-1-1 = 当系统调用activity的 <code>onPause()</code> 方法, 从技术上就以为这你的activity始终部分可见。但通常情况下是用户会离开这个activity，很快它就会进入stop状态。通常情况下你应该使用 <code>onPause()</code> 回调方法执行以下操作:
li1-4-2-1-1-1 = 停止动画或者其他的可能占用CPU的操作。
li1-4-2-1-1-2 = 提交未保存的修改, 只是针对那些当他们离开之后想要永久保存的数据(比如email的草稿)。
li1-4-2-1-1-3 = 在activity被暂停的，并且用户不在需要的时候，释放例如 broadcast receivers, 处理传感器 (向 GPS), 或者其他可能影响电池寿命的系统资源。
p1-4-2-1-2 = 例如, 如果你的应用使用Camera,那么<code>onPause()</code> 方法是释放Camera的很好的位置。
p1-4-2-1-3 = 总的来说, 你不应该使用 <code>onPause()</code>来永久存储用户的修改(比如表单中输入的用户信息)。唯一的你应该使用<code>onPause()</code>永久存储用户修改的情况是你确定用户希望自动保存修改。(当在起草一份邮件的时候)。 然而, 你应该避免在<code>onPause()</code>方法中执行CPU密集的操作，例如写入数据库，因为他将会减缓activity切换的速度(另外你应该在<code>onStop()</code>方法中执行资源占用量很大的关闭操作)。
p1-4-2-1-4 = 你应该在onPause()方法中执行那些相对简单的操作，这样才能保证在你的activity stop之后能够平滑的过度到下一个目的地。
nc1-4-2-1-1 = 注意: 当你的activity被paused的时候, Activity 的实例还会一直保存在内存中，当activity被唤醒的时候会重新被召回。在恢复到Resumed状态之前，你不需要重新初始化那些在任何回调方法中被创建的组件。
sub_title1-4-2-2 = 恢复你的 Activity
p1-4-2-2-1 = 当用户从Paused状态唤醒你的activity时，系统会调用onResume()方法。
p1-4-2-2-2 = 要注意每次当你的activity转变到前台的时候，系统都会调用这个方法，包括当它第一次被创建的时候。因此，你应该实现 <code>onResume()</code>方法来初始化那些你在<code>onPause()</code>方法中释放掉的组件，并且执行那些在每次进入Resumed状态必须要执行的初始化操作 (例如开始动画，或者初始化那些只有在activity获取用户焦点的时候才使用到的组件)。
p1-4-2-2-3 = 下面的 <code>onResume()</code> 例子是上面<code>onPause()</code> 例子的副本，因此他初始化了Camera并且在activity paused的时候释放。
#		**********************************************************************************************************
#		Stopping and Restarting an Activity
#		**********************************************************************************************************

title1-4-3 = 停止 和 重新开启 一个 Activity
p1-4-3-1 = 在activity的生命周期中正确的停止和重启activity是非常重要的，这样就可以确保让你的用户感知到你的应用是活动的并且没有丢失他们的进度。 这里有一些你的activity关闭和重启的主要情景：
li1-4-3-1-1 = 用户打开了当前应用窗口然后从你的应用切换到了其他的应用。当前正在处于前台的activity 停止了。如果用户通过Home界面的应用图标或者当前启动的应用窗口中返回到你的应用，activity就会重启。
li1-4-3-1-2 = 在你的应用中用户执行了一个操作打开了一个新的Activity。在第二个activity创建的时候，当前的activity就被停止了。如果现在用户点击返回按钮，第一个activity就会重新打开。
li1-4-3-1-3 = 在他或者她在使用你的应用的时候接到了一个电话的时候。
p1-4-3-2 = Activity类提供了两个生命周期方法，<code>onStop()</code> 和 <code>onRestart()</code>, 在这个方法中你可以指定怎样处理被停止和重启的情况。不像pause状态, 只遮挡住了部分的UI，在stop状态可以确定的是UI不再可见，并且用户焦点是在别的activity上 (或者是其他的应用上)。
nc1-4-3-1 = 注意: 因为当activity处于stopped状态时，提供依然会保持activity的实例，也有可能你完全不需要实现<code>onStop()</code> 和 <code>onRestart()</code>方法(或者甚至 <code>onStart()</code>方法)，对于那些相对简单的activity来讲，activity会正确的停止和重启，你只需要使用<code>onPause()</code>方法来从系统中暂停那些正在执行的操作。
sub_title1-4-3-1 = 停止Activity
p1-4-3-1-1 = 当调用activity的 <code>onStop()</code>方法时，activity是不可见的，并且你需要释放大多数那些在用户不需要使用这个activity时所不需要的资源。一旦你的activity被停止了，在系统内存不足的时候，系统可能会销毁activity的实例。 在极端的情况下，系统会直接杀死应用进程而不会调用<code>onDestroy()</code>方法，因此使用<code>onStop()</code>来释放资源是非常重要的。
p1-4-3-1-2 = 尽管<code>onPause()</code> 方法会在 <code>onStop()</code>之前执行, 你应该使用<code>onStop()</code> 来暂停占用CPU的t操作，例如向数据库中写入数据。
p1-4-3-1-3 = 例如, 这里有一个<code>onStop()</code>方法实现的例子，在这个方法里保存了笔记内容到永久存储中：
p1-4-3-1-4 = 当你的activity停止时, activity对象会被保存在内存中，在恢复到Resumed状态之前，你不需要重新初始化那些在任何回调方法中被创建的组件。 系统也会一直记录布局中每个Veiw的当前状态，因此如果用户在<code>EditText</code>控件中输入了文本，那么这个内容会被保留，因此你不需要保存和恢复它。
nc1-4-3-1-1 = 注意: 及时系统销毁了处于stopped状态下的activity，它仍然会在Bundle(一组键值对)中保存View对象的状态(比如在EditText中输入的文本) ，并且在用户重新回到相同的activity实例的时候恢复这些数据(下一节中会讨论更多于Boundle的内容，包括如何在你的activity销毁和重建的时候保存状态数据) 。
sub_title1-4-3-2 = Start/Restart Activity
p1-4-3-2-1 = 当你的activity从stopped状态重新返回到前台时，系统也会调用<code>onStart()</code> 方法, 在每次activity可见的时候都会调用这个方法(无论是重新启动还是第一次被创建)。 而<code>onRestart()</code> 方法只有在activity从stopped状态被唤醒,因此你可以使用它来执行那些可能只在activity处于stopped状态但是还没有被销毁时所需要的特定的修复工作。
p1-4-3-2-2 = 通常不会在<code>onRestart()</code> 方法中存储activity的状态，因此对于一般的应用而言，对于这个方法没有什么其他的内容指导。然而，因为你在<code>onStop()</code> 方法中清理了你的activity所以的资源，所以你应该在activity restart的时候重新实例化他们。到 Yet, you also need to instantiate them when your activity is created for the first time (when there's no existing instance of the activity). For this reason, you should usually use the <code>onStart()</code> callback method as the counterpart to the <code>onStop()</code> method, because the system calls <code>onStart()</code> both when it creates your activity and when it restarts the activity from the stopped state.
p1-4-3-2-3 = For example, because the user might have been away from your app for a long time before coming back it, the <code>onStart()</code> method is a good place to verify that required system features are enabled:
p1-4-3-2-4 = When the system destroys your activity, it calls the <code>onDestroy()</code> method for your Activity. Because you should generally have released most of your resources with <code>onStop()</code>, by the time you receive a call to <code>onDestroy()</code>, there's not much that most apps need to do. This method is your last chance to clean out resources that could lead to a memory leak, so you should be sure that additional threads are destroyed and other long-running actions like method tracing are also stopped.

#		**********************************************************************************************************
#		Recreating an Activity
#		**********************************************************************************************************

title1-4-4 = Recreating an Activity
p1-4-4-1 = There are a few scenarios in which your activity is destroyed due to normal app behavior, such as when the user presses the Back button or your activity signals its own destruction by calling <code>finish()</code>. The system may also destroy your activity if it's currently stopped and hasn't been used in a long time or the foreground activity requires more resources so the system must shut down background processes to recover memory.
p1-4-4-2 = When your activity is destroyed because the user presses Back or the activity finishes itself, the system's concept of that Activity instance is gone forever because the behavior indicates the activity is no longer needed. However, if the system destroys the activity due to system constraints (rather than normal app behavior), then although the actual Activity instance is gone, the system remembers that it existed such that if the user navigates back to it, the system creates a new instance of the activity using a set of saved data that describes the state of the activity when it was destroyed. The saved data that the system uses to restore the previous state is called the "instance state" and is a collection of key-value pairs stored in a Bundle object.
cc1-4-4-1 = Caution: Your activity will be destroyed and recreated each time the user rotates the screen. When the screen changes orientation, the system destroys and recreates the foreground activity because the screen configuration has changed and your activity might need to load alternative resources (such as the layout).
p1-4-4-3 = By default, the system uses the Bundle instance state to save information about each View object in your activity layout (such as the text value entered into an EditText object). So, if your activity instance is destroyed and recreated, the state of the layout is restored to its previous state with no code required by you. However, your activity might have more state information that you'd like to restore, such as member variables that track the user's progress in the activity.
nc1-4-4-1 = Note: In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the <code>android:id</code> attribute.
p1-4-4-4 = To save additional data about the activity state, you must override the <code>onSaveInstanceState()</code> callback method. The system calls this method when the user is leaving your activity and passes it the Bundle object that will be saved in the event that your activity is destroyed unexpectedly. If the system must recreate the activity instance later, it passes the same Bundle object to both the <code>onRestoreInstanceState()</code> and <code>onCreate()</code> methods.
sub_title1-4-4-1 = Save Your Activity State
p1-4-4-1-1 = As your activity begins to stop, the system calls <code>onSaveInstanceState()</code> so your activity can save state information with a collection of key-value pairs. The default implementation of this method saves information about the state of the activity's view hierarchy, such as the text in an EditText widget or the scroll position of a ListView.
p1-4-4-1-2 = To save additional state information for your activity, you must implement <code>onSaveInstanceState()</code> and add key-value pairs to the Bundle object. For example:
cc1-4-4-1-1 = Caution: Always call the superclass implementation of <code>onSaveInstanceState()</code> so the default implementation can save the state of the view hierarchy.
sub_title1-4-4-2 = Restore Your Activity State
p1-4-4-2-1 = When your activity is recreated after it was previously destroyed, you can recover your saved state from the Bundle that the system passes your activity. Both the <code>onCreate()</code> and <code>onRestoreInstanceState()</code> callback methods receive the same Bundle that contains the instance state information.
p1-4-4-2-2 = Because the <code>onCreate()</code> method is called whether the system is creating a new instance of your activity or recreating a previous one, you must check whether the state Bundle is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed.
p1-4-4-2-3 = For example, here's how you can restore some state data in <code>onCreate()</code>:
p1-4-4-2-4 = Instead of restoring the state during <code>onCreate()</code> you may choose to implement <code>onRestoreInstanceState()</code>, which the system calls after the <code>onStart()</code> method. The system calls <code>onRestoreInstanceState()</code> only if there is a saved state to restore, so you do not need to check whether the Bundle is null:
cc1-4-4-2-1 = Caution: Always call the superclass implementation of <code>onRestoreInstanceState()</code> so the default implementation can restore the state of the view hierarchy.
p1-4-4-2-5 = To learn more about recreating your activity due to a restart event at runtime (such as when the screen rotates), read Handling Runtime Changes.

#		**********************************************************************************************************
#		Building a Dynamic UI with Fragments
#		**********************************************************************************************************

title1-5 = Building a Dynamic UI with Fragments
p1-5-1 = To create a dynamic and multi-pane user interface on Android, you need to encapsulate UI components and activity behaviors into modules that you can swap into and out of your activities. You can create these modules with the Fragment class, which behaves somewhat like a nested activity that can define its own layout and manage its own lifecycle.
p1-5-2 = When a fragment specifies its own layout, it can be configured in different combinations with other fragments inside an activity to modify your layout configuration for different screen sizes (a small screen might show one fragment at a time, but a large screen can show two or more).
p1-5-3 = This class shows you how to create a dynamic user experience with fragments and optimize your app's user experience for devices with different screen sizes, all while continuing to support devices running versions as old as Android 1.6.

#		**********************************************************************************************************
#		Creating a Fragment
#		**********************************************************************************************************

title1-5-1 = Creating a Fragment
p1-5-1-1 = You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running (sort of like a "sub activity" that you can reuse in different activities). This lesson shows how to extend the Fragment class using the <code>Support Library</code> so your app remains compatible with devices running system versions as low as Android 1.6.
nc1-5-1-1 = Note: If you decide that the minimum API level your app requires is 11 or higher, you don't need to use the Support Library and can instead use the framework's built in Fragment class and related APIs. Just be aware that this lesson is focused on using the APIs from the Support Library, which use a specific package signature and sometimes slightly different API names than the versions included in the platform.
p1-5-1-2 = Before you begin this lesson, you must set up your Android project to use the Support Library. If you have not used the Support Library before, set up your project to use the v4 library by following the Support Library Setup document. However, you can also include the action bar in your activities by instead using the v7 appcompat library, which is compatible with Android 2.1 (API level 7) and also includes the Fragment APIs.
sub_title1-5-1-1 = Create a Fragment Class
p1-5-1-1-1 = To create a fragment, extend the Fragment class, then override key lifecycle methods to insert your app logic, similar to the way you would with an Activity class.
p1-5-1-1-2 = One difference when creating a Fragment is that you must use the <code>onCreateView()</code> callback to define the layout. In fact, this is the only callback you need in order to get a fragment running. For example, here's a simple fragment that specifies its own layout:
p1-5-1-1-3 = Just like an activity, a fragment should implement other lifecycle callbacks that allow you to manage its state as it is added or removed from the activity and as the activity transitions between its lifecycle states. For instance, when the activity's <code>onPause()</code> method is called, any fragments in the activity also receive a call to <code>onPause()</code>.
p1-5-1-1-4 = More information about the fragment lifecycle and callback methods is available in the Fragments developer guide.
sub_title1-5-1-2 = Add a Fragment to an Activity using XML
p1-5-1-2-1 = While fragments are reusable, modular UI components, each instance of a Fragment class must be associated with a parent FragmentActivity. You can achieve this association by defining each fragment within your activity layout XML file.
nc1-5-1-2-1 = Note: FragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity.
p1-5-1-2-2 = Here is an example layout file that adds two fragments to an activity when the device screen is considered "large" (specified by the <code>large</code> qualifier in the directory name).
tc1-5-1-2-1 = Tip: For more about creating layouts for different screen sizes, read Supporting Different Screen Sizes.
p1-5-1-2-3 = Then apply the layout to your activity:
p1-5-1-2-4 = If you're using the <code>v7 appcompat library</code>, your activity should instead extend ActionBarActivity, which is a subclass of FragmentActivity (for more information, read Adding the Action Bar).
nc1-5-1-2-2 = Note: When you add a fragment to an activity layout by defining the fragment in the layout XML file, you cannot remove the fragment at runtime. If you plan to swap your fragments in and out during user interaction, you must add the fragment to the activity when the activity first starts, as shown in the next lesson.

#		**********************************************************************************************************
#		Building a Flexible UI
#		**********************************************************************************************************

title1-5-2 = Building a Flexible UI
p1-5-2-1 = When designing your application to support a wide range of screen sizes, you can reuse your fragments in different layout configurations to optimize the user experience based on the available screen space.
p1-5-2-2 = For example, on a handset device it might be appropriate to display just one fragment at a time for a single-pane user interface. Conversely, you may want to set fragments side-by-side on a tablet which has a wider screen size to display more information to the user.
p1-5-2-3 = The <code>FragmentManager</code> class provides methods that allow you to add, remove, and replace fragments to an activity at runtime in order to create a dynamic experience.
sub_title1-5-2-1 = Add a Fragment to an Activity at Runtime
p1-5-2-1-1 = Rather than defining the fragments for an activity in the layout file\u2014as shown in the <a href="#c1-5-1">previous lesson</a> with the <code>&lt;fragment&gt;</code> element\u2014you can add a fragment to the activity during the activity runtime. This is necessary if you plan to change fragments during the life of the activity.
p1-5-2-1-2 = To perform a transaction such as add or remove a fragment, you must use the <code>FragmentManager</code> to create a <code>FragmentTransaction</code>, which provides APIs to add, remove, replace, and perform other fragment transactions.
p1-5-2-1-3 = If your activity allows the fragments to be removed and replaced, you should add the initial fragment(s) to the activity during the activity's <code>onCreate()</code> method.
p1-5-2-1-4 = An important rule when dealing with fragments\u2014especially when adding fragments at runtime\u2014is that your activity layout must include a container View in which you can insert the fragment.
p1-5-2-1-5 = The following layout is an alternative to the layout shown in the <a href="#c1-5-1">previous lesson</a> that shows only one fragment at a time. In order to replace one fragment with another, the activity's layout includes an empty FrameLayout that acts as the fragment container.
p1-5-2-1-6 = Notice that the filename is the same as the layout file in the previous lesson, but the layout directory does not have the large qualifier, so this layout is used when the device screen is smaller than large because the screen does not fit both fragments at the same time.
p1-5-2-1-7 = <code>res/layout/news_articles.xml:</code>
p1-5-2-1-8 = Inside your activity, call <code>getSupportFragmentManager()</code> to get a <code>FragmentManager</code> using the Support Library APIs. Then call <code>beginTransaction()</code> to create a FragmentTransaction and call <code>add()</code> to add a fragment.
p1-5-2-1-9 = You can perform multiple fragment transaction for the activity using the same FragmentTransaction. When you're ready to make the changes, you must call <code>commit()</code>.
p1-5-2-1-10 = For example, here's how to add a fragment to the previous layout:
p1-5-2-1-11 = Because the fragment has been added to the FrameLayout container at runtime\u2014instead of defining it in the activity's layout with a <code>&lt;fragment&gt;</code> element\u2014the activity can remove the fragment and replace it with a different one.
sub_title1-5-2-2 = Replace One Fragment with Another
p1-5-2-2-1 = The procedure to replace a fragment is similar to adding one, but requires the <code>replace()</code> method instead of <code>add()</code>.
p1-5-2-2-2 = Keep in mind that when you perform fragment transactions, such as replace or remove one, it's often appropriate to allow the user to navigate backward and "undo" the change. To allow the user to navigate backward through the fragment transactions, you must call <code>addToBackStack()</code> before you commit the <code>FragmentTransaction</code>.
nc1-5-2-2-1 = Note: When you remove or replace a fragment and add the transaction to the back stack, the fragment that is removed is stopped (not destroyed). If the user navigates back to restore the fragment, it restarts. If you do not add the transaction to the back stack, then the fragment is destroyed when removed or replaced.
p1-5-2-2-3 = Example of replacing one fragment with another:
p1-5-2-2-4 = The <code>addToBackStack()</code> method takes an optional string parameter that specifies a unique name for the transaction. The name isn't needed unless you plan to perform advanced fragment operations using the FragmentManager.BackStackEntry APIs.

#		**********************************************************************************************************
#		Communicating with Other Fragments
#		**********************************************************************************************************

title1-5-3 = Communicating with Other Fragments
p1-5-3-1 = In order to reuse the Fragment UI components, you should build each as a completely self-contained, modular component that defines its own layout and behavior. Once you have defined these reusable Fragments, you can associate them with an Activity and connect them with the application logic to realize the overall composite UI.
p1-5-3-2 = Often you will want one Fragment to communicate with another, for example to change the content based on a user event. All Fragment-to-Fragment communication is done through the associated Activity. Two Fragments should never communicate directly.
sub_title1-5-3-1 = Define an Interface
p1-5-3-1-1 = To allow a Fragment to communicate up to its Activity, you can define an interface in the Fragment class and implement it within the Activity. The Fragment captures the interface implementation during its onAttach() lifecycle method and can then call the Interface methods in order to communicate with the Activity.
p1-5-3-1-2 = Here is an example of Fragment to Activity communication:
p1-5-3-1-3 = Now the fragment can deliver messages to the activity by calling the <code>onArticleSelected()</code> method (or other methods in the interface) using the <code>mCallback</code> instance of the <code>OnHeadlineSelectedListener</code> interface.
p1-5-3-1-4 = For example, the following method in the fragment is called when the user clicks on a list item. The fragment uses the callback interface to deliver the event to the parent activity.
sub_title1-5-3-2 = Implement the Interface
p1-5-3-2-1 = In order to receive event callbacks from the fragment, the activity that hosts it must implement the interface defined in the fragment class.
p1-5-3-2-2 = For example, the following activity implements the interface from the above example.
sub_title1-5-3-3 = Deliver a Message to a Fragment
p1-5-3-3-1 = The host activity can deliver messages to a fragment by capturing the Fragment instance with <code>findFragmentById()</code>, then directly call the fragment's public methods.
p1-5-3-3-2 = For instance, imagine that the activity shown above may contain another fragment that's used to display the item specified by the data returned in the above callback method. In this case, the activity can pass the information received in the callback method to the other fragment that will display the item:

#		**********************************************************************************************************
#		Saving Data
#		**********************************************************************************************************

title1-6 = Saving Data
p1-6-1 = ost Android apps need to save data, even if only to save information about the app state during <code>onPause()</code> so the user's progress is not lost. Most non-trivial apps also need to save user settings, and some apps must manage large amounts of information in files and databases. This class introduces you to the principal data storage options in Android, including:
li1-6-1-1 = Saving key-value pairs of simple data types in a shared preferences file
li1-6-1-2 = Saving arbitrary files in Android's file system
li1-6-1-3 = Using databases managed by SQLite

#		**********************************************************************************************************
#		Saving Key-Value Sets
#		**********************************************************************************************************

title1-6-1 = Saving Key-Value Sets 
p1-6-1-1 = If you have a relatively small collection of key-values that you'd like to save, you should use the <code>SharedPreferences</code> APIs. A <code>SharedPreferences</code> object points to a file containing key-value pairs and provides simple methods to read and write them. Each <code>SharedPreferences</code> file is managed by the framework and can be private or shared.
p1-6-1-2 = This class shows you how to use the <code>SharedPreferences</code> APIs to store and retrieve simple values.
nc1-6-1-1 = Note: The SharedPreferences APIs are only for reading and writing key-value pairs and you should not confuse them with the Preference APIs, which help you build a user interface for your app settings (although they use SharedPreferences as their implementation to save the app settings). For information about using the Preference APIs, see the Settings guide.
sub_title1-6-1-1 = Get a Handle to a SharedPreferences 
p1-6-1-1-1 = You can create a new shared preference file or access an existing one by calling one of two methods:
li1-6-1-1-1-1 = <code>getSharedPreferences()</code> \u2014 Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any Context in your app.
li1-6-1-1-1-2 = <code>getPreferences()</code> \u2014 Use this from an Activity if you need to use only one shared preference file for the activity. Because this retrieves a default shared preference file that belongs to the activity, you don't need to supply a name.
p1-6-1-1-2 = For example, the following code is executed inside a Fragment. It accesses the shared preferences file that's identified by the resource string <code>R.string.preference_file_key</code> and opens it using the private mode so the file is accessible by only your app.
p1-6-1-1-3 = When naming your shared preference files, you should use a name that's uniquely identifiable to your app, such as <code>"com.example.myapp.PREFERENCE_FILE_KEY"</code>
p1-6-1-1-4 = Alternatively, if you need just one shared preference file for your activity, you can use the <code>getPreferences()</code> method:
cc1-6-1-1-1 = Caution: If you create a shared preferences file with <code>MODE_WORLD_READABLE</code> or <code>MODE_WORLD_WRITEABLE</code>, then any other apps that know the file identifier can access your data.
sub_title1-6-1-2 = Write to Shared Preferences
p1-6-1-2-1 = To write to a shared preferences file, create a <code>SharedPreferences.Editor</code> by calling <code>edit()</code> on your <code>SharedPreferences</code>.
p1-6-1-2-2 = Pass the keys and values you want to write with methods such as <code>putInt()</code> and <code>putString()</code>. Then call <code>commit()</code> to save the changes. For example:
sub_title1-6-1-3 = Read from Shared Preferences
p1-6-1-3-1 = To retrieve values from a shared preferences file, call methods such as <code>getInt()</code> and <code>getString()</code>, providing the key for the value you want, and optionally a default value to return if the key isn't present. For example:

#		**********************************************************************************************************
#		Saving Files
#		**********************************************************************************************************

title1-6-2 = Saving Files
p1-6-2-1 = Android uses a file system that's similar to disk-based file systems on other platforms. This lesson describes how to work with the Android file system to read and write files with the <code>File</code> APIs.
p1-6-2-2 = A <code>File</code> object is suited to reading or writing large amounts of data in start-to-finish order without skipping around. For example, it's good for image files or anything exchanged over a network.
p1-6-2-3 = This lesson shows how to perform basic file-related tasks in your app. The lesson assumes that you are familiar with the basics of the Linux file system and the standard file input/output APIs in <code>java.io</code>.
sub_title1-6-2-1 = Choose Internal or External Storage
p1-6-2-1-1 = All Android devices have two file storage areas: "internal" and "external" storage. These names come from the early days of Android, when most devices offered built-in non-volatile memory (internal storage), plus a removable storage medium such as a micro SD card (external storage). Some devices divide the permanent storage space into "internal" and "external" partitions, so even without a removable storage medium, there are always two storage spaces and the API behavior is the same whether the external storage is removable or not. The following lists summarize the facts about each storage space.
p1-6-2-1-2 = Internal storage:
li1-6-2-1-1-1 = It's always available.
li1-6-2-1-1-2 = Files saved here are accessible by only your app by default.
li1-6-2-1-1-3 = When the user uninstalls your app, the system removes all your app's files from internal storage.
p1-6-2-1-3 = Internal storage is best when you want to be sure that neither the user nor other apps can access your files.
p1-6-2-1-4 = External storage:
li1-6-2-1-2-1 = It's not always available, because the user can mount the external storage as USB storage and in some cases remove it from the device.
li1-6-2-1-2-2 = It's world-readable, so files saved here may be read outside of your control.
li1-6-2-1-2-3 = When the user uninstalls your app, the system removes your app's files from here only if you save them in the directory from <code>getExternalFilesDir()</code>.
p1-6-2-1-5 = External storage is the best place for files that don't require access restrictions and for files that you want to share with other apps or allow the user to access with a computer.
tc1-6-2-1-1 = Tip: Although apps are installed onto the internal storage by default, you can specify the <code>android:installLocation</code> attribute in your manifest so your app may be installed on external storage. Users appreciate this option when the APK size is very large and they have an external storage space that's larger than the internal storage. For more information, see App Install Location.
sub_title1-6-2-2 = Obtain Permissions for External Storage
p1-6-2-2-1 = To write to the external storage, you must request the <code>WRITE_EXTERNAL_STORAGE</code> permission in your <code>manifest file</code>:
cc1-6-2-2-1-1 = Caution: Currently, all apps have the ability to read the external storage without a special permission. However, this will change in a future release. If your app needs to read the external storage (but not write to it), then you will need to declare the READ_EXTERNAL_STORAGE permission. To ensure that your app continues to work as expected, you should declare this permission now, before the change takes effect.
cc1-6-2-2-1-2 = However, if your app uses the <code>WRITE_EXTERNAL_STORAGE</code> permission, then it implicitly has permission to read the external storage as well.
p1-6-2-2-2 = You don\u2019t need any permissions to save files on the internal storage. Your application always has permission to read and write files in its internal storage directory.
sub_title1-6-2-3 = Save a File on Internal Storage
p1-6-2-3-1 = When saving a file to internal storage, you can acquire the appropriate directory as a File by calling one of two methods:
dt1-6-2-3-1 = getFilesDir() 
dd1-6-2-3-1 = Returns a File representing an internal directory for your app.
dt1-6-2-3-2 = getCacheDir()
dd1-6-2-3-2 = Returns a File representing an internal directory for your app's temporary cache files. Be sure to delete each file once it is no longer needed and implement a reasonable size limit for the amount of memory you use at any given time, such as 1MB. If the system begins running low on storage, it may delete your cache files without warning.
p1-6-2-3-2 = To create a new file in one of these directories, you can use the <code>File()</code> constructor, passing the <code>File</code> provided by one of the above methods that specifies your internal storage directory. For example:
p1-6-2-3-3 = Alternatively, you can call <code>openFileOutput()</code> to get a <code>FileOutputStream</code> that writes to a file in your internal directory. For example, here's how to write some text to a file:
p1-6-2-3-4 = Or, if you need to cache some files, you should instead use <code>createTempFile()</code>. For example, the following method extracts the file name from a URL and creates a file with that name in your app's internal cache directory:
nc1-6-2-3-1 = Note: Your app's internal storage directory is specified by your app's package name in a special location of the Android file system. Technically, another app can read your internal files if you set the file mode to be readable. However, the other app would also need to know your app package name and file names. Other apps cannot browse your internal directories and do not have read or write access unless you explicitly set the files to be readable or writable. So as long as you use <code>MODE_PRIVATE</code> for your files on the internal storage, they are never accessible to other apps.
sub_title1-6-2-4 = Save a File on External Storage
p1-6-2-4-1 = Because the external storage may be unavailable\u2014such as when the user has mounted the storage to a PC or has removed the SD card that provides the external storage\u2014you should always verify that the volume is available before accessing it. You can query the external storage state by calling <code>getExternalStorageState()</code>. If the returned state is equal to <code>MEDIA_MOUNTED</code>, then you can read and write your files. For example, the following methods are useful to determine the storage availability:
p1-6-2-4-2 = Although the external storage is modifiable by the user and other apps, there are two categories of files you might save here:
dt1-6-2-4-1 = Public files
dd1-6-2-4-1-1 = Files that should be freely available to other apps and to the user. When the user uninstalls your app, these files should remain available to the user.
dd1-6-2-4-1-2 = For example, photos captured by your app or other downloaded files.
dt1-6-2-4-2 = Private files
dd1-6-2-4-2-1 = Files that rightfully belong to your app and should be deleted when the user uninstalls your app. Although these files are technically accessible by the user and other apps because they are on the external storage, they are files that realistically don't provide value to the user outside your app. When the user uninstalls your app, the system deletes all files in your app's external private directory.
dd1-6-2-4-2-2 = For example, additional resources downloaded by your app or temporary media files.
p1-6-2-4-3 = If you want to save public files on the external storage, use the <code>getExternalStoragePublicDirectory()</code> method to get a File representing the appropriate directory on the external storage. The method takes an argument specifying the type of file you want to save so that they can be logically organized with other public files, such as <code>DIRECTORY_MUSIC</code> or <code>DIRECTORY_PICTURES</code>. For example:
p1-6-2-4-4 = If you want to save files that are private to your app, you can acquire the appropriate directory by calling <code>getExternalFilesDir()</code> and passing it a name indicating the type of directory you'd like. Each directory created this way is added to a parent directory that encapsulates all your app's external storage files, which the system deletes when the user uninstalls your app.
p1-6-2-4-5 = For example, here's a method you can use to create a directory for an individual photo album:
p1-6-2-4-6 = If none of the pre-defined sub-directory names suit your files, you can instead call <code>getExternalFilesDir()</code> and pass null. This returns the root directory for your app's private directory on the external storage.
p1-6-2-4-7 = Remember that <code>getExternalFilesDir()</code> creates a directory inside a directory that is deleted when the user uninstalls your app. If the files you're saving should remain available after the user uninstalls your app\u2014such as when your app is a camera and the user will want to keep the photos\u2014you should instead use <code>getExternalStoragePublicDirectory()</code>.
p1-6-2-4-8 = Regardless of whether you use <code>getExternalStoragePublicDirectory()</code> for files that are shared or <code>getExternalFilesDir()</code> for files that are private to your app, it's important that you use directory names provided by API constants like <code>DIRECTORY_PICTURES</code>. These directory names ensure that the files are treated properly by the system. For instance, files saved in <code>DIRECTORY_RINGTONES</code> are categorized by the system media scanner as ringtones instead of music.
sub_title1-6-2-5 = Query Free Space
p1-6-2-5-1 = If you know ahead of time how much data you're saving, you can find out whether sufficient space is available without causing an <code>IOException</code> by calling <code>getFreeSpace()</code> or <code>getTotalSpace()</code>. These methods provide the current available space and the total space in the storage volume, respectively. This information is also useful to avoid filling the storage volume above a certain threshold.
p1-6-2-5-2 = However, the system does not guarantee that you can write as many bytes as are indicated by <code>getFreeSpace()</code>. If the number returned is a few MB more than the size of the data you want to save, or if the file system is less than 90% full, then it's probably safe to proceed. Otherwise, you probably shouldn't write to storage.
nc1-6-2-5-1 = Note: You aren't required to check the amount of available space before you save your file. You can instead try writing the file right away, then catch an <code>IOException</code> if one occurs. You may need to do this if you don't know exactly how much space you need. For example, if you change the file's encoding before you save it by converting a PNG image to JPEG, you won't know the file's size beforehand.
sub_title1-6-2-6 = Delete a File
p1-6-2-6-1 = You should always delete files that you no longer need. The most straightforward way to delete a file is to have the opened file reference call <code>delete()</code> on itself.
p1-6-2-6-2 = If the file is saved on internal storage, you can also ask the <code>Context</code> to locate and delete a file by calling <code>deleteFile()</code>:
nc1-6-2-6-1-1 = Note: When the user uninstalls your app, the Android system deletes the following:
li1-6-2-6-1-1 = All files you saved on internal storage
li1-6-2-6-1-2 = All files you saved on external storage using <code>getExternalFilesDir()</code>.
nc1-6-2-6-1-2 = However, you should manually delete all cached files created with <code>getCacheDir()</code> on a regular basis and also regularly delete other files you no longer need.

#		**********************************************************************************************************
#		Saving Data in SQL Databases
#		**********************************************************************************************************

title1-6-3 = Saving Data in SQL Databases
p1-6-3-1 = Saving data to a database is ideal for repeating or structured data, such as contact information. This class assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the <code>android.database.sqlite</code> package.
sub_title1-6-3-1 = Define a Schema and Contract
p1-6-3-1-1 = One of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.
p1-6-3-1-2 = A contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.
p1-6-3-1-3 = A good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table that enumerates its columns.
nc1-6-3-1-1 = Note: By implementing the <code>BaseColumns</code> interface, your inner class can inherit a primary key field called _ID that some Android classes such as cursor adaptors will expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.
p1-6-3-1-4 = For example, this snippet defines the table name and column names for a single table:
sub_title1-6-3-2 = Create a Database Using a SQL Helper
p1-6-3-2-1 = Once you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:
p1-6-3-2-2 = Just like files that you save on the device's <code>internal storage</code>, Android stores your database in private disk space that's associated application. Your data is secure, because by default this area is not accessible to other applications.
p1-6-3-2-3 = A useful set of APIs is available in the <code>SQLiteOpenHelper</code> class. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call <code>getWritableDatabase()</code> or <code>getReadableDatabase()</code>.
nc1-6-3-2-1 = Note: Because they can be long-running, be sure that you call <code>getWritableDatabase()</code> or <code>getReadableDatabase()</code> in a background thread, such as with <code>AsyncTask</code> or <code>IntentService</code>.
p1-6-3-2-4 = To use SQLiteOpenHelper, create a subclass that overrides the <code>onCreate()</code>, <code>onUpgrade()</code> and <code>onOpen()</code> callback methods. You may also want to implement <code>onDowngrade()</code>, but it's not required.
p1-6-3-2-5 = For example, here's an implementation of SQLiteOpenHelper that uses some of the commands shown above:
p1-6-3-2-6 = To access your database, instantiate your subclass of <code>SQLiteOpenHelper</code>:
sub_title1-6-3-3 = Put Information into a Database
p1-6-3-3-1 = Insert data into the database by passing a <code>ContentValues</code> object to the <code>insert()</code> method:
p1-6-3-3-2 = The first argument for <code>insert()</code> is simply the table name. The second argument provides the name of a column in which the framework can insert NULL in the event that the <code>ContentValues</code> is empty (if you instead set this to <code>"null"</code>, then the framework will not insert a row when there are no values).
sub_title1-6-3-4 = Read Information from a Database
p1-6-3-4-1 = To read from a database, use the <code>query()</code> method, passing it your selection criteria and desired columns. The method combines elements of <code>insert()</code> and <code>update()</code>, except the column list defines the data you want to fetch, rather than the data to insert. The results of the query are returned to you in a <code>Cursor</code> object.
p1-6-3-4-2 = To look at a row in the cursor, use one of the Cursor move methods, which you must always call before you begin reading values. Generally, you should start by calling <code>moveToFirst()</code>, which places the "read position" on the first entry in the results. For each row, you can read a column's value by calling one of the Cursor get methods, such as <code>getString()</code> or <code>getLong()</code>. For each of the get methods, you must pass the index position of the column you desire, which you can get by calling <code>getColumnIndex()</code> or <code>getColumnIndexOrThrow()</code>. For example:
sub_title1-6-3-5 = Delete Information from a Database
p1-6-3-5-1 = To delete rows from a table, you need to provide selection criteria that identify the rows. The database API provides a mechanism for creating selection criteria that protects against SQL injection. The mechanism divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.
sub_title1-6-3-6 = Update a Database
p1-6-3-6-1 = When you need to modify a subset of your database values, use the <code>update()</code> method.
p1-6-3-6-2 = Updating the table combines the content values syntax of <code>insert()</code> with the where syntax of <code>delete()</code>.

#		**********************************************************************************************************
#		Interacting with Other Apps
#		**********************************************************************************************************

title1-7 = 与其他APP交互
p1-7-1 = 一般一个安卓应用都会有几个Activity。每一个activity为用户执行某一个特定功能而提供一个交互界面（比如展示地图或者拍照）。想要把用户从一个activity带到另一个，你必须使用Intent来定义你的应用程序的意图。当你使用<code>startActivity()</code>方法将Intent传递给系统时，系统会使用这个Intent来定位并打开对应的应用组件。使用意图甚至可以打开另一个独立应用的activity。
p1-7-2 = 一个意图可以使显式的也可以是隐式的。显式的意图可以打开一个特定的组件（一个特定的activity实例），而一个隐式的意图则可以打开所有符合功能需求的组件（比如“拍一张照片”）。
p1-7-3 = 这一节将会向你展示如何使用Intent来与其他应用进行最基本的交互，比如打开其他应用，从那个打开的应用获得数据，并且让你的应用能够响应来自其它应用的意图。

#		**********************************************************************************************************
#		Sending the User to Another App
#		**********************************************************************************************************

title1-7-1 = 引导用户到另外的应用
p1-7-1-1 = 安卓一个最重要的特点就是能够根据用户所要进行的操作跳转到相应功能的应用之中。比如，如果你的应用有一些地址想显示在地图上，你不需要在你的应用中创建一个activity来专门显示地图。你需要做的就是向系统发送一个访问地图的清酒。接下来系统会自动帮你打开能够显示地图的应用。
p1-7-1-2 = 就像在第一节“创建第一个应用”中解释的那样，在你自己的应用中，你必须通过意图来进行activity之间的跳转。你通常会使用显式意图，即指定想要开启组件的类名来进行跳转。然而，当你想要另外一个应用来处理一个你想要的动作时（比如查看地图），你必须使用隐式意图。
p1-7-1-3 = 这一节将向你展示如何为某一个行为创建隐式意图，并且使用这个意图打开一个能够处理那一行为的应用。
sub_title1-7-1-1 = 创建一个隐式意图
p1-7-1-1-1 = 隐式意图不会指定将要打开组件的类名，而是指定将要进行的操作行为。这一行为就是你想要做的操作，比如查看，修改，发送或者获取。意图经常还会为行为添加一些数据，比如你想要在地图中查看的地址，或者你想要发送邮件的目的地。根据你希望创建意图目的的不同，数据格式也会有所不同（比如Uri），或者你想要的意图根本不需要任何数据。
p1-7-1-1-2 = 如果你的数据类型是Uri,你可以使用Intent的 <code>Intent()</code> 构造函数来定义行为和数据。
p1-7-1-1-3 = 比如，这里会展示如何创建一个意图来拨打电话，并且如何指定要拨打的电话号码：
p1-7-1-1-4 = 当你的应用通过<code>startActivity()</code>方法执行这个意图之后，拨号程序会拨打你给定的电话号码。
p1-7-1-1-5 = 下面是一些其它意图和这些意图的行为，数据键值对：
li1-7-1-1-1-1 = 查看地图：
li1-7-1-1-1-2 = 浏览网页：
p1-7-1-1-6 = 其它类型的隐式意图需要一些其它类型的额外数据，比如字符串。你可以通过<code>putExtra()</code>方法来添加一个或多个额外数据。
p1-7-1-1-7 = 默认情况下，系统会根据你引入的Uri类型的数据来决定MIME类型。如果你没有引入Uri类型的数据，你需要使用<code>setType()</code>方法来指定分配给意图的数据类型。设定了MIME类型可以进一步明确哪些activity将会接收这个意图。
p1-7-1-1-8 = 下面是一些意图通过添加额外数据来指明自己期望的操作：
li1-7-1-1-2-1 = 发送带有附件的邮件：
li1-7-1-1-2-2 = 创建日历事件：
nc1-7-1-1-1 = 注意：创建日历事件的意图仅仅在API 14之上才被支持。
nc1-7-1-1-2 = 注意：将你的意图定义的尽可能的详细是十分必要的。比如，当你使用ACTION_VIEW意图来展示一张图片，你应该同时指定MIME类型为<code>image/*</code>。这样就不会触发其他拥有“查看”功能的应用（比如地图）。
sub_title1-7-1-2 = 确保至少有一个应用会接收你的意图
p1-7-1-2-1 = 尽管安卓平台能够保证特定的意图会触发对应的内建应用（比如电话，邮件或者日历因公），你还是应该在执行你的意图之前做一步校验操作。
cc1-7-1-2-1 = 注意：如果你执行的意图没有对应的应用进行处理，那么你的程序会崩溃。
p1-7-1-2-2 = 为了保证有应用会相应你的意图，调用<code>queryIntentActivities()</code>方法来获得一能够处理你意图的应用程序的列表。如果这个列表不是空的，那么你就可以安心的执行你的意图了。比如：
p1-7-1-2-3 = 如果<code>isIntentSafe</code>为<code>true</code>，那么至少有一个应用会相应你的意图。如果为<code>false</code>，那么就表明没有应用会处理你的意图。
nc1-7-1-2-1 = 注意：你应该在你的应用刚启动时就做这种检查，这样你就可以提前隐藏相对应的功能，而不是让用户发现这个功能无法使用。如果你知道有特定的应用能够处理你的需求，你也可以为用户提供一个连接指引用户前去下载。
sub_title1-7-1-3 = 使用意图来开启一个Activity
p1-7-1-3-1 = 一旦你创建了你的意图并且设置的一些额外的信息，调用<code>startActivity()</code>方法将你的意图发送给系统。如果系统发现有多于一个activity可以处理这个意图，它会显示一个对话框让用户选择其中一个。如果只有一个应用可以处理你的意图，系统会立即打开它。
p1-7-1-3-2 = 这是一个完整的例子展示如何创建一个意图来查看地图，保证至少有一个引用来处理这个意图，然后启动它：
sub_title1-7-1-4 = 展示应用选择对话框
p1-7-1-4-1 = 注意当你发送一个意图，而有多个应用能够处理这个意图时，用户可以选择一个应用作为默认处理程序（通过选择在对话框底部的选择框）。当你每次都想使用同一个应用时，这个功能是很不错的，比如当打开网页（用户更愿意使用同一个浏览器）或者拍一张照片（用户通常使用一个照相机应用）。
p1-7-1-4-2 = 然而，当用户不希望都使用一个应用时，比如分享操作，用户可能拥有数个应用来分享给不同的群体。这时你应该显式的展示一个选择对话框。这个选择对话框强制用户每次进行这个操作时都要手动选择一个应用（用户不能选择默认程序）。
p1-7-1-4-3 = 想要显式一个选择对话框，使用<code>createChooser()</code>创建一个意图，并将这个意图传给<code>startActivity()</code>方法。比如：
p1-7-1-4-4 = 这些到吗展示了一个应用列表对话框，并且使用自定义的文本作为对话框的标题。

#		**********************************************************************************************************
#		Getting a Result from an Activity
#		**********************************************************************************************************

title1-7-2 = 从另外的Activity获取返回结果
p1-7-2-1 = 开启另外的activity的方法并不一定是单向的。你也可能想从之前打开的应用中获取一些结果。想要获得这些数据，调用<code>startActivityForResult()</code>方法（而不是<code>startActivity()</code>）。
p1-7-2-2 = 比如，你的应用可以开启一个拍照应用并从那个应用获得拍好的照片。或者，你可以开启一个联系人应用并从那个应用中获取选中联系人的详细信息。
p1-7-2-3 = 当然，那个将会返回值的activity必须要设计成能够返回值。当它被设计好后，它会返回一个有返回信息的另一个意图对象。你的应用会在<code>onActivityResult()</code>回调方法中获得这个意图对象。
nc1-7-2-1 = 注意：<code>startActivityForResult()</code>方法可以用在显式意图和隐式意图上。当启动你自己应用的activity时，你应该使用显式意图，这样所得到的结果才是你所预期的。
sub_title1-7-2-1 = 启动Activity
p1-7-2-1-1 = 你使用的用来获得返回值的意图对象并没有什么特别的地方，但是在调用<code>startActivityForResult()</code>方法时你需要传递一个额外的整形参数。
p1-7-2-1-2 = 这个整形参数是一个“请求码”来标示你的这次请求。当你获得了作为结果传回来的Intent对象后，回调函数会提供数值相同的请求码，这样你的应用可以确定这是来自哪一个请求，并做出相应的处理。
p1-7-2-1-3 = 比如，这个例子展示了如何启动一个activity并让用户选择一个联系人：
sub_title1-7-2-2 = 获得返回值
p1-7-2-2-1 = 当用户操作完打开的其他应用并返回时，系统会调用你activity的<code>onActivityResult()</code>方法。这个方法包含三个参数：
li1-7-2-2-1-1 = 你在<code>startActivityForResult()</code>传入的请求码。
li1-7-2-2-1-2 = 由第二个activity提供的返回码。如果操作成功返回<code>RESULT_OK</code>，如果操作失败或者用户取消操作，返回<code>RESULT_CANCELED</code>。
li1-7-2-2-1-3 = 一个包含返回数据的Intent。
p1-7-2-2-2 = 比如，这是一个关于如何操作返回的联系人的例子：
p1-7-2-2-3 = 例子中，由安卓联系人应用返回的结果意图中提供了一个Uri，这个Uri指明了之前用户选择了哪个联系人。
p1-7-2-2-4 = 为了能共成功的处理这个结果，你必须知道返回的结果是什么格式的。如果这是你自己的应用，那么这很容易处理。内建的安卓应用都会提供它们的API，你可以通过查看这些API来获知返回结果的格式。比如给，联系人应用会返回选中联系人的URI，照相机应用会在额外数据中返回Bitmap。
p1-7-2-2-5 = 额外内容：读取联系人数据
p1-7-2-2-6 = 以上的代码展示了如何从联系人应用获取结果，并没有详细说明如何读到这些信息，因为这需要有关内容提供者的知识。但是如果你还是很好奇，这里有一些代码来展示如何从选中的联系人中获得电话号码：
nc1-7-2-2-1 = 注意：在安卓2.3之前（API 9），想要查询联系人信息需要获得<code>READ_CONTACTS</code>权限。然而，从安卓2.3开始，联系人应用给你的应用一个暂时授权，可以从中获得联系人信息。这个暂时授权使能查询到URI指定的联系人，如果你想访问所有联系人，请获得<code>READ_CONTACTS</code>权限。

#		**********************************************************************************************************
#		Allowing Other Apps to Start Your Activity
#		**********************************************************************************************************

title1-7-3 = 允许其他的Apps开启你的Activity
p1-7-3-1 = 前面两节主要讲了从自己应用到其它应用的单向请求。同样的，如果你的应用能够响应某种行为同样对其它的应用有所帮助，你的应用应该为其它应用的这种行为时刻准备着。比如，你创建了一个社交应用可以给好友分享文字或者照片，那么你的应用应该支持<code>ACTION_SEND</code>意图的请求，这样当用户进行分享操作时就有可能进入到你的应用。
p1-7-3-2 = 为了让其他应用能够启动你的应用的Activity，你需要在manifest文件对应的<code>&lt;activity&gt;</code>中添加<code>&lt;intent-filter&gt;</code>标签。
p1-7-3-3 = 当你的应用安装在手机上之后，系统会标示你的意图过滤器（intent filter）并把相关信息存储在内部的目录中，这个目录可以被手机上所有的应用访问。当应用隐式调用<code>startActivity()</code>或者<code>startActivityForResult()</code>时，系统会在目录中找到相对应的activity。
sub_title1-7-3-1 = 添加意图过滤器
p1-7-3-1-1 = 为了准确的定义你的activity能够处理哪些意图，你添加的每一个意图过滤器应该尽可能的准确。
p1-7-3-1-2 = 当一个Activity满足以下几方面的需求时，系统就会把意图交给这个Activity处理：
dt1-7-3-1-1 = Action
dd1-7-3-1-1-1 = 一个行为的字符名称。通常为系统内置的几个值之一，比如<code>ACTION_SEND</code>或者<CODE>ACTION_VIEW</code>。
dd1-7-3-1-1-2 = 在你的意图过滤器中使用<code>&lt;action&gt;</code>元素指定Action值。你指定的值必须是行为的全程，而不是API常量。
dt1-7-3-1-2 = Data
dd1-7-3-1-2-1 = 传递给意图的类型的描述。
dd1-7-3-1-2-2 = 在你的意图过滤器中使用<code>&lt;data&gt;</code>元素添加Data。在这个元素中定义一个或多个属性，你可以只指定MIME类型，只指定URI前缀，只指定URI格式，或者同时指定以上这些。
nc1-7-3-1-1 = 注意：如果你不需要定义数据URI的细节（比如当你的activity处理其他类型的数据，而不是URI时），你应该只指定<code>android:mimeType</code>属性来说明你的activity所处理数据的类型，比如<code>text/plain</code>或者<code>image/jpeg</code>。
dt1-7-3-1-3 = Category
dd1-7-3-1-3-1 = 提供了一个额外的方式来筛选处理意图的activity，通常与用户手势或者它开始位置有关。系统支持集中不同的类型，但是大部分很少被使用。然而，所有的意图都有一个<code>CATEGORY_DEFAULT</code>类型作为默认值。
dd1-7-3-1-3-2 = 在你的意图过滤器中使用<code>&lt;category&gt;</code>元素来定义Category
p1-7-3-1-3 = 在你的意图过滤器中，你可以通过在<code>&lt;intent-filter&gt;</code>元素中添加它们相对应的元素来定义你的activity可以接受的规则。
p1-7-3-1-4 = 比如，这里有一个activity，这个activity处理action为<code>ACTION_SEND</code>的请求，处理的文件类型为文本或者图片：
p1-7-3-1-5 = 任何一个被选中的意图都定义了一个action和一个数据类型，但是同事定义多个action,category和data也是可以的。
p1-7-3-1-6 = 当任意两对action和数据相互独立时，你应该创建两个独立的意图过滤器来指明那个行为对应哪个数据类型。
p1-7-3-1-7 = 比如，假设你的activity处理的文件类型包括文字和图像，而处理的行为有<code>ACTION_SEND</code>和<code>ACTION_SENDTO</code>意图。这种情况下，你必须定义为两个action定义两个单独的意图过滤器，因为<code>ACTION_SENDTO</code>意图必须使用数据的URI来指定接收方的地址。比如：
nc1-7-3-1-2 = 注意：为了能够接收隐式意图，你必须在你的意图过滤器中包含<code>CATEGORY_DEFAULT</code>类型。<code>startActivity()</code>和<code>startActivityForResult()</code>方法都认为所有的intent都定义了<code>CATEGORY_DEFAULT</code>类型。如果你没有定义这个类型，将不会有任何intent传递给你的activity。
p1-7-3-1-8 = For more information about sending and receiving <code>ACTION_SEND</code> intents that perform social sharing behaviors, see the lesson about Receiving Simple Data from Other Apps.
sub_title1-7-3-2 = 在你的Activity中处理意图
p1-7-3-2-1 = 为了决定你的Activity接收到的是哪个行动，你可以从启动这个Activity的intent中获取相应信息。
p1-7-3-2-2 = 当你的activity启动的时候，调用<code>getIntent()</code>可以获得启动这个activity的意图。你可以在activity的生命周期内随时调用这个方法，但是一般应该在较早的时候调用，比如<code>onCreate()</code>或者<code>onStart()</code>。
p1-7-3-2-3 = 比如：
sub_title1-7-3-3 = 返回一个结果
p1-7-3-3-1 = 如果你想向调用你的应用返回一个结果，只要调用<code>setResult()</code>来设置返回码和返回意图。当在你的activity的操作完成之后，要返回原来的activity，通过调用<code>finish()</code>来关闭（并销毁）你的activity，比如：
p1-7-3-3-2 = 你必须每次为返回的结果指定一个返回码。一般情况下，这个返回码为<code>RESULT_OK</code>或者<code>RESULT_CANCELED</code>。如果必要的话，你可以继续在你的意图对象中添加额外的数据。
nc1-7-3-3-1 = 注意：结果码默认被设置为了<code>RESULT_CANCELED</code>。所以，如果用户在完成操作之前按下了返回键，那么上一个activity将会得到"canceled"。
p1-7-3-3-3 = 如果你只需要返回一个整形来指示多个选项中的某一个，你可以将返回码设置成任意大于0的整数。如果你使用返回码来作为数据传递而不需要使用意图对象，那么你可以只向<code>setResult()</code>方法中传递一个返回码，比如：
p1-7-3-3-4 = 在这种情况下，只能有有限个可处理的返回值，这样返回码才可以指向某一个返回值的位置（大于0）。当你把返回值返回给你自己应用的activity时，这种方式十分管用，因为接收结果的activity可以通过定义构造函数的方法获得返回码。
nc1-7-3-3-2 = 注意：没有必要检查你的activity是通过<code>startActivity()</code>还是<code>startActivityForResult()</code>方法启动的。只需要调用<code>setResult()</code>方法，如果别的activity期望从你的activity获得返回值时，会自动从中获取返回的意图对象。