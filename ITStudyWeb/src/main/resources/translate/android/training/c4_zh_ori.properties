title4 = Building Apps with Graphics &amp; Animation
p4-1 = These classes teach you how to accomplish tasks with graphics that can give your app an edge on the competition. If you want to go beyond the basic user interface to create a beautiful visual experience, these classes will help you get there.
title4-1 = Displaying Bitmaps Efficiently
p4-1-1 = Learn how to use common techniques to process and load <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.html">Bitmap</a></code> objects in a way that keeps your user interface (UI) components responsive and avoids exceeding your application memory limit. If you're not careful, bitmaps can quickly consume your available memory budget leading to an application crash due to the dreaded exception:<br><code>java.lang.OutofMemoryError: bitmap size exceeds VM budget</code>.
p4-1-2 = There are a number of reasons why loading bitmaps in your Android application is tricky:
#ul
li4-1-1 = Mobile devices typically have constrained system resources. Android devices can have as little as 16MB of memory available to a single application. The <a href="http://developer.android.com/http://source.android.com/compatibility/downloads.html">Android Compatibility Definition Document</a> (CDD), <i>Section 3.7. Virtual Machine Compatibility</i> gives the required minimum application memory for various screen sizes and densities. Applications should be optimized to perform under this minimum memory limit. However, keep in mind many devices are configured with higher limits.
li4-1-2 = Bitmaps take up a lot of memory, especially for rich images like photographs. For example, the camera on the <a href="http://developer.android.com/http://www.android.com/devices/detail/galaxy-nexus">Galaxy Nexus</a> takes photos up to 2592x1936 pixels (5 megapixels). If the bitmap configuration used is <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.Config.html">ARGB_8888</a></code> (the default from the Android 2.3 onward) then loading this image into memory takes about 19MB of memory (2592*1936*4 bytes), immediately exhausting the per-app limit on some devices.
li4-1-3 = Android app UI’s frequently require several bitmaps to be loaded at once. Components such as <code><a href="http://developer.android.com//reference/android/widget/ListView.html">ListView</a></code>, <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> and <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> commonly include multiple bitmaps on-screen at once with many more potentially off-screen ready to show at the flick of a finger.
sub_title4-1-1 = Lessons
dt4-1-1-1 = <b><a href="http://developer.android.com/load-bitmap.html">Loading Large Bitmaps Efficiently</a></b>
dd4-1-1-1 = This lesson walks you through decoding large bitmaps without exceeding the per application memory limit.
dt4-1-1-2 = <b><a href="http://developer.android.com/process-bitmap.html">Processing Bitmaps Off the UI Thread</a></b>
dd4-1-1-2 = Bitmap processing (resizing, downloading from a remote source, etc.) should never take place on the main UI thread. This lesson walks you through processing bitmaps in a background thread using  <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> and explains how to handle concurrency issues.
dt4-1-1-3 = <b><a href="http://developer.android.com/cache-bitmap.html">Caching Bitmaps</a></b>
dd4-1-1-3 = This lesson walks you through using a memory and disk bitmap cache to improve the responsiveness and fluidity of your UI when loading multiple bitmaps.
dt4-1-1-4 = <b><a href="http://developer.android.com/manage-memory.html">Managing Bitmap Memory</a></b>
dd4-1-1-4 = This lesson explains how to manage bitmap memory to maximize your app's performance.
dt4-1-1-5 = <b><a href="http://developer.android.com/display-bitmap.html">Displaying Bitmaps in Your UI</a></b>
dd4-1-1-5 = This lesson brings everything together, showing you how to load multiple bitmaps into components like  <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> and  <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> using a background thread and bitmap cache.
title4-1-1 = Loading Large Bitmaps Efficiently
p4-1-1-1 = Images come in all shapes and sizes. In many cases they are larger than required for a typical application user interface (UI). For example, the system Gallery application displays photos taken using your Android devices's camera which are typically much higher resolution than the screen density of your device.
p4-1-1-2 = Given that you are working with limited memory, ideally you only want to load a lower resolution version in memory. The lower resolution version should match the size of the UI component that displays it. An image with a higher resolution does not provide any visible benefit, but still takes up precious memory and incurs additional performance overhead due to additional on the fly scaling.
p4-1-1-3 = This lesson walks you through decoding large bitmaps without exceeding the per application memory limit by loading a smaller subsampled version in memory.
sub_title4-1-1-1 = Read Bitmap Dimensions and Type
p4-1-1-1-1 = The <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.html">BitmapFactory</a></code> class provides several decoding methods (<code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.html#decodeByteArray(byte[], int, int, android.graphics.BitmapFactory.Options)">decodeByteArray()</a></code>, <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.html#decodeFile(java.lang.String, android.graphics.BitmapFactory.Options)">decodeFile()</a></code>, <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.html#decodeResource(android.content.res.Resources, int, android.graphics.BitmapFactory.Options)">decodeResource()</a></code>, etc.) for creating a <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.html">Bitmap</a></code> from various sources. Choose the most appropriate decode method based on your image data source. These methods attempt to allocate memory for the constructed bitmap and therefore can easily result in an <code>OutOfMemory</code> exception. Each type of decode method has additional signatures that let you specify decoding options via the <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html">BitmapFactory.Options</a></code> class. Setting the <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inJustDecodeBounds">inJustDecodeBounds</a></code> property to <code>true</code> while decoding avoids memory allocation, returning <code>null</code> for the bitmap object but setting <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#outWidth">outWidth</a></code>, <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#outHeight">outHeight</a></code> and <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#outMimeType">outMimeType</a></code>. This technique allows you to read the dimensions and type of the image data prior to construction (and memory allocation) of the bitmap.
#pre4-1-1-1-1
p4-1-1-1-2 = To avoid <code>java.lang.OutOfMemory</code> exceptions, check the dimensions of a bitmap before decoding it, unless you absolutely trust the source to provide you with predictably sized image data that comfortably fits within the available memory.
sub_title4-1-1-2 = Load a Scaled Down Version into Memory
p4-1-1-2-1 = Now that the image dimensions are known, they can be used to decide if the full image should be loaded into memory or if a subsampled version should be loaded instead. Here are some factors to consider:
#ul
li4-1-1-2-1 = Estimated memory usage of loading the full image in memory.
li4-1-1-2-2 = Amount of memory you are willing to commit to loading this image given any other memory requirements of your application.
li4-1-1-2-3 = Dimensions of the target <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> or UI component that the image is to be loaded into.
li4-1-1-2-4 = Screen size and density of the current device.
p4-1-1-2-2 = For example, it’s not worth loading a 1024x768 pixel image into memory if it will eventually be displayed in a 128x96 pixel thumbnail in an <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>.
p4-1-1-2-3 = To tell the decoder to subsample the image, loading a smaller version into memory, set <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inSampleSize">inSampleSize</a></code> to <code>true</code> in your <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html">BitmapFactory.Options</a></code> object. For example, an image with resolution 2048x1536 that is decoded with an <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inSampleSize">inSampleSize</a></code> of 4 produces a bitmap of approximately 512x384. Loading this into memory uses 0.75MB rather than 12MB for the full image (assuming a bitmap configuration of <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.Config.html">ARGB_8888</a></code>). Here’s a method to calculate a sample size value that is a power of two based on a target width and height:
#pre4-1-1-2-1
nc4-1-1-2-1 = <strong>Note:</strong> A power of two value is calculated because the decoder uses a final value by rounding down to the nearest power of two, as per the <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inSampleSize">inSampleSize</a></code> documentation.
p4-1-1-2-4 = To use this method, first decode with <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inJustDecodeBounds">inJustDecodeBounds</a></code> set to <code>true</code>, pass the options through and then decode again using the new <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inSampleSize">inSampleSize</a></code> value and <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inJustDecodeBounds">inJustDecodeBounds</a></code> set to <code>false</code>:
#pre4-1-1-2-2
p4-1-1-2-5 = This method makes it easy to load a bitmap of arbitrarily large size into an <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> that displays a 100x100 pixel thumbnail, as shown in the following example code:
#pre4-1-1-2-3
p4-1-1-2-6 = You can follow a similar process to decode bitmaps from other sources, by substituting the appropriate <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.html#decodeByteArray(byte[], int, int, android.graphics.BitmapFactory.Options)">BitmapFactory.decode*</a></code> method as needed.
title4-1-2 = Processing Bitmaps Off the UI Thread
p4-1-2-1 = The <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.html#decodeByteArray(byte[], int, int, android.graphics.BitmapFactory.Options)">BitmapFactory.decode*</a></code> methods, discussed in the <a href="http://developer.android.com/load-bitmap.html">Load Large Bitmaps Efficiently</a> lesson, should not be executed on the main UI thread if the source data is read from disk or a network location (or really any source other than memory). The time this data takes to load is unpredictable and depends on a variety of factors (speed of reading from disk or network, size of image, power of CPU, etc.). If one of these tasks blocks the UI thread, the system flags your application as non-responsive and the user has the option of closing it (see <a href="http://developer.android.com//guide/practices/responsiveness.html">Designing for Responsiveness</a> for more information).
p4-1-2-2 = This lesson walks you through processing bitmaps in a background thread using <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> and shows you how to handle concurrency issues.
sub_title4-1-2-1 = Use an AsyncTask
p4-1-2-1-1 = The <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> class provides an easy way to execute some work in a background thread and publish the results back on the UI thread. To use it, create a subclass and override the provided methods. Here’s an example of loading a large image into an <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> using <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> and <a href="http://developer.android.com/load-bitmap.html#decodeSampledBitmapFromResource"><code>decodeSampledBitmapFromResource()</code></a>:
#pre4-1-2-1-1
p4-1-2-1-2 = The <code><a href="http://developer.android.com//reference/java/lang/ref/WeakReference.html">WeakReference</a></code> to the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> ensures that the <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> does not prevent the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> and anything it references from being garbage collected. There’s no guarantee the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> is still around when the task finishes, so you must also check the reference in <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html#onPostExecute(Result)">onPostExecute()</a></code>. The <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> may no longer exist, if for example, the user navigates away from the activity or if a configuration change happens before the task finishes.
p4-1-2-1-3 = To start loading the bitmap asynchronously, simply create a new task and execute it:
#pre4-1-2-1-2
sub_title4-1-2-2 = Handle Concurrency
p4-1-2-2-1 = Common view components such as <code><a href="http://developer.android.com//reference/android/widget/ListView.html">ListView</a></code> and <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> introduce another issue when used in conjunction with the <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> as demonstrated in the previous section. In order to be efficient with memory, these components recycle child views as the user scrolls. If each child view triggers an <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code>, there is no guarantee that when it completes, the associated view has not already been recycled for use in another child view. Furthermore, there is no guarantee that the order in which asynchronous tasks are started is the order that they complete.
p4-1-2-2-2 = The blog post <a href="http://developer.android.com/http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html">Multithreading for Performance</a> further discusses dealing with concurrency, and offers a solution where the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> stores a reference to the most recent <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> which can later be checked when the task completes. Using a similar method, the <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> from the previous section can be extended to follow a similar pattern.
p4-1-2-2-3 = Create a dedicated <code><a href="http://developer.android.com//reference/android/graphics/drawable/Drawable.html">Drawable</a></code> subclass to store a reference back to the worker task. In this case, a <code><a href="http://developer.android.com//reference/android/graphics/drawable/BitmapDrawable.html">BitmapDrawable</a></code> is used so that a placeholder image can be displayed in the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> while the task completes:
#pre4-1-2-2-1
p4-1-2-2-4 = Before executing the <a href="http://developer.android.com/#BitmapWorkerTask"><code>BitmapWorkerTask</code></a>, you create an <a href="http://developer.android.com/#AsyncDrawable"><code>AsyncDrawable</code></a> and bind it to the target <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>:
#pre4-1-2-2-2
p4-1-2-2-5 = The <code>cancelPotentialWork</code> method referenced in the code sample above checks if another running task is already associated with the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>. If so, it attempts to cancel the previous task by calling <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html#cancel(boolean)">cancel()</a></code>. In a small number of cases, the new task data matches the existing task and nothing further needs to happen. Here is the implementation of <code>cancelPotentialWork</code>:
#pre4-1-2-2-3
p4-1-2-2-6 = A helper method, <code>getBitmapWorkerTask()</code>, is used above to retrieve the task associated with a particular <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>:
#pre4-1-2-2-4
p4-1-2-2-7 = The last step is updating <code>onPostExecute()</code> in <a href="http://developer.android.com/#BitmapWorkerTask"><code>BitmapWorkerTask</code></a> so that it checks if the task is cancelled and if the current task matches the one associated with the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>:
#pre4-1-2-2-5
p4-1-2-2-8 = This implementation is now suitable for use in <code><a href="http://developer.android.com//reference/android/widget/ListView.html">ListView</a></code> and <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> components as well as any other components that recycle their child views. Simply call <code>loadBitmap</code> where you normally set an image to your <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>. For example, in a <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> implementation this would be in the <code><a href="http://developer.android.com//reference/android/widget/Adapter.html#getView(int, android.view.View, android.view.ViewGroup)">getView()</a></code> method of the backing adapter.
title4-1-3 = Caching Bitmaps
p4-1-3-1 = Loading a single bitmap into your user interface (UI) is straightforward, however things get more complicated if you need to load a larger set of images at once. In many cases (such as with components like <code><a href="http://developer.android.com//reference/android/widget/ListView.html">ListView</a></code>, <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> or <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code>), the total number of images on-screen combined with images that might soon scroll onto the screen are essentially unlimited.
p4-1-3-2 = Memory usage is kept down with components like this by recycling the child views as they move off-screen. The garbage collector also frees up your loaded bitmaps, assuming you don't keep any long lived references. This is all good and well, but in order to keep a fluid and fast-loading UI you want to avoid continually processing these images each time they come back on-screen. A memory and disk cache can often help here, allowing components to quickly reload processed images.
p4-1-3-3 = This lesson walks you through using a memory and disk bitmap cache to improve the responsiveness and fluidity of your UI when loading multiple bitmaps.
sub_title4-1-3-1 = Use a Memory Cache
p4-1-3-1-1 = A memory cache offers fast access to bitmaps at the cost of taking up valuable application memory. The <code><a href="http://developer.android.com//reference/android/util/LruCache.html">LruCache</a></code> class (also available in the <a href="http://developer.android.com//reference/android/support/v4/util/LruCache.html">Support Library</a> for use back to API Level 4) is particularly well suited to the task of caching bitmaps, keeping recently referenced objects in a strong referenced <code><a href="http://developer.android.com//reference/java/util/LinkedHashMap.html">LinkedHashMap</a></code> and evicting the least recently used member before the cache exceeds its designated size.
nc4-1-3-1-1 = <strong>Note:</strong> In the past, a popular memory cache implementation was a <code><a href="http://developer.android.com//reference/java/lang/ref/SoftReference.html">SoftReference</a></code> or <code><a href="http://developer.android.com//reference/java/lang/ref/WeakReference.html">WeakReference</a></code> bitmap cache, however this is not recommended. Starting from Android 2.3 (API Level 9) the garbage collector is more aggressive with collecting soft/weak references which makes them fairly ineffective. In addition, prior to Android 3.0 (API Level 11), the backing data of a bitmap was stored in native memory which is not released in a predictable manner, potentially causing an application to briefly exceed its memory limits and crash.
p4-1-3-1-2 = In order to choose a suitable size for a <code><a href="http://developer.android.com//reference/android/util/LruCache.html">LruCache</a></code>, a number of factors should be taken into consideration, for example:
#ul
li4-1-3-1-1 = How memory intensive is the rest of your activity and/or application?
li4-1-3-1-2 = How many images will be on-screen at once? How many need to be available ready to come on-screen?
li4-1-3-1-3 = What is the screen size and density of the device? An extra high density screen (xhdpi) device like <a href="http://developer.android.com/http://www.android.com/devices/detail/galaxy-nexus">Galaxy Nexus</a> will need a larger cache to hold the same number of images in memory compared to a device like <a href="http://developer.android.com/http://www.android.com/devices/detail/nexus-s">Nexus S</a> (hdpi).
li4-1-3-1-4 = What dimensions and configuration are the bitmaps and therefore how much memory will each take up?
li4-1-3-1-5 = How frequently will the images be accessed? Will some be accessed more frequently than others? If so, perhaps you may want to keep certain items always in memory or even have multiple <code><a href="http://developer.android.com//reference/android/util/LruCache.html">LruCache</a></code> objects for different groups of bitmaps.
li4-1-3-1-6 = Can you balance quality against quantity? Sometimes it can be more useful to store a larger number of lower quality bitmaps, potentially loading a higher quality version in another background task.
p4-1-3-1-3 = There is no specific size or formula that suits all applications, it's up to you to analyze your usage and come up with a suitable solution. A cache that is too small causes additional overhead with no benefit, a cache that is too large can once again cause <code>java.lang.OutOfMemory</code> exceptions and leave the rest of your app little memory to work with.
p4-1-3-1-4 = Here’s an example of setting up a <code><a href="http://developer.android.com//reference/android/util/LruCache.html">LruCache</a></code> for bitmaps:
#pre4-1-3-1-1
nc4-1-3-1-2 = <strong>Note:</strong> In this example, one eighth of the application memory is allocated for our cache. On a normal/hdpi device this is a minimum of around 4MB (32/8). A full screen <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> filled with images on a device with 800x480 resolution would use around 1.5MB (800*480*4 bytes), so this would cache a minimum of around 2.5 pages of images in memory.
p4-1-3-1-5 = When loading a bitmap into an <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>, the <code><a href="http://developer.android.com//reference/android/util/LruCache.html">LruCache</a></code> is checked first. If an entry is found, it is used immediately to update the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>, otherwise a background thread is spawned to process the image:
#pre4-1-3-1-2
p4-1-3-1-6 = The <a href="http://developer.android.com/process-bitmap.html#BitmapWorkerTask"><code>BitmapWorkerTask</code></a> also needs to be updated to add entries to the memory cache:
#pre4-1-3-1-3
sub_title4-1-3-2 = Use a Disk Cache
p4-1-3-2-1 = A memory cache is useful in speeding up access to recently viewed bitmaps, however you cannot rely on images being available in this cache. Components like <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> with larger datasets can easily fill up a memory cache. Your application could be interrupted by another task like a phone call, and while in the background it might be killed and the memory cache destroyed. Once the user resumes, your application has to process each image again.
p4-1-3-2-2 = A disk cache can be used in these cases to persist processed bitmaps and help decrease loading times where images are no longer available in a memory cache. Of course, fetching images from disk is slower than loading from memory and should be done in a background thread, as disk read times can be unpredictable.
nc4-1-3-2-1 = <strong>Note:</strong> A <code><a href="http://developer.android.com//reference/android/content/ContentProvider.html">ContentProvider</a></code> might be a more appropriate place to store cached images if they are accessed more frequently, for example in an image gallery application.
p4-1-3-2-3 = The sample code of this class uses a <code>DiskLruCache</code> implementation that is pulled from the <a href="http://developer.android.com/https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/DiskLruCache.java">Android source</a>. Here’s updated example code that adds a disk cache in addition to the existing memory cache:
#pre4-1-3-2-1
nc4-1-3-2-2 = <strong>Note:</strong> Even initializing the disk cache requires disk operations and therefore should not take place on the main thread. However, this does mean there's a chance the cache is accessed before initialization. To address this, in the above implementation, a lock object ensures that the app does not read from the disk cache until the cache has been initialized.
p4-1-3-2-4 = While the memory cache is checked in the UI thread, the disk cache is checked in the background thread. Disk operations should never take place on the UI thread. When image processing is complete, the final bitmap is added to both the memory and disk cache for future use.
sub_title4-1-3-3 = Handle Configuration Changes
p4-1-3-3-1 = Runtime configuration changes, such as a screen orientation change, cause Android to destroy and restart the running activity with the new configuration (For more information about this behavior, see <a href="http://developer.android.com//guide/topics/resources/runtime-changes.html">Handling Runtime Changes</a>). You want to avoid having to process all your images again so the user has a smooth and fast experience when a configuration change occurs.
p4-1-3-3-2 = Luckily, you have a nice memory cache of bitmaps that you built in the <a href="http://developer.android.com/#memory-cache">Use a Memory Cache</a> section. This cache can be passed through to the new activity instance using a <code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragment</a></code> which is preserved by calling <code><a href="http://developer.android.com//reference/android/app/Fragment.html#setRetainInstance(boolean)">setRetainInstance(true)</a></code>). After the activity has been recreated, this retained <code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragment</a></code> is reattached and you gain access to the existing cache object, allowing images to be quickly fetched and re-populated into the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> objects.
p4-1-3-3-3 = Here’s an example of retaining a <code><a href="http://developer.android.com//reference/android/util/LruCache.html">LruCache</a></code> object across configuration changes using a <code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragment</a></code>:
#pre4-1-3-3-1
p4-1-3-3-4 = To test this out, try rotating a device both with and without retaining the <code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragment</a></code>. You should notice little to no lag as the images populate the activity almost instantly from memory when you retain the cache. Any images not found in the memory cache are hopefully available in the disk cache, if not, they are processed as usual.
title4-1-4 = Managing Bitmap Memory
p4-1-4-1 = In addition to the steps described in <a href="http://developer.android.com/cache-bitmap.html">Caching Bitmaps</a>, there are specific things you can do to facilitate garbage collection and bitmap reuse. The recommended strategy depends on which version(s) of Android you are targeting. The <code>BitmapFun</code> sample app included with this class shows you how to design your app to work efficiently across different versions of Android.
p4-1-4-2 = To set the stage for this lesson, here is how Android's management of bitmap memory has evolved:
#ul
li4-1-4-1 = On Android Android 2.2 (API level 8) and lower, when garbage collection occurs, your app's threads get stopped. This causes a lag that can degrade performance. <strong>Android 2.3 adds concurrent garbage collection, which means that the memory is reclaimed soon after a bitmap is no longer referenced.</strong>
li4-1-4-2 = On Android 2.3.3 (API level 10) and lower, the backing pixel data for a bitmap is stored in native memory. It is separate from the bitmap itself, which is stored in the Dalvik heap. The pixel data in native memory is not released in a predictable manner, potentially causing an application to briefly exceed its memory limits and crash. <strong>As of Android 3.0 (API level 11), the pixel data is stored on the Dalvik heap along with the associated bitmap.</strong>
p4-1-4-3 = The following sections describe how to optimize bitmap memory management for different Android versions.
sub_title4-1-4-1 = Manage Memory on Android 2.3.3 and Lower
p4-1-4-1-1 = On Android 2.3.3 (API level 10) and lower, using <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.html#recycle()">recycle()</a></code> is recommended. If you're displaying large amounts of bitmap data in your app, you're likely to run into <code><a href="http://developer.android.com//reference/java/lang/OutOfMemoryError.html">OutOfMemoryError</a></code> errors. The <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.html#recycle()">recycle()</a></code> method allows an app to reclaim memory as soon as possible.
cc4-1-4-1-1 = <strong>Caution:</strong> You should use <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.html#recycle()">recycle()</a></code> only when you are sure that the bitmap is no longer being used. If you call <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.html#recycle()">recycle()</a></code> and later attempt to draw the bitmap, you will get the error: <code>"Canvas: trying to use a recycled bitmap"</code>.
p4-1-4-1-2 = The following code snippet gives an example of calling <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.html#recycle()">recycle()</a></code>. It uses reference counting (in the variables <code>mDisplayRefCount</code> and <code>mCacheRefCount</code>) to track whether a bitmap is currently being displayed or in the cache. The code recycles the bitmap when these conditions are met:
#ul
li4-1-4-1-1 = The reference count for both <code>mDisplayRefCount</code> and <code>mCacheRefCount</code> is 0.
li4-1-4-1-2 = The bitmap is not <code>null</code>, and it hasn't been recycled yet.
#pre4-1-4-1-1
sub_title4-1-4-2 = Manage Memory on Android 3.0 and Higher
p4-1-4-2-1 = Android 3.0 (API level 11) introduces the <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inBitmap">BitmapFactory.Options.inBitmap</a></code> field. If this option is set, decode methods that take the <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html">Options</a></code> object will attempt to reuse an existing bitmap when loading content. This means that the bitmap's memory is reused, resulting in improved performance, and removing both memory allocation and de-allocation. However, there are certain restrictions with how <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inBitmap">inBitmap</a></code> can be used. In particular, before Android 4.4 (API level 19), only equal sized bitmaps are supported. For details, please see the <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inBitmap">inBitmap</a></code> documentation.
lead4-1-4-2-1 = Save a bitmap for later use
p4-1-4-2-2 = The following snippet demonstrates how an existing bitmap is stored for possible later use in the sample app. When an app is running on Android 3.0 or higher and a bitmap is evicted from the <code><a href="http://developer.android.com//reference/android/util/LruCache.html">LruCache</a></code>, a soft reference to the bitmap is placed in a <code><a href="http://developer.android.com//reference/java/util/HashSet.html">HashSet</a></code>, for possible reuse later with <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inBitmap">inBitmap</a></code>:
#pre4-1-4-2-1
lead4-1-4-2-2 = Use an existing bitmap
p4-1-4-2-3 = In the running app, decoder methods check to see if there is an existing bitmap they can use. For example:
#pre4-1-4-2-2
#pre4-1-4-2-3
p4-1-4-2-4 = Finally, this method determines whether a candidate bitmap satisfies the size criteria to be used for <code><a href="http://developer.android.com//reference/android/graphics/BitmapFactory.Options.html#inBitmap">inBitmap</a></code>:
#pre4-1-4-2-4
title4-1-5 = Displaying Bitmaps in Your UI
p4-1-5-1 = This lesson brings together everything from previous lessons, showing you how to load multiple bitmaps into <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> and <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> components using a background thread and bitmap cache, while dealing with concurrency and configuration changes.
sub_title4-1-5-1 = Load Bitmaps into a ViewPager Implementation
p4-1-5-1-1 = The <a href="http://developer.android.com//design/patterns/swipe-views.html">swipe view pattern</a> is an excellent way to navigate the detail view of an image gallery. You can implement this pattern using a <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> component backed by a <code><a href="http://developer.android.com//reference/android/support/v4/view/PagerAdapter.html">PagerAdapter</a></code>. However, a more suitable backing adapter is the subclass <code><a href="http://developer.android.com//reference/android/support/v4/app/FragmentStatePagerAdapter.html">FragmentStatePagerAdapter</a></code> which automatically destroys and saves state of the <code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragments</a></code> in the <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> as they disappear off-screen, keeping memory usage down.
nc4-1-5-1-1 = <strong>Note:</strong> If you have a smaller number of images and are confident they all fit within the application memory limit, then using a regular <code><a href="http://developer.android.com//reference/android/support/v4/view/PagerAdapter.html">PagerAdapter</a></code> or <code><a href="http://developer.android.com//reference/android/support/v4/app/FragmentPagerAdapter.html">FragmentPagerAdapter</a></code> might be more appropriate.
p4-1-5-1-2 = Here’s an implementation of a <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> with <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> children. The main activity holds the <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> and the adapter:
#pre4-1-5-1-1
p4-1-5-1-3 = Here is an implementation of the details <code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragment</a></code> which holds the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> children. This might seem like a perfectly reasonable approach, but can you see the drawbacks of this implementation? How could it be improved?
#pre4-1-5-1-2
p4-1-5-1-4 = Hopefully you noticed the issue: the images are being read from resources on the UI thread, which can lead to an application hanging and being force closed. Using an <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> as described in the <a href="http://developer.android.com/process-bitmap.html">Processing Bitmaps Off the UI Thread</a> lesson, it’s straightforward to move image loading and processing to a background thread:
#pre4-1-5-1-3
p4-1-5-1-5 = Any additional processing (such as resizing or fetching images from the network) can take place in the <a href="http://developer.android.com/process-bitmap.html#BitmapWorkerTask"><code>BitmapWorkerTask</code></a> without affecting responsiveness of the main UI. If the background thread is doing more than just loading an image directly from disk, it can also be beneficial to add a memory and/or disk cache as described in the lesson <a href="http://developer.android.com/cache-bitmap.html#memory-cache">Caching Bitmaps</a>. Here's the additional modifications for a memory cache:
#pre4-1-5-1-4
p4-1-5-1-6 = Putting all these pieces together gives you a responsive <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> implementation with minimal image loading latency and the ability to do as much or as little background processing on your images as needed.
sub_title4-1-5-2 = Load Bitmaps into a GridView Implementation
p4-1-5-2-1 = The <a href="http://developer.android.com//design/building-blocks/grid-lists.html">grid list building block</a> is useful for showing image data sets and can be implemented using a <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> component in which many images can be on-screen at any one time and many more need to be ready to appear if the user scrolls up or down. When implementing this type of control, you must ensure the UI remains fluid, memory usage remains under control and concurrency is handled correctly (due to the way <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> recycles its children views).
p4-1-5-2-2 = To start with, here is a standard <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> implementation with <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> children placed inside a <code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragment</a></code>. Again, this might seem like a perfectly reasonable approach, but what would make it better?
#pre4-1-5-2-1
p4-1-5-2-3 = Once again, the problem with this implementation is that the image is being set in the UI thread. While this may work for small, simple images (due to system resource loading and caching), if any additional processing needs to be done, your UI grinds to a halt.
p4-1-5-2-4 = The same asynchronous processing and caching methods from the previous section can be implemented here. However, you also need to wary of concurrency issues as the <code><a href="http://developer.android.com//reference/android/widget/GridView.html">GridView</a></code> recycles its children views. To handle this, use the techniques discussed in the <a href="http://developer.android.com/process-bitmap.html#concurrency">Processing Bitmaps Off the UI Thread</a> lesson. Here is the updated solution:
#pre4-1-5-2-2
nc4-1-5-2-1 = <strong>Note:</strong> The same code can easily be adapted to work with <code><a href="http://developer.android.com//reference/android/widget/ListView.html">ListView</a></code> as well.
p4-1-5-2-5 = This implementation allows for flexibility in how the images are processed and loaded without impeding the smoothness of the UI. In the background task you can load images from the network or resize large digital camera photos and the images appear as the tasks finish processing.
p4-1-5-2-6 = For a full example of this and other concepts discussed in this lesson, please see the included sample application.
title4-2 = Displaying Graphics with OpenGL ES
p4-2-1 = The Android framework provides plenty of standard tools for creating attractive, functional graphical user interfaces. However, if you want more control of what your application draws on screen, or are venturing into three dimensional graphics, you need to use a different tool. The OpenGL ES APIs provided by the Android framework offers a set of tools for displaying high-end, animated graphics that are limited only by your imagination and can also benefit from the acceleration of graphics processing units (GPUs) provided on many Android devices.
p4-2-2 = This class walks you through the basics of developing applications that use OpenGL, including setup, drawing objects, moving drawn elements and responding to touch input.
p4-2-3 = The example code in this class uses the OpenGL ES 2.0 APIs, which is the recommended API version to use with current Android devices. For more information about versions of OpenGL ES, see the <a href="http://developer.android.com//guide/topics/graphics/opengl.html#choosing-version">OpenGL</a> developer guide.
nc4-2-1 = <strong>Note:</strong> Be careful not to mix OpenGL ES 1.x API calls with OpenGL ES 2.0 methods! The two APIs are not interchangeable and trying to use them together only results in frustration and sadness.
sub_title4-2-1 = Lessons
dt4-2-1-1 = <b><a href="http://developer.android.com/environment.html">Building an OpenGL ES Environment</a></b>
dd4-2-1-1 = Learn how to set up an Android application to be able to draw OpenGL graphics.
dt4-2-1-2 = <b><a href="http://developer.android.com/shapes.html">Defining Shapes</a></b>
dd4-2-1-2 = Learn how to define shapes and why you need to know about faces and winding.
dt4-2-1-3 = <b><a href="http://developer.android.com/draw.html">Drawing Shapes</a></b>
dd4-2-1-3 = Learn how to draw OpenGL shapes in your application.
dt4-2-1-4 = <b><a href="http://developer.android.com/projection.html">Applying Projection and Camera Views</a></b>
dd4-2-1-4 = Learn how to use projection and camera views to get a new perspective on your drawn objects.
dt4-2-1-5 = <b><a href="http://developer.android.com/motion.html">Adding Motion</a></b>
dd4-2-1-5 = Learn how to do basic movement and animation of drawn objects with OpenGL.
dt4-2-1-6 = <b><a href="http://developer.android.com/touch.html">Responding to Touch Events</a></b>
dd4-2-1-6 = Learn how to do basic interaction with OpenGL graphics.
title4-2-1 = Building an OpenGL ES Environment
p4-2-1-1 = In order to draw graphics with OpenGL ES in your Android application, you must create a view container for them. One of the more straight-forward ways to do this is to implement both a <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and a <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>. A <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> is a view container for graphics drawn with OpenGL and <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> controls what is drawn within that view. For more information about these classes, see the <a href="http://developer.android.com//guide/topics/graphics/opengl.html">OpenGL ES</a> developer guide.
p4-2-1-2 = <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> is just one way to incorporate OpenGL ES graphics into your application. For a full-screen or near-full screen graphics view, it is a reasonable choice. Developers who want to incorporate OpenGL ES graphics in a small portion of their layouts should take a look at <code><a href="http://developer.android.com//reference/android/view/TextureView.html">TextureView</a></code>. For real, do-it-yourself developers, it is also possible to build up an OpenGL ES view using <code><a href="http://developer.android.com//reference/android/view/SurfaceView.html">SurfaceView</a></code>, but this requires writing quite a bit of additional code.
p4-2-1-3 = This lesson explains how to complete a minimal implementation of <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> in a simple application activity.
sub_title4-2-1-1 = Declare OpenGL ES Use in the Manifest
p4-2-1-1-1 = In order for your application to use the OpenGL ES 2.0 API, you must add the following declaration to your manifest:
#pre4-2-1-1-1
p4-2-1-1-2 = If your application uses texture compression, you must also declare which compression formats your app supports, so that it is only installed on compatible devices.
#pre4-2-1-1-2
p4-2-1-1-3 = For more information about texture compression formats, see the <a href="http://developer.android.com//guide/topics/graphics/opengl.html#textures">OpenGL</a> developer guide.
sub_title4-2-1-2 = Create an Activity for OpenGL ES Graphics
p4-2-1-2-1 = Android applications that use OpenGL ES have activities just like any other application that has a user interface. The main difference from other applications is what you put in the layout for your activity. While in many applications you might use <code><a href="http://developer.android.com//reference/android/widget/TextView.html">TextView</a></code>, <code><a href="http://developer.android.com//reference/android/widget/Button.html">Button</a></code> and <code><a href="http://developer.android.com//reference/android/widget/ListView.html">ListView</a></code>, in an app that uses OpenGL ES, you can also add a <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>.
p4-2-1-2-2 = The following code example shows a minimal implementation of an activity that uses a <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> as its primary view:
#pre4-2-1-2-1
nc4-2-1-2-1 = <strong>Note:</strong> OpenGL ES 2.0 requires Android 2.2 (API Level 8) or higher, so make sure your Android project targets that API or higher.
sub_title4-2-1-3 = Build a GLSurfaceView Object
p4-2-1-3-1 = A <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> is a specialized view where you can draw OpenGL ES graphics. It does not do much by itself. The actual drawing of objects is controlled in the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> that you set on this view. In fact, the code for this object is so thin, you may be tempted to skip extending it and just create an unmodified <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> instance, but don’t do that. You need to extend this class in order to capture touch events, which is covered in the <a href="http://developer.android.com/#touch.html">Responding to Touch Events</a> lesson.
p4-2-1-3-2 = The essential code for a <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> is minimal, so for a quick implementation, it is common to just create an inner class in the activity that uses it:
#pre4-2-1-3-1
p4-2-1-3-3 = When using OpenGL ES 2.0, you must add another call to your <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> constructor, specifying that you want to use the 2.0 API:
#pre4-2-1-3-2
nc4-2-1-3-1 = <strong>Note:</strong> If you are using the OpenGL ES 2.0 API, make sure you declare this in your application manifest. For more information, see <a href="http://developer.android.com/#manifest">Declare OpenGL ES Use in the Manifest</a>.
p4-2-1-3-4 = One other optional addition to your <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> implementation is to set the render mode to only draw the view when there is a change to your drawing data using the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY">GLSurfaceView.RENDERMODE_WHEN_DIRTY</a></code> setting:
#pre4-2-1-3-3
p4-2-1-3-5 = This setting prevents the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> frame from being redrawn until you call <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html#requestRender()">requestRender()</a></code>, which is more efficient for this sample app.
sub_title4-2-1-4 = Build a Renderer Class
p4-2-1-4-1 = The implementation of the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> class, or renderer, within an application that uses OpenGL ES is where things start to get interesting. This class controls what gets drawn on the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> with which it is associated. There are three methods in a renderer that are called by the Android system in order to figure out what and how to draw on a <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>:
#ul
li4-2-1-4-1 = <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)">onSurfaceCreated()</a></code> - Called once to set up the view's OpenGL ES environment.
li4-2-1-4-2 = <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code> - Called for each redraw of the view.
li4-2-1-4-3 = <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code> - Called if the geometry of the view changes, for example when the device's screen orientation changes.
p4-2-1-4-2 = Here is a very basic implementation of an OpenGL ES renderer, that does nothing more than draw a gray background in the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>:
#pre4-2-1-4-1
p4-2-1-4-3 = That’s all there is to it! The code examples above create a simple Android application that displays a gray screen using OpenGL. While this code does not do anything very interesting, by creating these classes, you have laid the foundation you need to start drawing graphic elements with OpenGL.
nc4-2-1-4-1 = <strong>Note:</strong> You may wonder why these methods have a <code><a href="http://developer.android.com//reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code> parameter, when you are using the OpengGL ES 2.0 APIs. These method signatures are simply reused for the 2.0 APIs to keep the Android framework code simpler.
p4-2-1-4-4 = If you are familiar with the OpenGL ES APIs, you should now be able to set up a OpenGL ES environment in your app and start drawing graphics. However, if you need a bit more help getting started with OpenGL, head on to the next lessons for a few more hints.
title4-2-2 = Defining Shapes
p4-2-2-1 = Being able to define shapes to be drawn in the context of an OpenGL ES view is the first step in creating your high-end graphics masterpiece. Drawing with OpenGL ES can be a little tricky without knowing a few basic things about how OpenGL ES expects you to define graphic objects.
p4-2-2-2 = This lesson explains the OpenGL ES coordinate system relative to an Android device screen, the basics of defining a shape, shape faces, as well as defining a triangle and a square.
sub_title4-2-2-1 = Define a Triangle
p4-2-2-1-1 = OpenGL ES allows you to define drawn objects using coordinates in three-dimensional space. So, before you can draw a triangle, you must define its coordinates. In OpenGL, the typical way to do this is to define a vertex array of floating point numbers for the coordinates. For maximum efficiency, you write these coordinates into a <code><a href="http://developer.android.com//reference/java/nio/ByteBuffer.html">ByteBuffer</a></code>, that is passed into the OpenGL ES graphics pipeline for processing.
#pre4-2-2-1-1
p4-2-2-1-2 = By default, OpenGL ES assumes a coordinate system where [0,0,0] (X,Y,Z) specifies the center of the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> frame, [1,1,0] is the top right corner of the frame and [-1,-1,0] is bottom left corner of the frame. For an illustration of this coordinate system, see the <a href="http://developer.android.com//guide/topics/graphics/opengl.html#coordinate-mapping">OpenGL ES</a> developer guide.
p4-2-2-1-3 = Note that the coordinates of this shape are defined in a counterclockwise order. The drawing order is important because it defines which side is the front face of the shape, which you typically want to have drawn, and the back face, which you can choose to not draw using the OpenGL ES cull face feature. For more information about faces and culling, see the <a href="http://developer.android.com//guide/topics/graphics/opengl.html#faces-winding">OpenGL ES</a> developer guide.
sub_title4-2-2-2 = Define a Square
p4-2-2-2-1 = Defining triangles is pretty easy in OpenGL, but what if you want to get a just a little more complex? Say, a square? There are a number of ways to do this, but a typical path to drawing such a shape in OpenGL ES is to use two triangles drawn together:
#ccw-square.png
p4-2-2-2-2 = Again, you should define the vertices in a counterclockwise order for both triangles that represent this shape, and put the values in a <code><a href="http://developer.android.com//reference/java/nio/ByteBuffer.html">ByteBuffer</a></code>. In order to avoid defining the two coordinates shared by each triangle twice, use a drawing list to tell the OpenGL ES graphics pipeline how to draw these vertices. Here’s the code for this shape:
#pre4-2-2-2-1
p4-2-2-2-3 = This example gives you a peek at what it takes to create more complex shapes with OpenGL. In general, you use collections of triangles to draw objects. In the next lesson, you learn how to draw these shapes on screen.
title4-2-3 = Drawing Shapes
p4-2-3-1 = After you define shapes to be drawn with OpenGL, you probably want to draw them. Drawing shapes with the OpenGL ES 2.0 takes a bit more code than you might imagine, because the API provides a great deal of control over the graphics rendering pipeline.
p4-2-3-2 = This lesson explains how to draw the shapes you defined in the previous lesson using the OpenGL ES 2.0 API.
sub_title4-2-3-1 = Initialize Shapes
p4-2-3-1-1 = Before you do any drawing, you must initialize and load the shapes you plan to draw. Unless the structure (the original coordinates) of the shapes you use in your program change during the course of execution, you should initialize them in the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)">onSurfaceCreated()</a></code> method of your renderer for memory and processing efficiency.
#pre4-2-3-1-1
sub_title4-2-3-2 = Draw a Shape
p4-2-3-2-1 = Drawing a defined shape using OpenGL ES 2.0 requires a significant amount of code, because you must provide a lot of details to the graphics rendering pipeline. Specifically, you must define the following:
#ul
li4-2-3-2-1 = <em>Vertex Shader</em> - OpenGL ES graphics code for rendering the vertices of a shape.
li4-2-3-2-2 = <em>Fragment Shader</em> - OpenGL ES code for rendering the face of a shape with colors or textures.
li4-2-3-2-3 = <em>Program</em> - An OpenGL ES object that contains the shaders you want to use for drawing one or more shapes.
p4-2-3-2-2 = You need at least one vertex shader to draw a shape and one fragment shader to color that shape. These shaders must be complied and then added to an OpenGL ES program, which is then used to draw the shape. Here is an example of how to define basic shaders you can use to draw a shape:
#pre4-2-3-2-1
p4-2-3-2-3 = Shaders contain OpenGL Shading Language (GLSL) code that must be compiled prior to using it in the OpenGL ES environment. To compile this code, create a utility method in your renderer class:
#pre4-2-3-2-2
p4-2-3-2-4 = In order to draw your shape, you must compile the shader code, add them to a OpenGL ES program object and then link the program. Do this in your drawn object’s constructor, so it is only done once.
nc4-2-3-2-1 = <strong>Note:</strong> Compiling OpenGL ES shaders and linking programs is expensive in terms of CPU cycles and processing time, so you should avoid doing this more than once. If you do not know the content of your shaders at runtime, you should build your code such that they only get created once and then cached for later use.
#pre4-2-3-2-3
p4-2-3-2-5 = At this point, you are ready to add the actual calls that draw your shape. Drawing shapes with OpenGL ES requires that you specify several parameters to tell the rendering pipeline what you want to draw and how to draw it. Since drawing options can vary by shape, it's a good idea to have your shape classes contain their own drawing logic.
p4-2-3-2-6 = Create a <code>draw()</code> method for drawing the shape. This code sets the position and color values to the shape’s vertex shader and fragment shader, and then executes the drawing function.
#pre4-2-3-2-4
p4-2-3-2-7 = Once you have all this code in place, drawing this object just requires a call to the <code>draw()</code> method from within your renderer’s <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code> method. When you run the application, it should look something like this:
#ogl-triangle.png
p4-2-3-2-8 = There are a few problems with this code example. First of all, it is not going to impress your friends. Secondly, the triangle is a bit squashed and changes shape when you change the screen orientation of the device. The reason the shape is skewed is due to the fact that the object’s vertices have not been corrected for the proportions of the screen area where the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> is displayed. You can fix that problem using a projection and camera view in the next lesson.
p4-2-3-2-9 = Lastly, the triangle is stationary, which is a bit boring. In the <a href="http://developer.android.com/motion.html">Adding Motion</a> lesson, you make this shape rotate and make more interesting use of the OpenGL ES graphics pipeline.
title4-2-4 = Applying Projection and Camera Views
p4-2-4-1 = In the OpenGL ES environment, projection and camera views allow you to display drawn objects in a way that more closely resembles how you see physical objects with your eyes. This simulation of physical viewing is done with mathematical transformations of drawn object coordinates:
#ul
li4-2-4-1 = <em>Projection</em> - This transformation adjusts the coordinates of drawn objects based on the width and height of the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> where they are displayed. Without this calculation, objects drawn by OpenGL ES are skewed by the unequal proportions of the view window. A projection transformation typically only has to be calculated when the proportions of the OpenGL view are established or changed in the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code> method of your renderer. For more information about OpenGL ES projections and coordinate mapping, see <a href="http://developer.android.com//guide/topics/graphics/opengl.html#coordinate-mapping">Mapping Coordinates for Drawn Objects</a>.
li4-2-4-2 = <em>Camera View</em> - This transformation adjusts the coordinates of drawn objects based on a virtual camera position. It’s important to note that OpenGL ES does not define an actual camera object, but instead provides utility methods that simulate a camera by transforming the display of drawn objects. A camera view transformation might be calculated only once when you establish your <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>, or might change dynamically based on user actions or your application’s function.
p4-2-4-2 = This lesson describes how to create a projection and camera view and apply it to shapes drawn in your <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>.
sub_title4-2-4-1 = Define a Projection
p4-2-4-1-1 = The data for a projection transformation is calculated in the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code> method of your <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> class. The following example code takes the height and width of the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and uses it to populate a projection transformation <code><a href="http://developer.android.com//reference/android/opengl/Matrix.html">Matrix</a></code> using the <code><a href="http://developer.android.com//reference/android/opengl/Matrix.html#frustumM(float[], int, float, float, float, float, float, float)">Matrix.frustumM()</a></code> method:
#pre4-2-4-1-1
p4-2-4-1-2 = This code populates a projection matrix, <code>mProjectionMatrix</code> which you can then combine with a camera view transformation in the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code> method, which is shown in the next section.
nc4-2-4-1-1 = <strong>Note:</strong> Just applying a projection transformation to your drawing objects typically results in a very empty display. In general, you must also apply a camera view transformation in order for anything to show up on screen.
sub_title4-2-4-2 = Define a Camera View
p4-2-4-2-1 = Complete the process of transforming your drawn objects by adding a camera view transformation as part of the drawing process. In the following example code, the camera view transformation is calculated using the <code><a href="http://developer.android.com//reference/android/opengl/Matrix.html#setLookAtM(float[], int, float, float, float, float, float, float, float, float, float)">Matrix.setLookAtM()</a></code> method and then combined with the previously calculated projection matrix. The combined transformation matrices are then passed to the drawn shape.
#pre4-2-4-2-1
sub_title4-2-4-3 = Apply Projection and Camera Transformations
p4-2-4-3-1 = In order to use the combined projection and camera view transformation matrix shown in the previews sections, modify the <code>draw()</code> method of your graphic objects to accept the combined transformation matrix and apply it to the shape:
#pre4-2-4-3-1
p4-2-4-3-2 = Once you have correctly calculated and applied the projection and camera view transformations, your graphic objects are drawn in correct proportions and should look like this:
#ogl-triangle-projected.png
p4-2-4-3-3 = Now that you have an application that displays your shapes in correct proportions, it's time to add motion to your shapes.
title4-2-5 = Adding Motion
p4-2-5-1 = Drawing objects on screen is a pretty basic feature of OpenGL, but you can do this with other Android graphics framwork classes, including <code><a href="http://developer.android.com//reference/android/graphics/Canvas.html">Canvas</a></code> and <code><a href="http://developer.android.com//reference/android/graphics/drawable/Drawable.html">Drawable</a></code> objects. OpenGL ES provides additional capabilities for moving and transforming drawn objects in three dimensions or in other unique ways to create compelling user experiences.
p4-2-5-2 = In this lesson, you take another step forward into using OpenGL ES by learning how to add motion to a shape with rotation.
sub_title4-2-5-1 = Rotate a Shape
p4-2-5-1-1 = Rotating a drawing object with OpenGL ES 2.0 is relatively simple. You create another transformation matrix (a rotation matrix) and then combine it with your projection and camera view transformation matrices:
#pre4-2-5-1-1
p4-2-5-1-2 = If your triangle does not rotate after making these changes, make sure you have commented out the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY">GLSurfaceView.RENDERMODE_WHEN_DIRTY</a></code> setting, as described in the next section.
sub_title4-2-5-2 = Enable Continuous Rendering
p4-2-5-2-1 = If you have diligently followed along with the example code in this class to this point, make sure you comment out the line that sets the render mode only draw when dirty, otherwise OpenGL rotates the shape only one increment and then waits for a call to <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html#requestRender()">requestRender()</a></code> from the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> container:
#pre4-2-5-2-1
p4-2-5-2-2 = Unless you have objects changing without any user interaction, it’s usually a good idea have this flag turned on. Be ready to uncomment this code, because the next lesson makes this call applicable once again.
title4-2-6 = Responding to Touch Events
p4-2-6-1 = Making objects move according to a preset program like the rotating triangle is useful for getting some attention, but what if you want to have users interact with your OpenGL ES graphics? The key to making your OpenGL ES application touch interactive is expanding your implementation of <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> to override the <code><a href="http://developer.android.com//reference/android/view/View.html#onTouchEvent(android.view.MotionEvent)">onTouchEvent()</a></code> to listen for touch events.
p4-2-6-2 = This lesson shows you how to listen for touch events to let users rotate an OpenGL ES object.
sub_title4-2-6-1 = Setup a Touch Listener
p4-2-6-1-1 = In order to make your OpenGL ES application respond to touch events, you must implement the <code><a href="http://developer.android.com//reference/android/view/View.html#onTouchEvent(android.view.MotionEvent)">onTouchEvent()</a></code> method in your <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> class. The example implementation below shows how to listen for <code><a href="http://developer.android.com//reference/android/view/MotionEvent.html#ACTION_MOVE">MotionEvent.ACTION_MOVE</a></code> events and translate them to an angle of rotation for a shape.
#pre4-2-6-1-1
p4-2-6-1-2 = Notice that after calculating the rotation angle, this method calls <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html#requestRender()">requestRender()</a></code> to tell the renderer that it is time to render the frame. This approach is the most efficient in this example because the frame does not need to be redrawn unless there is a change in the rotation. However, it does not have any impact on efficiency unless you also request that the renderer only redraw when the data changes using the <code><a href="http://developer.android.com//reference/android/opengl/GLSurfaceView.html#setRenderMode(int)">setRenderMode()</a></code> method, so make sure this line is uncommented in the renderer:
#pre4-2-6-1-2
sub_title4-2-6-2 = Expose the Rotation Angle
p4-2-6-2-1 = The example code above requires that you expose the rotation angle through your renderer by adding a public member. Since the renderer code is running on a separate thread from the main user interface thread of your application, you must declare this public variable as <code>volatile</code>. Here is the code to do that:
#pre4-2-6-2-1
sub_title4-2-6-3 = Apply Rotation
p4-2-6-3-1 = To apply the rotation generated by touch input, comment out the code that generates an angle and add <code>mAngle</code>, which contains the touch input generated angle:
#pre4-2-6-3-1
p4-2-6-3-2 = When you have completed the steps described above, run the program and drag your finger over the screen to rotate the triangle:
#ogl-triangle-touch.png
title4-3 = Adding Animations
p4-3-1 = Animations can add subtle visual cues that notify users about what's going on in your app and improve their mental model of your app's interface. Animations are especially useful when the screen changes state, such as when content loads or new actions become available. Animations can also add a polished look to your app, which gives your app a higher quality feel.
p4-3-2 = Keep in mind though, that overusing animations or using them at the wrong time can be detrimental, such as when they cause delays. This training class shows you how to implement some common types of animations that can increase usability and add flair without annoying your users.
sub_title4-3-1 = Lessons
dt4-3-1-1 = <b><a href="http://developer.android.com/crossfade.html">Crossfading Two Views</a></b>
dd4-3-1-1 = Learn how to crossfade between two overlapping views. This lesson shows you how to crossfade a progress indicator to a view that contains text content.
dt4-3-1-2 = <b><a href="http://developer.android.com/screen-slide.html">Using ViewPager for Screen Slides</a></b>
dd4-3-1-2 = Learn how to animate between horizontally adjacent screens with a sliding transition.
dt4-3-1-3 = <b><a href="http://developer.android.com/cardflip.html">Displaying Card Flip Animations</a></b>
dd4-3-1-3 = Learn how to animate between two views with a flipping motion.
dt4-3-1-4 = <b><a href="http://developer.android.com/zoom.html">Zooming a View</a></b>
dd4-3-1-4 = Learn how to enlarge views with a touch-to-zoom animation.
dt4-3-1-5 = <b><a href="http://developer.android.com/layout.html">Animating Layout Changes</a></b>
dd4-3-1-5 = Learn how to enable built-in animations when adding, removing, or updating child views in a layout.
title4-3-1 = Crossfading Two Views
p4-3-1-1 = Crossfade animations (also know as dissolve) gradually fade out one UI component while simultaneously fading in another. This animation is useful for situations where you want to switch content or views in your app. Crossfades are very subtle and short but offer a fluid transition from one screen to the next. When you don't use them, however, transitions often feel abrupt or hurried.
p4-3-1-2 = Here's an example of a crossfade from a progress indicator to some text content.
p4-3-1-3 = If you want to jump ahead and see a full working example, <a href="http://developer.android.com//shareables/training/Animations.zip">download</a> and run the sample app and select the Crossfade example. See the following files for the code implementation:
#ul
li4-3-1-1 = <code>src/CrossfadeActivity.java</code>
li4-3-1-2 = <code>layout/activity_crossfade.xml</code>
li4-3-1-3 = <code>menu/activity_crossfade.xml</code>
sub_title4-3-1-1 = Create the Views
p4-3-1-1-1 = Create the two views that you want to crossfade. The following example creates a progress indicator and a scrollable text view:
#pre4-3-1-1-1
sub_title4-3-1-2 = Set up the Animation
p4-3-1-2-1 = To set up the animation:
#ol
li4-3-1-2-1 = Create member variables for the views that you want to crossfade. You need these references later when modifying the views during the animation.
li4-3-1-2-2 = For the view that is being faded in, set its visibility to <code><a href="http://developer.android.com//reference/android/view/View.html#GONE">GONE</a></code>. This prevents the view from taking up layout space and omits it from layout calculations, speeding up processing.
li4-3-1-2-3 = Cache the <code><code><a href="http://developer.android.com//reference/android/R.integer.html#config_shortAnimTime">config_shortAnimTime</a></code></code> system property in a member variable. This property defines a standard "short" duration for the animation. This duration is ideal for subtle animations or animations that occur very frequently. <code><a href="http://developer.android.com//reference/android/R.integer.html#config_longAnimTime">config_longAnimTime</a></code> and <code><a href="http://developer.android.com//reference/android/R.integer.html#config_mediumAnimTime">config_mediumAnimTime</a></code> are also available if you wish to use them.
p4-3-1-2-2 = Here's an example using the layout from the previous code snippet as the activity content view:
#pre4-3-1-2-1
sub_title4-3-1-3 = Crossfade the Views
p4-3-1-3-1 = Now that the views are properly set up, crossfade them by doing the following:
#ol
li4-3-1-3-1 = For the view that is fading in, set the alpha value to <code>0</code> and the visibility to <code><a href="http://developer.android.com//reference/android/view/View.html#VISIBLE">VISIBLE</a></code>. (Remember that it was initially set to <code><a href="http://developer.android.com//reference/android/view/View.html#GONE">GONE</a></code>.) This makes the view visible but completely transparent.
li4-3-1-3-2 = For the view that is fading in, animate its alpha value from <code>0</code> to <code>1</code>. At the same time, for the view that is fading out, animate the alpha value from <code>1</code> to <code>0</code>.
li4-3-1-3-3 = Using <code><a href="http://developer.android.com//reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> in an <code><a href="http://developer.android.com//reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code>, set the visibility of the view that was fading out to <code><a href="http://developer.android.com//reference/android/view/View.html#GONE">GONE</a></code>. Even though the alpha value is <code>0</code>, setting the view's visibility to <code><a href="http://developer.android.com//reference/android/view/View.html#GONE">GONE</a></code> prevents the view from taking up layout space and omits it from layout calculations, speeding up processing.
p4-3-1-3-2 = The following method shows an example of how to do this:
#pre4-3-1-3-1
title4-3-2 = Using ViewPager for Screen Slides
p4-3-2-1 = Screen slides are transitions between one entire screen to another and are common with UIs like setup wizards or slideshows. This lesson shows you how to do screen slides with a <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code> provided by the <a href="http://developer.android.com//tools/support-library/index.html">support library</a>. <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code>s can animate screen slides automatically. Here's what a screen slide looks like that transitions from one screen of content to the next:
p4-3-2-2 = If you want to jump ahead and see a full working example, <a href="http://developer.android.com//shareables/training/Animations.zip">download</a> and run the sample app and select the Screen Slide example. See the following files for the code implementation:
#ul
li4-3-2-1 = <code>src/ScreenSlidePageFragment.java</code>
li4-3-2-2 = <code>src/ScreenSlideActivity.java</code>
li4-3-2-3 = <code>layout/activity_screen_slide.xml</code>
li4-3-2-4 = <code>layout/fragment_screen_slide_page.xml</code>
sub_title4-3-2-1 = Create the Views
p4-3-2-1-1 = Create a layout file that you'll later use for the content of a fragment. The following example contains a text view to display some text:
#pre4-3-2-1-1
p4-3-2-1-2 = Define also a string for the contents of the fragment.
sub_title4-3-2-2 = Create the Fragment
p4-3-2-2-1 = Create a <code><a href="http://developer.android.com//reference/android/support/v4/app/Fragment.html">Fragment</a></code> class that returns the layout that you just created in the <code><a href="http://developer.android.com//reference/android/app/Fragment.html#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)">onCreateView()</a></code> method. You can then create instances of this fragment in the parent activity whenever you need a new page to display to the user:
#pre4-3-2-2-1
sub_title4-3-2-3 = Add a ViewPager
p4-3-2-3-1 = <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code>s have built-in swipe gestures to transition through pages, and they display screen slide animations by default, so you don't need to create any. <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code>s use <code><a href="http://developer.android.com//reference/android/support/v4/view/PagerAdapter.html">PagerAdapter</a></code>s as a supply for new pages to display, so the <code><a href="http://developer.android.com//reference/android/support/v4/view/PagerAdapter.html">PagerAdapter</a></code> will use the fragment class that you created earlier.
p4-3-2-3-2 = To begin, create a layout that contains a <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code>:
#pre4-3-2-3-1
p4-3-2-3-3 = Create an activity that does the following things:
#ul
li4-3-2-3-1 = Sets the content view to be the layout with the <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code>.
li4-3-2-3-2 = Creates a class that extends the <code><a href="http://developer.android.com//reference/android/support/v13/app/FragmentStatePagerAdapter.html">FragmentStatePagerAdapter</a></code> abstract class and implements the <code><a href="http://developer.android.com//reference/android/support/v4/app/FragmentStatePagerAdapter.html#getItem(int)">getItem()</a></code> method to supply instances of <code>ScreenSlidePageFragment</code> as new pages. The pager adapter also requires that you implement the <code><a href="http://developer.android.com//reference/android/support/v4/view/PagerAdapter.html#getCount()">getCount()</a></code> method, which returns the amount of pages the adapter will create (five in the example).
li4-3-2-3-3 = Hooks up the <code><a href="http://developer.android.com//reference/android/support/v4/view/PagerAdapter.html">PagerAdapter</a></code> to the <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html">ViewPager</a></code>.
li4-3-2-3-4 = Handles the device's back button by moving backwards in the virtual stack of fragments. If the user is already on the first page, go back on the activity back stack.
#pre4-3-2-3-2
sub_title4-3-2-4 = Customize the Animation with PageTransformer
p4-3-2-4-1 = To display a different animation from the default screen slide animation, implement the <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.PageTransformer.html">ViewPager.PageTransformer</a></code> interface and supply it to the view pager. The interface exposes a single method, <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.PageTransformer.html#transformPage(android.view.View, float)">transformPage()</a></code>. At each point in the screen's transition, this method is called once for each visible page (generally there's only one visible page) and for adjacent pages just off the screen. For example, if page three is visible and the user drags towards page four, <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.PageTransformer.html#transformPage(android.view.View, float)">transformPage()</a></code> is called for pages two, three, and four at each step of the gesture.
p4-3-2-4-2 = In your implementation of <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.PageTransformer.html#transformPage(android.view.View, float)">transformPage()</a></code>, you can then create custom slide animations by determining which pages need to be transformed based on the position of the page on the screen, which is obtained from the <code>position</code> parameter of the <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.PageTransformer.html#transformPage(android.view.View, float)">transformPage()</a></code> method.
p4-3-2-4-3 = The <code>position</code> parameter indicates where a given page is located relative to the center of the screen. It is a dynamic property that changes as the user scrolls through the pages. When a page fills the screen, its position value is <code>0</code>. When a page is drawn just off the right side of the screen, its position value is <code>1</code>. If the user scrolls halfway between pages one and two, page one has a position of -0.5 and page two has a position of 0.5. Based on the position of the pages on the screen, you can create custom slide animations by setting page properties with methods such as <code><a href="http://developer.android.com//reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code>, <code><a href="http://developer.android.com//reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code>, or <code><a href="http://developer.android.com//reference/android/view/View.html#setScaleY(float)">setScaleY()</a></code>.
p4-3-2-4-4 = When you have an implementation of a <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.PageTransformer.html">PageTransformer</a></code>, call <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.html#setPageTransformer(boolean, android.support.v4.view.ViewPager.PageTransformer)">setPageTransformer()</a></code> with your implementation to apply your custom animations. For example, if you have a <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.PageTransformer.html">PageTransformer</a></code> named <code>ZoomOutPageTransformer</code>, you can set your custom animations like this:
#pre4-3-2-4-1
p4-3-2-4-5 = See the <a href="http://developer.android.com/#zoom-out">Zoom-out page transformer</a> and <a href="http://developer.android.com/#depth-page">Depth page transformer</a> sections for examples and videos of a <code><a href="http://developer.android.com//reference/android/support/v4/view/ViewPager.PageTransformer.html">PageTransformer</a></code>.
lead4-3-2-4-1 = Zoom-out page transformer
p4-3-2-4-6 = This page transformer shrinks and fades pages when scrolling between adjacent pages. As a page gets closer to the center, it grows back to its normal size and fades in.
#pre4-3-2-4-2
lead4-3-2-4-2 = Depth page transformer
p4-3-2-4-7 = This page transformer uses the default slide animation for sliding pages to the left, while using a "depth" animation for sliding pages to the right. This depth animation fades the page out, and scales it down linearly.
nc4-3-2-4-1 = <strong>Note:</strong> During the depth animation, the default animation (a screen slide) still takes place, so you must counteract the screen slide with a negative X translation. For example:
#pre4-3-2-4-3
#pre4-3-2-4-4
title4-3-3 = Displaying Card Flip Animations
p4-3-3-1 = This lesson shows you how to do a card flip animation with custom fragment animations. Card flips animate between views of content by showing an animation that emulates a card flipping over.
p4-3-3-2 = Here's what a card flip looks like:
p4-3-3-3 = If you want to jump ahead and see a full working example, <a href="http://developer.android.com//shareables/training/Animations.zip">download</a> and run the sample app and select the Card Flip example. See the following files for the code implementation:
#ul
li4-3-3-1 = <code>src/CardFlipActivity.java</code>
li4-3-3-2 = <code>animator/card_flip_right_in.xml</code>
li4-3-3-3 = <code>animator/card_flip_right_out.xml</code>
li4-3-3-4 = <code>animator/card_flip_left_in.xml</code>
li4-3-3-5 = <code>animator/card_flip_left_out.xml</code>
li4-3-3-6 = <code>layout/fragment_card_back.xml</code>
li4-3-3-7 = <code>layout/fragment_card_front.xml</code>
sub_title4-3-3-1 = Create the Animators
p4-3-3-1-1 = Create the animations for the card flips. You'll need two animators for when the front of the card animates out and to the left and in and from the left. You'll also need two animators for when the back of the card animates in and from the right and out and to the right.
#pre4-3-3-1-1
#pre4-3-3-1-2
#pre4-3-3-1-3
#pre4-3-3-1-4
sub_title4-3-3-2 = Create the Views
p4-3-3-2-1 = Each side of the "card" is a separate layout that can contain any content you want, such as two screens of text, two images, or any combination of views to flip between. You'll then use the two layouts in the fragments that you'll later animate. The following layouts create one side of a card that shows text:
#pre4-3-3-2-1
p4-3-3-2-2 = and the other side of the card that displays an <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>:
#pre4-3-3-2-2
sub_title4-3-3-3 = Create the Fragment
p4-3-3-3-1 = Create fragment classes for the front and back of the card. These classes return the layouts that you created previously in the <code><a href="http://developer.android.com//reference/android/app/Fragment.html#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)">onCreateView()</a></code> method of each fragment. You can then create instances of this fragment in the parent activity where you want to show the card. The following example shows nested fragment classes inside of the parent activity that uses them:
#pre4-3-3-3-1
sub_title4-3-3-4 = Animate the Card Flip
p4-3-3-4-1 = Now, you'll need to display the fragments inside of a parent activity. To do this, first create the layout for your activity. The following example creates a <code><a href="http://developer.android.com//reference/android/widget/FrameLayout.html">FrameLayout</a></code> that you can add fragments to at runtime:
#pre4-3-3-4-1
p4-3-3-4-2 = In the activity code, set the content view to be the layout that you just created. It's also good idea to show a default fragment when the activity is created, so the following example activity shows you how to display the front of the card by default:
#pre4-3-3-4-2
p4-3-3-4-3 = Now that you have the front of the card showing, you can show the back of the card with the flip animation at an appropriate time. Create a method to show the other side of the card that does the following things:
#ul
li4-3-3-4-1 = Sets the custom animations that you created earlier for the fragment transitions.
li4-3-3-4-2 = Replaces the currently displayed fragment with a new fragment and animates this event with the custom animations that you created.
li4-3-3-4-3 = Adds the previously displayed fragment to the fragment back stack so when the user presses the <em>Back</em> button, the card flips back over.
#pre4-3-3-4-3
title4-3-4 = Zooming a View
p4-3-4-1 = This lesson demonstrates how to do a touch-to-zoom animation, which is useful for apps such as photo galleries to animate a view from a thumbnail to a full-size image that fills the screen.
p4-3-4-2 = Here's what a touch-to-zoom animation looks like that expands an image thumbnail to fill the screen:
p4-3-4-3 = If you want to jump ahead and see a full working example, <a href="http://developer.android.com//shareables/training/Animations.zip">download</a> and run the sample app and select the Zoom example. See the following files for the code implementation:
#ul
li4-3-4-1 = <code>src/TouchHighlightImageButton.java</code> (a simple helper class that shows a blue touch highlight when the image button is pressed)
li4-3-4-2 = <code>src/ZoomActivity.java</code>
li4-3-4-3 = <code>layout/activity_zoom.xml</code>
sub_title4-3-4-1 = Create the Views
p4-3-4-1-1 = Create a layout file that contains the small and large version of the content that you want to zoom. The following example creates an <code><a href="http://developer.android.com//reference/android/widget/ImageButton.html">ImageButton</a></code> for clickable image thumbnail and an <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> that displays the enlarged view of the image:
#pre4-3-4-1-1
sub_title4-3-4-2 = Set up the Zoom Animation
p4-3-4-2-1 = Once you apply your layout, set up the event handlers that trigger the zoom animation. The following example adds a <code><a href="http://developer.android.com//reference/android/view/View.OnClickListener.html">View.OnClickListener</a></code> to the <code><a href="http://developer.android.com//reference/android/widget/ImageButton.html">ImageButton</a></code> to execute the zoom animation when the user clicks the image button:
#pre4-3-4-2-1
sub_title4-3-4-3 = Zoom the View
p4-3-4-3-1 = You'll now need to animate from the normal sized view to the zoomed view when appropriate. In general, you need to animate from the bounds of the normal-sized view to the bounds of the larger-sized view. The following method shows you how to implement a zoom animation that zooms from an image thumbnail to an enlarged view by doing the following things:
#ol
li4-3-4-3-1 = Assign the high-res image to the hidden "zoomed-in" (enlarged) <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>. The following example loads a large image resource on the UI thread for simplicity. You will want to do this loading in a separate thread to prevent blocking on the UI thread and then set the bitmap on the UI thread. Ideally, the bitmap should not be larger than the screen size.
li4-3-4-3-2 = Calculate the starting and ending bounds for the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>.
li4-3-4-3-3 = Animate each of the four positioning and sizing properties <code><code><a href="http://developer.android.com//reference/android/view/View.html#X">X</a></code></code>, <code><code><a href="http://developer.android.com//reference/android/view/View.html#Y">Y</a></code></code>, (<code><a href="http://developer.android.com//reference/android/view/View.html#SCALE_X">SCALE_X</a></code>, and <code><code><a href="http://developer.android.com//reference/android/view/View.html#SCALE_Y">SCALE_Y</a></code></code>) simultaneously, from the starting bounds to the ending bounds. These four animations are added to an <code><a href="http://developer.android.com//reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> so that they can be started at the same time.
li4-3-4-3-4 = Zoom back out by running a similar animation but in reverse when the user touches the screen when the image is zoomed in. You can do this by adding a <code><a href="http://developer.android.com//reference/android/view/View.OnClickListener.html">View.OnClickListener</a></code> to the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>. When clicked, the <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code> minimizes back down to the size of the image thumbnail and sets its visibility to <code><a href="http://developer.android.com//reference/android/view/View.html#GONE">GONE</a></code> to hide it.
#pre4-3-4-3-1
title4-3-5 = Animating Layout Changes
p4-3-5-1 = A layout animation is a pre-loaded animation that the system runs each time you make a change to the layout configuration. All you need to do is set an attribute in the layout to tell the Android system to animate these layout changes, and system-default animations are carried out for you.
tc4-3-5-1 = <strong>Tip</strong>: If you want to supply custom layout animations, create a <code><a href="http://developer.android.com//reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> object and supply it to the layout with the <code><a href="http://developer.android.com//reference/android/view/ViewGroup.html#setLayoutTransition(android.animation.LayoutTransition)">setLayoutTransition()</a></code> method.
p4-3-5-2 = If you want to jump ahead and see a full working example, <a href="http://developer.android.com//shareables/training/Animations.zip">download</a> and run the sample app and select the Crossfade example. See the following files for the code implementation:
#ol
li4-3-5-1 = <code>src/LayoutChangesActivity.java</code>
li4-3-5-2 = <code>layout/activity_layout_changes.xml</code>
li4-3-5-3 = <code>menu/activity_layout_changes.xml</code>
sub_title4-3-5-1 = Create the Layout
p4-3-5-1-1 = In your activity's layout XML file, set the <code>android:animateLayoutChanges</code> attribute to <code>true</code> for the layout that you want to enable animations for. For instance:
#pre4-3-5-1-1
sub_title4-3-5-2 = Add, Update, or Remove Items from the Layout
p4-3-5-2-1 = Now, all you need to do is add, remove, or update items in the layout and the items are animated automatically:
#pre4-3-5-2-1
