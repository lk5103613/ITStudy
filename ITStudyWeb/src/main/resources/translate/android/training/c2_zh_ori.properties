title2 = 创建内容共享的应用
p2-1 = 本次课程教你怎样创建可以在应用和设备之间共享数据的app。
title2-1 = 共享简单数据
p2-1-1 = Android应用的其中一个最让人称赞的地方是他们可以和其他的应用交流和集成。为什么要重写那些已经在别的应用中存在的并且不是你的应用的主要功能的功能模块？
p2-1-2 = 本此课程会介绍一些在不同应用间发送和接收数据的方式，需要使用<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> API 和 <code><a href="http://developer.android.com//reference/android/view/ActionProvider.html">ActionProvider</a></code> 对象。
sub_title2-1-1 = 课程
dt2-1-1-1 = <b><a href="#c2-1-1">向其他应用发送简单数据</a></b>
dd2-1-1-1 = 学习怎样使用Intent来让你的应用能够像别的应用发送文本或者二进制数据。
dt2-1-1-2 = <b><a href="#c2-1-2">从别的应用中接收简单数据</a></b>
dd2-1-1-2 = 学习怎样让你的应用从Intent中读取文本和二进制数据。
dt2-1-1-3 = <b><a href="#c2-1-3">添加一个简单的共享操作</a></b>
dd2-1-1-3 = 学习怎样给你的action bar添加一个简单的共享操作。
title2-1-1 = 向别的应用传递简单数据
p2-1-1-1 = 当你构造了一个Intent的时候，你必须指定一个你希望这个intent“出触发”的行为, android中定义了一些action，包括<code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_SEND">ACTION_SEND</a></code>， 就像你大概猜到的那样，这个intent是从一个activity向另外的activity发送数据，甚至有可能是跨进程的。要想向别的activity发送数据，你需要做的仅仅是指定要发送的数据和它的类型，系统将会找到合适的activity接收这些数据，然后展示出来(如果有多个选择的话) 或者直接打开一个activity (如果只有一个选择的话)。 类似的, 你可以通过配置manifest文件来声明你的应用可以接收的数据类型。
p2-1-1-2 = 在应用之间使用Intent传递和接收数据是共享数据的最常用的方式。Intent应用中可以快速的简单的实现数据共享。
nc2-1-1-1 = <strong>主义:</strong> 给 <code><a href="http://developer.android.com//reference/android/app/ActionBar.html">ActionBar</a></code>添加一个共享操作项的最好的方式是使用  <code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProvider</a></code>, API14 及其以上支持。 <code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProvider</a></code> 在<a href="c2-1-3">添加简单的共享操作</a>中有讨论。
sub_title2-1-1-1 = 发送文本内容
#share-text-screenshot.png
p2-1-1-1-1 = 最直接的并且最常用的使用 <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_SEND">ACTION_SEND</a></code>的方式是从一个activity向其他的activity发送文本内容。例如，内置的Browser应用可以和其他的应用以文本的形式共享当前展示的页面的URL。这在朋友之间通过邮件或者其他社交网络共享文章或者网站时是非常有用的。下面的代码实现了这种类型的共享：
#pre2-1-1-1-1
p2-1-1-1-2 = 如果已经安装了带有 <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_SEND">ACTION_SEND</a></code> 过滤器并且 MIME 类型是 text/plain的应用, Android系统就会调用它; 如果有多个应用符合条件, 系统将会展示一个弹出框（一个选择器）让你选择想要使用的app。
p2-1-1-1-3 = 然而, 如果你调用 <code><a href="http://developer.android.com//reference/android/content/Intent.html#createChooser(android.content.Intent, java.lang.CharSequence)">Intent.createChooser()</a></code>, 然后传给他你的 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 对象, 他将会返回你的intent，并且将会一直显示这个选择器。这样做有以下好处：
#ul
li2-1-1-1-1 = 即使用户已经为这个intent选择了默认的行为，这个选择器还是会展示。
li2-1-1-1-2 = 如果没有符合的应用, Android会显示一条系统消息。
li2-1-1-1-3 = 你可以为这个选择器指定一个标题。
p2-1-1-1-4 = 下面是更改后的代码:
#pre2-1-1-1-2
p2-1-1-1-5 = 最终的dialog会像图1中展示的那样。
p2-1-1-1-6 = 此外, 你可以为intent指定标准的额外的数据： <code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_EMAIL">EXTRA_EMAIL</a></code>, <code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_CC">EXTRA_CC</a></code>, <code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_BCC">EXTRA_BCC</a></code>, <code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_SUBJECT">EXTRA_SUBJECT</a></code>。如果接受到的应用不打算使用这些数据，只会简单的忽略掉。
nc2-1-1-1-1 = <strong>注意:</strong> 一些邮件应用, 例如Gmail, 会期望把一个 <code><a href="http://developer.android.com//reference/java/lang/String.html">String[]</a></code>作为extra,像<code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_EMAIL">EXTRA_EMAIL</a></code> 和 <code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_CC">EXTRA_CC</a></code>, 使用 <code><a href="http://developer.android.com//reference/android/content/Intent.html#putExtra(java.lang.String, java.lang.String[])">putExtra(String, String[])</a></code>把它们添加到你的intent中。
sub_title2-1-1-2 = 发送二进制数据
p2-1-1-2-1 = 二进制数据的共享是通过 <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_SEND">ACTION_SEND</a></code> action，并且要设置对应的MIME类型，然后添加到名为<code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_STREAM">EXTRA_STREAM</a></code>的extra数据中。通常被用于共享图片，还可以用于其他任何的二进制数据共享：
#pre2-1-1-2-1
p2-1-1-2-2 = 注意下面的内容:
#ul
li2-1-1-2-1 = 你可以把MIME类型设置为<code>"*/*"</code>, 但是他只会匹配那些能够处理一般的数据流的activity。
li2-1-1-2-2 = 接收数据的应用需要声明权限来使用 <code><a href="http://developer.android.com//reference/android/net/Uri.html">Uri</a></code> 指定的数据。推荐的实现方式是：
#ulbegin
li2-1-1-2-3 = 在自己的 <code><a href="http://developer.android.com//reference/android/content/ContentProvider.html">ContentProvider</a></code>中存储数据, 要确保其他的应用有这个权限可以访问你的provider。访问provider的首选机制是使用<a href="http://developer.android.com//guide/topics/security/permissions.html#uri">per-URI permissions</a>，它是暂时的并且只给那些接收数据的应用分配使用权限。 创建一个 <code><a href="http://developer.android.com//reference/android/content/ContentProvider.html">ContentProvider</a></code> 的很好的方式是使用<code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 帮助类。
li2-1-1-2-4 = 使用系统的<code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code>。 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code> 是主要针对音频，视频和图片类型。然而，从Android3.0开始 (API 11) 也可以存储非媒体类型(参考 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.Files.html">MediaStore.Files</a></code> )。 使用 <code><a href="http://developer.android.com//reference/android/media/MediaScannerConnection.html#scanFile(android.content.Context, java.lang.String[], java.lang.String[], android.media.MediaScannerConnection.OnScanCompletedListener)">scanFile()</a></code>可以将文件添加到<code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code>，在这之后适用于共享的<code>content://</code> style <code><a href="http://developer.android.com//reference/android/net/Uri.html">Uri</a></code> 被传递到提供的 <code><a href="http://developer.android.com//reference/android/media/MediaScannerConnection.OnScanCompletedListener.html#onScanCompleted(java.lang.String, android.net.Uri)">onScanCompleted()</a></code> 回调方法中。注意，一旦添加到系统 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code>，这个content就可以被该设备的任何app访问。
#end
sub_title2-1-1-3 = 发送多个内容块
p2-1-1-3-1 = 要想同时共享多个内容模块, 需要使用<code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_SEND_MULTIPLE">ACTION_SEND_MULTIPLE</a></code> action 和指向内容的URI。 MIME类型整合了你需要共享的内容的类型。例如，如果你需要共享三个JPEG图片，那么MIME类型应该是<code>"image/jpeg"</code>。对于混合的图片类型，也应该是使用 <code>"image/*"</code> 来匹配那些可以处理任何图片类型的activity。如果你需要共享的类型有很多，你只需要使用 <code>"*/*"</code>。 如上所述, 怎样解析和处理你的数据是由接收数据的应用决定的。这里有一个例子:
#pre2-1-1-3-1
p2-1-1-3-2 = 和前面一样, 要确保指向数据的<code><a href="http://developer.android.com//reference/android/net/Uri.html">URIs</a></code>对接受者应用来讲是可用的。 
title2-1-2 = 从别的应用接收简单数据
p2-1-2-1 = 就像你的应用可以向别的应用发送数据一样，那么他也可以从别的应用接收数据。考虑一下你的应用时怎样和用户交互的，你希望从别的应用中获取什么类型的数据。例如， 一个社交网络应用会比较想要从别的应用接收像WEB URL这样的文本内容。<a href="http://developer.android.com/https://play.google.com/store/apps/details?id=com.google.android.apps.plus">Google+ Android 应用</a> 可以接收文本和单个或多个图片。使用这款app，用户可以很简单的使用从Android相册应用中的图片开启一个新的Google+ 发送操作。
sub_title2-1-2-1 = 更新你的Manifest
p2-1-2-1-1 = Intent filter告诉系统这个应用组件可以接收什么样的intent。就像在<a href="#c2-1-1">向别的应用发送简单数据</a> 课程中那样，创建了一个action为<code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_SEND">ACTION_SEND</a></code>的Intent，创建intent filter的目的是要接收那些使用了这个action的intent。 使用 <code><a href="http://developer.android.com//guide/components/intents-filters.html#ifs">&lt;intent-filter&gt;</a></code> 元素在manifest中定义intent filter。 例如， 如果你的应用可以处理文本，单张任何类型的图片，或者任何类型的多张图片，那么你的manifest应该是这样的：
#pre2-1-2-1-1
nc2-1-2-1-1 = <strong>注意:</strong> 更多冠以intent filter和intent 解决方案的信息，请参考<a href="http://developer.android.com//guide/components/intents-filters.html#ifs">Intents 和 Intent Filters</a>
p2-1-2-1-2 = 当其他的应用试图通过构造intent对象，然后把它传递给<code><a href="http://developer.android.com//reference/android/content/Context.html#startActivity(android.content.Intent)">startActivity()</a></code>来共享这些内容，你的应用将会出现在intent选择器中。如果用户选择了你的应用，对应的activity(在上面的例子中是<code>.ui.MyActivity</code>)将会被打开。那么接下来就取决于你怎样在代码和UI中处理这些内容。
sub_title2-1-2-2 = 处理增值内容
p2-1-2-2-1 = 想要处理通过 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>传递的数据, 从 calling <code><a href="http://developer.android.com//reference/android/content/Intent.html#getIntent(java.lang.String)">getIntent()</a></code> 开始，获得一个 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 对象。一旦你有了这个对象，你就可以检测他的内容，然后再决定怎样处理。请记住，如果一个activity可以从系统的其他地方打开，那么你需要考虑在什么时候检测这个intent。 
#pre2-1-2-2-1
cc2-1-2-2-1 = <strong>警告:</strong> 请花点精力检查增值数据，你永远不知道其他的应用会发送给你什么数据。例如，设置了错误的MIME类型，或者发送的图片太大。此外，要记住在非UI线程中处理二进制数据。
p2-1-2-2-2 = 更新UI可以像填充一个<code><a href="http://developer.android.com//reference/android/widget/EditText.html">EditText</a></code>这样简单, 也可以像过滤感兴趣的图片那样复杂。怎样处理完全取决于你的应用。
title2-1-3 = 添加一个简单的共享操作
p2-1-3-1 = 学习了 <code><a href="http://developer.android.com//reference/android/view/ActionProvider.html">ActionProvider</a></code> 之后，在Android 4.0以上(API 14)在你的<code><a href="http://developer.android.com//reference/android/app/ActionBar.html">ActionBar</a></code>上添加一个高效的用户友好的共享操作就变的非常简单。 一个 <code><a href="http://developer.android.com//reference/android/view/ActionProvider.html">ActionProvider</a></code>, 一旦绑定了action bar中的menu项， 就需要处理这个item的外观和行为。就 <code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProvider</a></code>来说, 你只需要提供一个共享的Intent，然后剩下的交给它。
nc2-1-3-1 = <strong>注意:&nbsp;</strong> <code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProvider</a></code> 在API 14及其以上可用。
#actionbar-shareaction.png
sub_title2-1-3-1 = 修改MENU声明
p2-1-3-1-1 = 开始使用<code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProviders</a></code>, 为在a href="http://developer.android.com//guide/topics/resources/menu-resource.html">menu resource</a> 文件中对应的<code>&lt;item&gt;</code>添加 <code>android:actionProviderClass</code> 属性:
#pre2-1-3-1-1
p2-1-3-1-2 = 这就声明了由谁来负责item的外观以及 <code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProvider</a></code>的功能。然热，你需要告诉provider你想要共享什么数据。 
sub_title2-1-3-2 = 设置共享Intent
p2-1-3-2-1 =要想让 <code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProvider</a></code> 运行，你必须制定一个共享 intent。这个共享intent应该和<a href="#c2-1-1">向别的应用发送简单数据</a> 课程中一样，使用 <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_SEND">ACTION_SEND</a></code>action，然后使用extras设置额外的数据，像<code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_TEXT">EXTRA_TEXT</a></code> 和 <code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_STREAM">EXTRA_STREAM</a></code>。 要想指派一个共享 intent, 在初始化<code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>或者<code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragment</a></code>中的menu资源的时候，首先要找到对应的<code><a href="http://developer.android.com//reference/android/view/MenuItem.html">MenuItem</a></code>，然后，在调用<code><a href="http://developer.android.com//reference/android/view/MenuItem.html#getActionProvider()">MenuItem.getActionProvider()</a></code> 来获取<code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProvider</a></code>的实例。 使用 <code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html#setShareIntent(android.content.Intent)">setShareIntent()</a></code> 来更新和action item想关联的共享intent。示例如下：
#pre2-1-3-2-1
p2-1-3-2-2 = 你只需要在创建menu的时候设置一下共享intent，你有可能设置了之后想要根据UI的变化来修改它。例如，当你在使用Gallery应用全屏查看图片的时候，在你滑动图片的时候共享intent会随之改变。
p2-1-3-2-3 = 关于<code><a href="http://developer.android.com//reference/android/widget/ShareActionProvider.html">ShareActionProvider</a></code> 对象更深入的讨论,请参考 <a href="http://developer.android.com//guide/topics/ui/actionbar.html#ActionProvider">Action Bar</a> 指南。
title2-2 = 共享文件
p2-2-1 = 应用通常需要为其他的应用提供一个或多个文件。例如，一个图片相册有可能要为图片编辑器提供图片，或者一个文件管理应用可能需要允许用户在不同的外部存储之间复制和粘贴文件。发送者应用共享文件的其中一个方式是响应接收者应用的请求。
p2-2-2 = 在所有的情况下, 从你的应用中给别的应用提供文件的唯一一个安全的方式是发送文件Content URI，然后给这个URI添加临时访问权限。带有临时URI访问权限的Content URI是安全的，因为他们只对那些需要接受这个URI的应用可用，并且他们会自动失效。 Android <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 组件提供了 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context, java.lang.String, java.io.File)">getUriForFile()</a></code>方法，这个方法可用于生成文件的 content URI。
p2-2-3 = 如果你想要在应用间共享比较小的文本或者数字，你应该发送一个包含这些数据的<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 。想要学习怎样使用<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>发送简单数据，请参考 培训课程 <a href="http://developer.android.com//training/sharing/index.html">共享简单数据</a>。
p2-2-4 = 本次课程解释了怎样使用Android <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>生成的content URI以及分配给接受者应用的 Content URI的临时权限，来安全的让你的应用和别的应用共享文件。
sub_title2-2-1 = 课程
dt2-2-1-1 = <b><a href="http://developer.android.com/setup-sharing.html">设置文件共享</a></b>
dd2-2-1-1 = 学习怎样设置你的应用来实现文件共享。
dt2-2-1-2 = <b><a href="http://developer.android.com/share-file.html">共享一个文件</a></b>
dd2-2-1-2 = 学习怎样通过生成一个文件的content URI来给别的应用提供文件，怎样为URI分配临时访问权限，以及怎样给应用传递这个URI。
dt2-2-1-3 = <b><a href="http://developer.android.com/request-file.html">请求一个共享文件</a></b>
dd2-2-1-3 = 学习怎样请求一个别的应用共享的文件, 获取该文件的 content URI，然后使用这个content URI 打开文件。
dt2-2-1-4 = <b><a href="http://developer.android.com/retrieve-info.html">获取文件信息</a></b>
dd2-2-1-4 = 学习怎样在应用中通过<code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>生成的content URI，来获取文件信息，包括MIME类型和文件大小。
title2-2-1 = 配置文件共享
p2-2-1-1 = 想要安全的给别的应用提供文，你需要配置你的应用来给这个文件提供一个安全的处理方式，以content URI的形式。Android <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 组件用于根据你在XML中的说明来生成文件的content URI。本次课程教你怎样为你的应用添加默认的 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 实现, 以及怎样制定哪些你想要提供给别的应用的文件。
nc2-2-1-1 = <strong>注意:</strong>  <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 类是 <a href="http://developer.android.com//tools/support-library/features.html#v4">v4 Support Library</a>的一部分。更多的关于这特 library的信息，请参考<a href="http://developer.android.com//tools/support-library/setup.html">Support Library Setup</a>。
sub_title2-2-1-1 = 指定FileProvider
p2-2-1-1-1 = 为你的应用定义一个 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>需要你的manifest中的一个条款。这个条款指定了使用这个content URI的授权码，就像那个指定了你的应用可以共享的目录的xml文件的名字一样。
p2-2-1-1-2 = 下面的代码片段展示怎样在manifest中添加 <code><a href="http://developer.android.com//guide/topics/manifest/provider-element.html">&lt;provider&gt;</a></code> 元素来指定 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 类,授权码, 以及xml文件名:
#pre2-2-1-1-1
p2-2-1-1-3 = 在本例中, <code><a href="http://developer.android.com//guide/topics/manifest/provider-element.html#auth">android:authorities</a></code> 属性指定了你想要使用的content URI的权限，这个URI由 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>生成。在这个例子中，授权码是<code>com.example.myapp.fileprovider</code>。 对于你自己的应用, 参考应用的 <code><a href="http://developer.android.com//guide/topics/manifest/manifest-element.html#package">android:package</a></code> 值，并在它的后面添加"fileprovider"字符串，来指定这个授权码， 参考<a href="http://developer.android.com//guide/topics/providers/content-provider-basics.html#ContentURIs">Content URIs</a> 以及 <code><a href="http://developer.android.com//guide/topics/manifest/provider-element.html#auth">android:authorities</a></code> 属性的文档。
p2-2-1-1-4 = <code><a href="http://developer.android.com//guide/topics/manifest/meta-data-element.html">&lt;meta-data&gt;</a></code> 是 <code><a href="http://developer.android.com//guide/topics/manifest/provider-element.html">&lt;provider&gt;</a></code>的子元素，他指向那个定义了你想要共享的目录的XML文件。<code>android:resource</code> 属性是文件的名字和路径，不带有 <code>.xml</code> 后缀。文件的内容会在下面的教程中讲解。
sub_title2-2-1-2 = 指定可共享的目录
p2-2-1-2-1 = 一旦你给manifest添加了 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> , 你需要指定那个包含了你想共享的文件的目录。要想指定这个目录, 首先需要子在你的项目的 <code>res/xml/</code> 子目录下创建<code>filepaths.xml</code> 。在这个文件中， 为每一个目录添加XML元素来指定这个目录。下面的片段展示了 <code>res/xml/filepaths.xml</code>的内容。 这个片段也展示了怎样共享一个在内部存储中的<code>files/</code>的子目录的：
#pre2-2-1-2-1
p2-2-1-2-2 = 在这个例子中, <code>&lt;files-path&gt;</code> 标签共享了你应用内部存储中的 <code>files/</code>下的目录。<code>path</code> 属性共享了 <code>files/</code>下的 <code>images/</code> 子目录。<code>name</code> 属性会告诉 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 为<code>files/images/</code>子目录下的文件的content URI添加一个路径分隔<code>myimages</code> 。
p2-2-1-2-3 = <code>&lt;paths&gt;</code> 元素可以有多个子元素，每一个都指定了一个不同的共享目录。 除了 <code>&lt;files-path&gt;</code> 元素之外, 你可以使用 <code>&lt;external-path&gt;</code> 元素来共享外部存储的目录，<code>&lt;cache-path&gt;</code> 元素用于共享内部存储中的目录。想要更深入的学习那些指定共享目录的子元素，请参考 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 文档。
nc2-2-1-2-1 = <strong>注意:</strong> XML文件是指定你想要共享的目录的唯一方式；你不可以通过编程的方式添加一个目录。
p2-2-1-2-4 = 现在对于怎样使用<code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>来为应用内部存储中<code>files/</code> 下的文件，或者其子目录下的文件生成content uri 有了一个完整的说明。当你的应用为一个文件生成了content uri时，它包含了在<code><a href="http://developer.android.com//guide/topics/manifest/provider-element.html">&lt;provider&gt;</a></code>元素中指定的授权码(<code>com.example.myapp.fileprovider</code>), 路径<code>myimages/</code>, 以及文件名。
p2-2-1-2-5 = 例如, 如果你根据本次课程中的代码片段指定了 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>，并且你为 <code>default_image.jpg</code>文件请求了一个content uri， <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>会返回下面的 URI:
#pre2-2-1-2-2
title2-2-2 = 共享一个文件
p2-2-2-1 = 一旦你已经配置了让你的应用通过content uri共享文件，你就可以响应别的应用对这些文件的请求。响应这些请求的其中一个很好的方式是在服务器端app，提供一个可以被其他应用调用的文件选择接口。 使用这种方式，就可以让一个客户端应用的用户从服务端app选择文件，然后再接收文件的 content uri。
p2-2-2-2 = 本次课程教你怎样在你的应用中创建一个文件选择 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>来响应文件请求。
sub_title2-2-2-1 = 接收文件请求
p2-2-2-1-1 = 接收响应客户端app的文件请求并且返回content URI， 你的应用应该提供一个提供文件选择功能的 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>。 客户端app通过调用<code><a href="http://developer.android.com//reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int)">startActivityForResult()</a></code>来结合包含 <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_PICK">ACTION_PICK</a></code>action的<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 来打开这个 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>。 当客户端app调用 <code><a href="http://developer.android.com//reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int)">startActivityForResult()</a></code>, 你的应用可以给客户端app返回一个结果，这个结果是以用户选择的文件的content URI的形式返回的。
p2-2-2-1-2 = 要想学习怎样在客户端app发送一个文件请求，请参考 <a href="http://developer.android.com/request-file.html">请求一个共享文件</a>有关的课程。
sub_title2-2-2-2 = 创建一个文件选择Activity
p2-2-2-2-1 = 要想配置这个文件选择 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>, 首先要在你的manifest中指定 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code> , 以及一个匹配<code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_PICK">ACTION_PICK</a></code>action 和<code><a href="http://developer.android.com//reference/android/content/Intent.html#CATEGORY_DEFAULT">CATEGORY_DEFAULT</a></code> and <code><a href="http://developer.android.com//reference/android/content/Intent.html#CATEGORY_OPENABLE">CATEGORY_OPENABLE</a></code> category的intent filter，并且要为你的app中提供给别的app的文件指定MIME类型过滤器。下面的片段展示了怎样指定一个新的 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code> 和intent filter:
#pre2-2-2-2-1
lead2-2-2-2-1 = 在代码中定义一个文件选择activity
p2-2-2-2-2 = 下一步, 定义一个 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code> 子类，这个activity展示了在内部存储中的<code>files/images/</code>目录下的文件，并且允许用户选择想要的文件。下面的片段展示了怎样定义这个 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code> ，并且相应用户的选择:
#pre2-2-2-2-2
sub_title2-2-2-3 = 响应文件选择
p2-2-2-3-1 = 一旦用户选择了一个共享文件，你的应用就需要确定哪一个文件被选择了，然后为这个文件生成一个content uri。 因为在这个 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>中使用<code><a href="http://developer.android.com//reference/android/widget/ListView.html">ListView</a></code>展示了可用文件，当用户点击 一个文件名，系统就会调用<code><a href="http://developer.android.com//reference/android/widget/AdapterView.OnItemClickListener.html#onItemClick(android.widget.AdapterView<?>, android.view.View, int, long)">onItemClick()</a></code>方法，在这个方法中你可以得到被选择的文件。
p2-2-2-3-2 = 在 <code><a href="http://developer.android.com//reference/android/widget/AdapterView.OnItemClickListener.html#onItemClick(android.widget.AdapterView<?>, android.view.View, int, long)">onItemClick()</a></code>方法中, 得到被选择文件的<code><a href="http://developer.android.com//reference/java/io/File.html">File</a></code> 对象 然后把它作为参数传递到<code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context, java.lang.String, java.io.File)">getUriForFile()</a></code>方法, 以及你在 <code><a href="http://developer.android.com//guide/topics/manifest/provider-element.html">&lt;provider&gt;</a></code> 元素为 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>指定的授权码。最终生成的 content URI 包含了这个授权码，一个代表了文件目录的路径片段(在 XML meta-data中指定), 以及包含后缀名的文件名。<code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code>是怎样根据XML meta-data来讲目录映射为路径节点的，这将会在 <a href="http://developer.android.com/setup-sharing.html#DefineMetaData">指定可共享的目录</a>中有讲解。
p2-2-2-3-3 = 下面的片段展示怎样检索被选择的文件以及怎样获得这个文件的content uri：
#pre2-2-2-3-1
p2-2-2-3-4 = 要记住，你只能为那些在包含了<code>&lt;paths&gt;</code>元素的meta-data文件中指定的目录下的文件创建content uri。就像在 <a href="http://developer.android.com/setup-sharing.html#DefineMetaData">指定共享目录</a>中讲解的那样。如果你为一个没有指定路径的<code><a href="http://developer.android.com//reference/java/io/File.html">File</a></code> 调用<code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context, java.lang.String, java.io.File)">getUriForFile()</a></code> 方法，你将会得到一个 <code><a href="http://developer.android.com//reference/java/lang/IllegalArgumentException.html">IllegalArgumentException</a></code>异常。
sub_title2-2-2-4 = 授予文件权限
p2-2-2-4-1 = 现在，你已经有了那些你想要共享的文件的content URI，你需要允许客户端app访问这个文件。 要想允许访问，就要先给客户端app授予访问权限，你需要把 content URI 添加到一个 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> ，然后在<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>设置权限标志。 你授予的权限是临时的并且在接收文件的应用的任务站结束的时候会自动取消。
p2-2-2-4-2 = 下面的代码段展示怎样给文件设置读权限：
#pre2-2-2-4-1
cc2-2-2-4-1 = <strong>警告:</strong> 调用 <code><a href="http://developer.android.com//reference/android/content/Intent.html#setFlags(int)">setFlags()</a></code> 方法是为你的文件授予临时访问权限的唯一安全方式，要避免对文件的content uri调用 <code><a href="http://developer.android.com//reference/android/content/Context.html#grantUriPermission(java.lang.String, android.net.Uri, int)">Context.grantUriPermission()</a></code> 方法，因为这个方法通过这个方法授予的权限，你只能通过 <code><a href="http://developer.android.com//reference/android/content/Context.html#revokeUriPermission(android.net.Uri, int)">Context.revokeUriPermission()</a></code>调用。
sub_title2-2-2-5 = 和请求的app共享文件
p2-2-2-5-1 = 要想实现和发送请求的app共享文件，需要传递一个包含content URI的 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>，以及权限到 <code><a href="http://developer.android.com//reference/android/app/Activity.html#setResult(int)">setResult()</a></code>方法。当 <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code> 结束时, 系统会发送一个包含了文件 content URI的 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 到客户端app。下面的代码段展示怎样实现它：
#pre2-2-2-5-1
p2-2-2-5-2 = 给用户提供一张方式可以在选择文件之后就立即返回到客户端app。实现这个功能的其中一个方式是提供一个 标记或者 <b>Done</b> 按钮。 然后给这个按钮的 <code><a href="http://developer.android.com//reference/android/view/View.html#attr_android:onClick">android:onClick</a></code> 属性指定一个关联的方法。在这个方法中, 调用 <code><a href="http://developer.android.com//reference/android/app/Activity.html#finish()">finish()</a></code>。例如：
#pre2-2-2-5-2
title2-2-3 =请求一个共享文件
p2-2-3-1 = 当一个app想要请求一个由其他应用共享的文件时，那个请求的app (客户端)通常会发送一个请求到那个共享文件的app(服务端)。在大部分情况下，这个请求通常会在服务端会打开一个<code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code> 来展示那些被共享的文件。用户选择一个文件，然后就会把文件的content URI返回给客户端app。
p2-2-3-2 = 本次课程会讲解，一个客户端app是怎样像服务端app请求一个文件的，怎样从服务端app接收文件的content URI，以及怎样使用content URI打开一个文件。
sub_title2-2-3-1 = 发送一个文件请求
p2-2-3-1-1 = 要想服务端app发送一个文件请求，客户端app需要结合<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>调用<code><a href="http://developer.android.com//reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int)">startActivityForResult</a></code> 方法，这个intent指明了类似 <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_PICK">ACTION_PICK</a></code>的action，以及客户端app可以处理的MIME类型。
p2-2-3-1-2 = 例如, 下面的代码段展示怎样向服务端app发送一个 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 来打开那个<code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>，这个activity在 <a href="http://developer.android.com/share-file.html#SendURI">共享一个文件</a>课程中有讲解:
#pre2-2-3-1-1
sub_title2-2-3-2 = 使用请求到的文件
p2-2-3-2-1 = 服务端app可以发送通过<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>来给客户端发送返回的content URI。<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 是在<code><a href="http://developer.android.com//reference/android/app/Activity.html#onActivityResult(int, int, android.content.Intent)">onActivityResult()</a></code>方法中被传递到客户端app的。一旦客户端app受到了文件的content URI，他就可以通过获得他的<code><a href="http://developer.android.com//reference/java/io/FileDescriptor.html">FileDescriptor</a></code>来访问这个文件。
p2-2-3-2-2 = 在这个过程中文件是安全的，因为content URI只是客户端app受到的数据的一部分。因为这个URI不包含目录的路径，客户端app不能够发现和打开位于服务端app的其他的文件。 只有客户端app可以访问这个文件，并且只限于服务器端授予的权限。这个权限是临时的，因此一旦客户端app的任务站完成的时候，这个文件子在服务端app之外是不可访问的。
p2-2-3-2-3 = 下面的片段说明客户端是怎样处理服务端app发送的<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 的，以及客户端app是怎样使用content URI得到<code><a href="http://developer.android.com//reference/java/io/FileDescriptor.html">FileDescriptor</a></code>的：
#pre2-2-3-2-1
p2-2-3-2-4 = 方法<code><a href="http://developer.android.com//reference/android/content/ContentResolver.html#openFileDescriptor(android.net.Uri, java.lang.String)">openFileDescriptor()</a></code>会返回一个文件的<code><a href="http://developer.android.com//reference/android/os/ParcelFileDescriptor.html">ParcelFileDescriptor</a></code>。从这个对象，客户端app可以得到一个 <code><a href="http://developer.android.com//reference/java/io/FileDescriptor.html">FileDescriptor</a></code> 对象, 使用它可以读取这个文件。
title2-2-4 =检索文件信息
p2-2-4-1 = 在客户端app想要方位一个拥有content URI的文件之前，客户端app会先从服务器端请求该文件的信息，包括文件的数据类型以及文件的大小。数据类型可以帮助客户端app来决定是否可以处理这个文件，文件的大小可以帮助客户端为文件设置缓冲区以及缓存。
p2-2-4-2 = 本节讲解怎样检索服务器端app的 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 来获取文集的MIME类型以及大小。
sub_title2-2-4-1 = 检索文件的 MIME 类型
p2-2-4-1-1 = 一个文件的数据类型可以让客户端app决定怎样处理这个文件的内容。要想获取提供了content URI的文件的数据类型，客户端app需要调用<code><a href="http://developer.android.com//reference/android/content/ContentResolver.html#getType(android.net.Uri)">ContentResolver.getType()</a></code>。这个方法返回文件的MIME 类型。默认情况下, <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 会根据后缀名来判断文件的MIME类型。
p2-2-4-1-2 = 下面的代码片段讲解客户端app是怎样在服务端返回content URI之后检索文件的MIME类型的：
#pre2-2-4-1-1
sub_title2-2-4-2 = 获得文件名和大小
p2-2-4-2-1 = <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html">FileProvider</a></code> 类有一个默认的实现方法 <code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code>，这个方法可以返回和  <code><a href="http://developer.android.com//reference/android/database/Cursor.html">Cursor</a></code>中相对应的content URI相关联的文件的名字和大小。这个默认的实现会返回两列：
dt2-2-4-2-1 = <code><a href="http://developer.android.com//reference/android/provider/OpenableColumns.html#DISPLAY_NAME">DISPLAY_NAME</a></code>
dd2-2-4-2-1 = 以 <code><a href="http://developer.android.com//reference/java/lang/String.html">String</a></code>的形式返回的文件名。这个值和<code><a href="http://developer.android.com//reference/java/io/File.html#getName()">File.getName()</a></code>方法返回的值相同。
dt2-2-4-2-2 = <code><a href="http://developer.android.com//reference/android/provider/OpenableColumns.html#SIZE">SIZE</a></code>
dd2-2-4-2-2 = 文件的字节大小，数据类型为 <code>long</code> ，这个值和  <code><a href="http://developer.android.com//reference/java/io/File.html#length()">File.length()</a></code>返回的值相同。
p2-2-4-2-2 = 通过把<code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html#query(android.net.Uri, java.lang.String[], java.lang.String, java.lang.String[], java.lang.String)">query()</a></code>方法中处理content URI之外的参数社会自为 <code>null</code>， 客户端app可以同时得到文件的 <code><a href="http://developer.android.com//reference/android/provider/OpenableColumns.html#DISPLAY_NAME">DISPLAY_NAME</a></code> 和 <code><a href="http://developer.android.com//reference/android/provider/OpenableColumns.html#SIZE">SIZE</a></code> 信息。例如，这个代码段获取了文件的 <code><a href="http://developer.android.com//reference/android/provider/OpenableColumns.html#DISPLAY_NAME">DISPLAY_NAME</a></code> 和 <code><a href="http://developer.android.com//reference/android/provider/OpenableColumns.html#SIZE">SIZE</a></code>，并且把它们分别展示在不同的<code><a href="http://developer.android.com//reference/android/widget/TextView.html">TextView</a></code>中:
#pre2-2-4-2-1
title2-3 = 使用NFC共享文件
p2-3-1 = Android允许你使用Android Bean文件传输功能来在设备之间传输大文件。这个功能有一个简单的API，并且允许用户在简单的触摸设备之后开始传输进程。 作为回应，Android Bean文件传输会自动从把一个文件从一个设备复制到另一个设备，并且在完成的时候提醒用户。
p2-3-2 = 使用 Android Beam 文件传输 API 处理大量数据， Android4.0(API 14)中介绍的Android Beam NDEF API用于传输向 URIs 或者其他小消息这类的小数据。 此外，Android Beam 是唯一一个Android NFC框架中可用的功能，你可以从 NFC标签中读取 NDEF信息。学习更多关于 Android Beam的内容,参考 <a href="http://developer.android.com//guide/topics/connectivity/nfc/nfc.html#p2p">使用Beaming NDEF 向别的设备发送消息</a>。更多关于NFC 框架的内容,参考 <a href="http://developer.android.com//guide/topics/connectivity/nfc/index.html">近场通讯</a> API 指南。
sub_title2-3-1 = 教程
dt2-3-1-1 = <b><a href="#c2-3-1">向其他设备发送文件</a></b>
dd2-3-1-1 = 学习怎样让你的应用可以向别的设备发送文件。
dt2-3-1-2 = <b><a href="c2-3-2">从别的设备接收文件</a></b>
dd2-3-1-2 = 学习怎样让你的应用可以接收别的设备发送的文件。
title2-3-1 = 向其他设备发送文件
p2-3-1-1 = 本节将会教你怎样设计你的应用从而能够使用Android Bean文件传输功能项其他设备发送大文件。要想发送问文件，你需要请求使用NFC 和外部存储的权限，需要测试来确保你的设备支持NFC，然后为Android Bean文件传出提供URI。
p2-3-1-2 = Android Beam 文件传输功能有下面的要求：
#ol
li2-3-1-1 = Android Beam 文件传输只能在Android 4.1 (API level 16) 及其以上才能传输大文件。
li2-3-1-2 = 你想要传输的文件必须要在外部存储。想要学习怎样使用外部存储，参考<a href="http://developer.android.com//guide/topics/data/data-storage.html#filesExternal">使用外部存储</a>。
li2-3-1-3 = 每个你想要传输的文件必须是可读写的。你可以通过调用<code><a href="http://developer.android.com//reference/java/io/File.html#setReadable(boolean)">File.setReadable(true,false)</a></code>来设置这个权限。
li2-3-1-4 = 你必须为你想要传输的文件提供一个URI。Android Bean文件传输不能够处理由<code><a href="http://developer.android.com//reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context, java.lang.String, java.io.File)">FileProvider.getUriForFile</a></code>生成的content URI。
sub_title2-3-1-1 = 在Manifest中声明该功能
p2-3-1-1-1 = 首先, 编辑你的manifest来声明权限以及你的应用需要的功能。
lead2-3-1-1-1 = 请求权限
p2-3-1-1-2 = 要想让你的app能够使用Android Bean文件传输，来使用NFC从外部存储发送文件，你必须在你的manifest中请求一下权限：
dt2-3-1-1-1 = <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#NFC">NFC</a></code>
dd2-3-1-1-1 = 让你的应用通过NFC发送数据。要指定这个权限，需要添加下面的元素作为<code><a href="http://developer.android.com//guide/topics/manifest/manifest-element.html">&lt;manifest&gt;</a></code> 元素的子元素:  <pre>     &lt;uses-permission android:name="android.permission.NFC" /&gt; </pre>
dt2-3-1-1-2 = <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE">READ_EXTERNAL_STORAGE</a></code>
dd2-3-1-1-2 = 让你的应用从外部存数读取内容。要指定这个权限，需要添加下面的元素作为 <code><a href="http://developer.android.com//guide/topics/manifest/manifest-element.html">&lt;manifest&gt;</a></code> 的子元素:  <pre>     &lt;uses-permission             android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; </pre>  <p class="note"> <strong>注意:</strong> 在 Android 4.2.2 (API level 17), 这个权限不是必须的。在Android之后的版本中，如果你的应用需要读取外部存储，那么你需要指定这个权限。在需要之前，现在就添加这个权限请求，这就可以保证向前兼容。</p>
lead2-3-1-1-2 = 指定 NFC 功能
p2-3-1-1-3 = 指定你的应用需要使用 NFC, 通过添加一个 <code><a href="http://developer.android.com//guide/topics/manifest/uses-feature-element.html">&lt;uses-feature&gt;</a></code> 元素作为<code><a href="http://developer.android.com//guide/topics/manifest/manifest-element.html">&lt;manifest&gt;</a></code> 的子元素。 把 <code>android:required</code> 属性设置为 <code>true</code> 来表明你的app只在NFC可用的时候需要这个功能。
p2-3-1-1-4 = 下面的代码展示怎样指定 <code><a href="http://developer.android.com//guide/topics/manifest/uses-feature-element.html">&lt;uses-feature&gt;</a></code> 元素:
#pre2-3-1-1-1
p2-3-1-1-5 = 注意，如果你的应用只把NFC作为可选的功能，但是在NFC不支持的时候仍然提供这个功能，你应该设置<code>android:required</code> 为 <code>false</code>, 然后再你的代码中测试 NFC 。
lead2-3-1-1-3 = 指定 Android Beam 文件传输
p2-3-1-1-6 = 因为 Android Beam文件传输仅仅在 Android 4.1 (API level 16) 及其以上才可用, 如果你的应用把Android Bean文件传输作为关键功能，你必须指定 <code><a href="http://developer.android.com//guide/topics/manifest/uses-sdk-element.html">&lt;uses-sdk&gt;</a></code> 元素，设置 <code><a href="http://developer.android.com//guide/topics/manifest/uses-sdk-element.html#min">android:minSdkVersion</a>="16"</code> 属性。否则，如果取药的话你可以设置<code><a href="http://developer.android.com//guide/topics/manifest/uses-sdk-element.html#min">android:minSdkVersion</a></code> 为其他的值, 然后再代码中测试这个平台版本，这些将会在下面的章节中讲解。
sub_title2-3-1-2 = 测试对Android Beam文件传输的支持
p2-3-1-2-1 = 在manifest中指定NFC是可选的，你需要使用一下元素：
#pre2-3-1-2-1
p2-3-1-2-2 = 如果你设置属性 <code><a href="http://developer.android.com//guide/topics/manifest/uses-feature-element.html#required">android:required</a>="false"</code>, 你必须在代码中测试NFC的支持性和Android Bean文件传出的支持性。
p2-3-1-2-3 = 要想在代码中测试Android Bean文件传输的支持性，开始要调用<code><a href="http://developer.android.com//reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String)">PackageManager.hasSystemFeature()</a></code>方法，并给他传递<code><a href="http://developer.android.com//reference/android/content/pm/PackageManager.html#FEATURE_NFC">FEATURE_NFC</a></code>参数来测试设备是否支持NFC。然后，通过检查<code><a href="http://developer.android.com//reference/android/os/Build.VERSION.html#SDK_INT">SDK_INT</a></code>的值来检查Android版本对Android Bean文件传输的支持性。如果支持Android Beam 文件传输，得到NFC controller的实例, 这样你就可以和NFC硬件通信。例如:
#pre2-3-1-2-2
sub_title2-3-1-3 = 创建一个提供文件的回调方法
p2-3-1-3-1 = 一旦你验证了设备支持Android Bean文件传输，添加一个系统的回调方法，在Android Bean文件传输监测到用户想要向别的NFC可用的设备上发送文件时，系统会调用这个方法。在这个回调方法中，返回一个<code><a href="http://developer.android.com//reference/android/net/Uri.html">Uri</a></code> 对象数组。 Android Beam 文件传输根据这些URI复制这些文件到接收文件的设备。
p2-3-1-3-2 = 要想添加这个回调方法, 需要实现 <code><a href="http://developer.android.com//reference/android/nfc/NfcAdapter.CreateBeamUrisCallback.html">NfcAdapter.CreateBeamUrisCallback</a></code> 接口，以及他的 <code><a href="http://developer.android.com//reference/android/nfc/NfcAdapter.CreateBeamUrisCallback.html#createBeamUris(android.nfc.NfcEvent)">createBeamUris()</a></code>方法。下面的代码段展示怎样操作：
#pre2-3-1-3-1
p2-3-1-3-3 = 一旦你实现了这个接口，通过调用<code><a href="http://developer.android.com//reference/android/nfc/NfcAdapter.html#setBeamPushUrisCallback(android.nfc.NfcAdapter.CreateBeamUrisCallback, android.app.Activity)">setBeamPushUrisCallback()</a></code>来为Android Bean文件传输提供这个回调方法。下面的代码段展示怎样操作:
#pre2-3-1-3-2
nc2-3-1-3-1 = <strong>注意:</strong>你也可以通过你的应用的<code><a href="http://developer.android.com//reference/android/nfc/NfcAdapter.html">NfcAdapter</a></code>实例直接给NFC框架提供一个 <code><a href="http://developer.android.com//reference/android/net/Uri.html">Uri</a></code> 对象的数组。如果在触发NFC Touch事件之前你可以定义要传输的URI，就可以选择这种方式。更多的关于这种方式的内容请参考<code><a href="http://developer.android.com//reference/android/nfc/NfcAdapter.html#setBeamPushUris(android.net.Uri[], android.app.Activity)">NfcAdapter.setBeamPushUris()</a></code>。
sub_title2-3-1-4 = 指定要发送的文件
p2-3-1-4-1 = 要向另外一个NFC可用的设备发送一个或多个文件，要得到每个文件的URI (带有<code>file</code>模式的URI) ，然后把这些URI添加到 一个 <code><a href="http://developer.android.com//reference/android/net/Uri.html">Uri</a></code> 对象的数组。要想发送一个文件，你必须对这个文件有永久的读取权限。例如，下面的片段展示怎样从文件名获得文件的URI，然后把这个URI添加到数组中：
#pre2-3-1-4-1
title2-3-2 = 从别的设备接收文件
p2-3-2-1 = Android Beam文件传输复制文件到接收文件的设备上的一个特定的目录。它也是使用Android Media Scanne来扫描这些文件，然后将媒体文件的记录添加到<code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code> 提供者。本节内容展示你怎样响应文件复制完成时间，以及怎样在接收文件的设备上查找这个复制过来的文件。 T
sub_title2-3-2-1 = 响应一个展示数据的请求
p2-3-2-1-1 = 当 Android Beam 文件传输结束复制文件到接收设备时，它会发送一个notification，这个notification中包含了一个带有<code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_VIEW">ACTION_VIEW</a></code>action，你传输的第一个文件的MIME类型，指向第一个传输文件的URI的<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 。当用户点击这个 notification时, 这个 intent 会发送到系统中。要想让你的应用响应这个intent，需要为响应这个intent的<code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>对应的<code><a href="http://developer.android.com//guide/topics/manifest/activity-element.html">&lt;activity&gt;</a></code> 元素添加一个 <code><a href="http://developer.android.com//guide/topics/manifest/intent-filter-element.html">&lt;intent-filter&gt;</a></code> 。在 <code><a href="http://developer.android.com//guide/topics/manifest/intent-filter-element.html">&lt;intent-filter&gt;</a></code> 元素中, 添加下面的子元素:
dt2-3-2-1-1 = <code><a href="http://developer.android.com//guide/topics/manifest/action-element.html">&lt;action android:name="android.intent.action.VIEW" /&gt;</a></code>
dd2-3-2-1-1 = 匹配从notification发送的  <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_VIEW">ACTION_VIEW</a></code> intent。
dt2-3-2-1-2 = <code><a href="http://developer.android.com//guide/topics/manifest/category-element.html">&lt;category android:name="android.intent.category.CATEGORY_DEFAULT" /&gt;</a></code>
dd2-3-2-1-2 = 匹配一个没有明确类别的 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>。
dt2-3-2-1-3 = <code><a href="http://developer.android.com//guide/topics/manifest/data-element.html">&lt;data android:mimeType="<i>mime-type</i>" /&gt;</a></code>
dd2-3-2-1-3 = 匹配一个 MIME 类型。只需要指定那些你的应用可以处理的MIME类型。
p2-3-2-1-2 = 例如, 下面的片段展示怎样添加一个intent filter来触发这个activity<code>com.example.android.nfctransfer.ViewActivity</code>:
#pre2-3-2-1-1
nc2-3-2-1-1 = <strong>注意:</strong> Android Beam 文件传输不是<code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_VIEW">ACTION_VIEW</a></code> intent的唯一资源。其他的在接收设备上的应用也可以发送一个带有这个action的 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>。 我们将会在课程 <a href="http://developer.android.com/#GetDirectory">从 content URI获取目录</a>中介绍怎样处理这种情况.
sub_title2-3-2-2 = 请求文件权限
p2-3-2-2-1 = 读取一个 Android Beam 文件传输复制到接收设备上的文件，需要请求<code><a href="http://developer.android.com//reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE">READ_EXTERNAL_STORAGE</a></code>权限。例如:
#pre2-3-2-2-1
p2-3-2-2-2 = 如果你想要复制传输的文件到你的应用的存储区域，代替的，你需要请求 <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#WRITE_EXTERNAL_STORAGE">WRITE_EXTERNAL_STORAGE</a></code> 权限。 <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#WRITE_EXTERNAL_STORAGE">WRITE_EXTERNAL_STORAGE</a></code> 包含了 <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE">READ_EXTERNAL_STORAGE</a></code>权限。
nc2-3-2-2-1 = <strong>注意:</strong>在 Android 4.2.2 (API level 17), 这个权限 <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE">READ_EXTERNAL_STORAGE</a></code> 这个权限是必须的。在android平台后面的版本中在任何情况下都需要指定这个权限。在开始需要之前就把权限添加上来确保向前兼容。
p2-3-2-2-3 = 因为你的应用可以支配他的内部存储，在复制传输文件到内部存储的时候不需要指定写权限。
sub_title2-3-2-3 = 得到被复制文件的目录
p2-3-2-3-1 = Android Beam 文件传输会在一次传输中将所有的文件复制到接收设备上。 通过Android Bean文件传输notification发送的<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 中的URI指向第一个传输的文件。然而，你的应用也有可能受到一个除Android Bean文件传输之外的资源发送的 <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_VIEW">ACTION_VIEW</a></code> intent，要想觉得怎样处理接收到的 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>,你需要检测他的模式和授权码。
p2-3-2-3-2 = 要想得到URI的scheme, 需要调用 <code><a href="http://developer.android.com//reference/android/net/Uri.html#getScheme()">Uri.getScheme()</a></code>方法。下面的代码片段展示怎样根据scheme来正确的处理URI：
#pre2-3-2-3-1
lead2-3-2-3-1 = 从文件 URI得到目录
p2-3-2-3-3 = 如果接受到的 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 包含了一个文件URI, 这个 URI包含了文件的绝对文件名，包括目录的全路径和文件名。 对于 Android Beam 文件传输, 如果有的话，这个目录路径指向其他的传输文件的位置。要得到这个目录路径，得到URI的路径部分，它包含了所有的URI，并带有 <code>file:</code> 前缀。创建一个路径部分的 <code><a href="http://developer.android.com//reference/java/io/File.html">File</a></code> 对象，然后得到 <code><a href="http://developer.android.com//reference/java/io/File.html">File</a></code>的富路径:
#pre2-3-2-3-2
lead2-3-2-3-2 = 从content URI中得到目录
p2-3-2-3-4 = 如果接收到的<code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> 包含一个content URI, 这个 URI可能会指向一个目录，并且文件名存储在<code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code> 内容提供者中。 你可以根据测试的URI 授权码来获取 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code>的授权码。 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code> 的content URI可能来自于 Android Beam 文件传输或者其他的app，但是，在这两种情况下你都可以得到一个目录以及这个content URI对应的文件名。
p2-3-2-3-5 = 你可能也会受到一个 <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_VIEW">ACTION_VIEW</a></code> intent，这个intent包含一个内容提供者的content URI而不是 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code>。在这种情况下，这个content URI 就不包含<code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code> 授权码, 并且这个 content URI 通常情况下不指向一个目录。
nc2-3-2-3-1 = <strong>注意:</strong> 对于 Android Beam 文件传输，你会受到一个在  <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_VIEW">ACTION_VIEW</a></code> intent 中的content URI，如果第一个传入的文件的MIME类型是 "audio/*", "image/*", 或者 "video/*", 表明这个文件是媒体相关的。Android Beam 文件传输会在存储传输文件的目录运行Media Scanner来给传输的文件添加索引。Media Scanner 把它的结果写进 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code> content provider, 然后把第一个文件的content URI 传递回Android Beam 文件传输。这个content URI 就是你在notification中的到的那个 <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code>。要想得到第一个文件的目录， 你可以使用content URI从<code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code>中得到。
lead2-3-2-3-3 = 确定内容提供者
p2-3-2-3-6 = 要想确定你是否可以从content URI检索出目录，通过调用<code><a href="http://developer.android.com//reference/android/net/Uri.html#getAuthority()">Uri.getAuthority()</a></code>方法得到URI的授权码来确定和这个URI相关的内容提供者。结果有两个可能的值：
dt2-3-2-3-1 = <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html#AUTHORITY">MediaStore.AUTHORITY</a></code>
dd2-3-2-3-1 = 这个 URI对应一个文件或者那些被 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code>追踪的文件。 从  <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code>中检索完整的文件名, 然后从文件名中得到目录。
dt2-3-2-3-2 = 其他的授权码
dd2-3-2-3-2 = 来自于其他的内容提供者的content URI。展示和这个content URI相关的数据,但是不获取文件目录。
p2-3-2-3-7 = 要想得到一个 <code><a href="http://developer.android.com//reference/android/provider/MediaStore.html">MediaStore</a></code> content URI对应的目录, 需要执行一个查询，查询重要指定接收的<code><a href="http://developer.android.com//reference/android/net/Uri.html">Uri</a></code> 参数对应的 content URI ，以及 映射的<code><a href="http://developer.android.com//reference/android/provider/MediaStore.MediaColumns.html#DATA">MediaColumns.DATA</a></code> 列。返回的<code><a href="http://developer.android.com//reference/android/database/Cursor.html">Cursor</a></code> 包含了通过这个URI代表的文件的全路径和文件名。这个路径也包含了所有其他的通过Android Bean 文件传输复制到该设备的文件。
p2-3-2-3-8 = 下面的片段展示怎样测试content URI对应的授权码，以及怎样获取传输文件的路径和文件名：
#pre2-3-2-3-3
p2-3-2-3-9 = 想要学习更多关于从一个content provider获取数据的内容，参考教程 <a href="http://developer.android.com//guide/topics/providers/content-provider-basics.html#SimpleQuery">从提供者中检索数据</a>。
