
#		**********************************************************************************************************
#		Getting Started
#		**********************************************************************************************************

title1 = 入门指南
p1-1 = 欢迎来到Android开发者培训教程。在这里你可以找到一系列的课程，这些课程讲解了如何使用可以重用于你的应用示例代码来完成特定的任务。这些课程分为几组， 左侧菜单栏的顶层菜单就是。
p1-2 = 这是第一组, 入门指南, 教你最基本的Android应用开发。如果你是一个Android应用开发新手，你应该按顺序依次完成这些课程：

#		**********************************************************************************************************
#		Building Your First App
#		**********************************************************************************************************

title1-1 = 创建你的首个A应用
p1-1-1 = 欢迎来到Android应用程序开发！
p1-1-2 = 本课程教你如何创建你的第一个android 应用。你将会学到怎样创建一个Android项目，并且运行你的应用程序的调试版本。你还会学到一些Android应用设计的一些基本原理，包括怎样创建一个简单的用户界面并处理用户输入。 
sub_title1-1-1 = 搭建开发环境
p1-1-3 = 在开始本课程之前，请确认你已经搭建好了开发环境。你需要：
p1-1-4 = 1. 下载 <a href="http://developer.android.com/sdk/index.html">Android Studio</a>.
p1-1-5 = 2. 使用<a href="http://developer.android.com/tools/help/sdk-manager.html">SDK Manager</a>下载最新的SDK tools 和 platforms。
nc1-1-1 = 注意: 尽管大部分的培训课程期望你使用Android Studio, 一些程序包含二选一的说明， 作为替代方法，可以在命令行使用SDK tools。
p1-1-6 = 这个课程以创建一个小的Android 应用的教程的方式来教你一些关于Android开发的基本知识，因此你应该按部就班的学习本课程。

#		**********************************************************************************************************
#		Creating an Android Project
#		**********************************************************************************************************

title1-1-1 = 创建Android项目
p1-1-1-1 = 一个Android项目包含了你的Android应用的所有源代码文件。
p1-1-1-2 = 本节展示了怎样使用Android Studio或者在命令行使用SDK Tools来创建一个新的项目。
nc1-1-1-1 = 注意: 你应该已经装好了Android SDK，如果你使用Android Studio, 那么你就应该已经装上了Android Studio。如果这些你都没有，在学习本节之前，请参考向导来安装Android SDK。
p1-1-1-3 = 使用 Android Studio, 创建一个新项目:
li1-1-1-1-1 = 如果你没有打开一个项目, 在 <strong>欢迎</strong> 界面， 点击 <strong>New Project</strong>。
li1-1-1-1-2 = 如果你已经打开了一个界面, 从 File 菜单, 选择 <strong>New Project</strong>。
p1-1-1-4 = 下面配置你的新项目，填写在图片1中字段然后点击<strong>Next</strong>.
p1-1-1-5 = 如果你使用和图片中相同的值，那么跟着这个课程步骤非常的简单。
li1-1-1-2-1 = <strong>Application Name</strong> 给用户展示的应用名。这个项目我们使用 "My First App"。
li1-1-1-2-2 = <strong>Company domain</strong> 提供了包名限定； Android Studio将会记住每个新项目的这个限定。
li1-1-1-2-3 = <strong>Package name</strong> 是项目的全限定名（命名规则和Java编程相同）。包名在Android系统中必须是唯一的。你可以独立的使用应用名或者公司域名来 <strong>Edit</strong> 修改这个值。
li1-1-1-2-4 = <strong>Project location</strong> 项目文在在你的系统中存放的位置。
p1-1-1-6 = 在 <strong>Select the form factors your app will run on</strong>下面, 选择平台是Phone 还是 Table。
p1-1-1-7 = 选项 <strong>Minimum SDK</strong>, 选择 <strong>API 8: Android 2.2 (Froyo)</strong>。
p1-1-1-8 = Minimum Required SDK 是你的应用程序支持的Android最低版本对应的API级别。为了支持更多的设备，你应该设置为能够提供你的应用程序核心功能所需要的特性的最低版本。如果你的应用的一些特性只在某些android新版本上支持，但是对这个应用的核心功能来讲不重要，那么你可以只在支持这个特性的版本上面开启这个特性（将在支持平台版本中讨论）。
p1-1-1-9 = 剩下所有的其他选项 (TV, Wear, and Glass) 不勾选，然后点击 <strong>Next</strong>。
p1-1-1-10 = 在 <strong>Add an activity to your project</strong>下面, 选择 <strong>Blank Activity</strong> 然后点击<strong>Next</strong>。
p1-1-1-11 = 在 <strong>Describe the new activity for your project</strong>下面, 不要修改默认的内容，然后点击<strong>Finish</strong>。
p1-1-1-12 = 现在你的Android项目是基本的“Hello World”应用，项目中包含了一些默认的文件。花点时间来看一下比较重要的文件内容： 
dt1-1-1-1 = <code>app/src/main/res/layout/activity_my.xml</code>
dd1-1-1-1 = 这个是在你使用Android Studio创建项目时添加的Activity的XML布局文件。按照创建新项目的步骤，Android Studio提供了布局文件的两种视图， 一种是文本形式，另一种是UI界面。这个文件包含了一些默认的设置和一个TextVeiw元素，展示消息“Hello World”。
dt1-1-1-2 = <code>app/src/main/java/com.mycompany.myfirstapp/MyActivity.java</code>
dd1-1-1-2 = 当创建新项目的流程结束时，将会打开该文件的一个新标签。 当你选择这个文件时，可以看到被创建的Activity 类的定义。当你编译并且运行这个应用时，这个Activity类会启动这个activity并且加载布局文件显示“Hello World!”。
dt1-1-1-3 = <code>app/src/res/AndroidManifest.xml</code>
dd1-1-1-3 = 这个manifest文件描述了这个应用的基本特性，并且定义了他的每个组件。在跟着这篇教程学习是你还会遇到这个文件，并且为你的应用添加更多的组件。
dt1-1-1-4 = <code>app/build.gradle</code>
dd1-1-1-4 = Android Studio 使用Gradle来编译和构建你的应用。你的项目的每个模块都会有一个<code>build.gradle</code>文件。通常情况下你只需关心某个模块的<code>build.gradle</code>文件，在本例中是app或者应用模块。在这里设置应用构建依赖，包括<code>defaultConfig</code>的设置：
li1-1-1-3-1 = <code>compiledSdkVersion</code> 是你的应用编译时使用的版本。默认是android sdk可以使用的最新版本。(应该是Android 4.1 或以上；如果没有以上可使用的版本，你必须使用SDK Manager安装一个。)你仍然可以构建你的应用去支持老版本，但是设置为最新的版本，你就可以使用一些新的特性，并且在新设备上面可以提高用户体验。
li1-1-1-3-2 = <code>applicationId</code> 是创建应用过程中使用的应用的全限定包名。
li1-1-1-3-3 = <code>minSdkVersion</code> 是在创建新项目过程中指定的SDK最小版本。这是你的应用支持的最早的版本。
li1-1-1-3-4 = <code>targetSdkVersion</code> 指定你测试应用程序使用的Android最高版本。当有Android新版本可用时，你应该在新版本中测试你的应用，并且将该值修改为最新的API等级，然后就可以使用心得平台特性。参考“不同平台版本的支持” 获取更多信息。
p1-1-1-13 = 参考“使用Gradle构建你的项目”获取更多关于Gradle的信息。
p1-1-1-14 = 注意<code>/res</code> 子目录同样包含应用的资源：
dt1-1-1-5 = <code>drawable-hdpi/</code>
dd1-1-1-5 =  drawable 对象的目录文件 (例如bitmaps)，被设计用于高分辨率(hdpi)的屏幕。 其他的drawable目录用于其他不同分辨率的屏幕。当你运行默认的应用时，你可以看到 ic_launcher.png 显示出来。
dt1-1-1-6 = <code>layout/</code>
dd1-1-1-6 = 存放你的应用的用户界面的文件件，像上面讨论的activity_my.xml，它描述了MyActivity类的基本布局。
dt1-1-1-7 = <code>values/</code>
dd1-1-1-7 = 存放其他的XML的文件夹，这些XML包含了一些资源集合，例如字符串和颜色的定义。 strings.xml 文件定义了在你运行默认的app是展示的"Hello world!" 字符串。
p1-1-1-15 = 运行这个app, 继续学习<a href="#c1-1-2">下一节</a>.
sub_title1-1-1-2 = 使用命令行工具创建项目
p1-1-1-16 = 如果你没有使用Android Studio 工具，你可以从命令行掉用SDK tools来创建android项目：
p1-1-1-17 = 将目录切换到Android SDK\u2019s <code>tools/</code> 所在路径.
p1-1-1-18 = 执行:
p1-1-1-19 = 这将会列出你已经下载的所有可用的Android SDK平台组件。找到那个你想用于编译项目的平台。记录下target id。我们推荐使用尽可能高的版本。你仍然可以构建你的应用来支持老版本，但是设置为最新版本可以使你的应用在新设备上有更好的体验。
p1-1-1-20 = 如果你没有看到任何的目标列表, 你需要使用Android SDK Manager去安装一些。参考 <a href="http://developer.android.com/sdk/installing/adding-packages.html">Adding SDK Packages</a>.
p1-1-1-21 = 执行:
p1-1-1-22 = 修改 <code>&lt;target-id&gt;</code> 为target列表中的某个target id(上一步)然后修改<code>&lt;path-to-workspace&gt;</code> 为保存你的Android 项目的地址
tc1-1-1-1 = 提示: 将 platform-tools/ 和 tools/ 目录添加到环境变量PATH中。
p1-1-1-23 = 现在你的android项目是一个基础的“Hello World”应用，它包含了一些默认的文件。要想运行这个App，请继续学习<a href="#c1-1-2">下一节</a>。

#		**********************************************************************************************************
#		Running Your App
#		**********************************************************************************************************

title1-1-2 = 运行你的应用
p1-1-2-1 = 如果你按照<a href="#c1-1-1">上一节</a> 的内容创建了一个Android应用，它包含了一些能让你的应用直接运行起来的默认的“Hello World”资源文件。
p1-1-2-2 = 怎样运行你的应用取决于两件事：你使用有运行的真是的android设备和你是否使用了Android Studio。本节内容教你怎样使用Android Studio或者使用命令行在一个真实设备或者模拟器上安装和运行应用。
sub_title1-1-2-1 = 在真实设备上运行
p1-1-2-3 = 如果你有一个运行的Android设备，下面演示怎样安装和运行App。
p1-1-2-4 = 配置你的设备
li1-1-2-1-1 = 使用USB连接线将你的设备连接到开发环境。如果你在Windows环境下开发，你也许需要为你的设备安装适当的USB驱动。关于安装驱动的帮助，参考OEM USB驱动文档。
li1-1-2-1-2 = 在你的设备上开启 <strong>USB debugging</strong> 。
li1-1-2-2-1 = 在许多Android 3.2或者更老的设备上，你可以在<strong>Settings > Applications > Development</strong>下找到该设置。
li1-1-2-2-2 = 在Android4.0及以上，是在 <strong>Settings > Developer options</strong>下。
nc1-1-2-1 = 注意: 在Android4.2及以上，<strong>Developer options</strong>默认情况下是隐藏的。要想让它可见，到 <strong>Settings > About phone</strong> 然后点击 <strong>Build number</strong> 七次。然后返回前面的界面找到<strong>Developer options</strong>。
p1-1-2-5 = 从Android Studio安装应用
li1-1-2-3-1 = 选择你的项目中的某个文件然后点击工具栏上的 <code>Run</code> 。
li1-1-2-3-2 = 在出现的<strong>Choose Device</strong> 窗口, 选择<strong>Choose a running device</strong> radio 按钮, 选择你的设备然后点击 <strong>OK</strong> 。
p1-1-2-6 = Android Studio 会在链接的设备上安装这个app并且打开它。
p1-1-2-7 = 使用命令行运行app
li1-1-2-4-1 = 切换目录到Android项目的根目录然后执行：
li1-1-2-4-2 = 确保Android SDK<code>platform-tools/</code> 目录应配置到PATH环境变量中，然后执行：
li1-1-2-4-3 = 在你的设备上找到 MyFirstApp 然后打开它。
p1-1-2-8 = 以上就是怎样构建你的App并且在设备上运行！开始开发，请继续学习 <a href="#c1-1-3">下一节</a>。
sub_title1-1-2-2 = 在模拟器上运行
p1-1-2-9 = 无论你是使用Android Studio还是命令行，要想在模拟器上运行app首先你需要创建一个Android虚拟设备（AVD）。AVD是一个android模拟器的配置，这样你就可以模拟一个真实的设备。
p1-1-2-10 = 创建一个 AVD
li1-1-2-5-1 = 加载Android Virtual Device Manager:
li1-1-2-6-1 = 在Android Studio, 选择 <strong>Tools > Android > AVD Manager</strong>, 或者点击在工具栏中的AVD Manager 图标。
li1-1-2-6-2 = 或者, 从命令行，切换目录到<code>&lt;sdk&gt;/tools/</code> 然后执行:
nc1-1-2-2 = 注意: 从命令行启动的AVD Manager的版本和Android Studio中的不一样，所以下面的指令不在适用。
li1-1-2-5-2 = 在 AVD Manager主界面(图片 1), 点击 <strong>Create Virtual Device</strong>。
li1-1-2-5-3 = 在Select Hardware 窗口, 选择一个设备配置，例如Nexus 6, 然后点击<strong>Next</strong>。
li1-1-2-5-4 = 选择期望的AVD系统版本然后点击<strong>Next</strong>。
li1-1-2-5-5 = 核实配置设置，然后点击<strong>Finish</strong>。
p1-1-2-11 = 关于 AVD的更多信息, 参考使用AVD Manager管理AVD。
p1-1-2-12 = 从Android Studio运行程序
li1-1-2-7-1 = 在Android Studio, 选择你的项目然后点击工具栏上的<strong>Run</strong>。
li1-1-2-7-2 = 在 <strong>Choose Device</strong> 窗口,点击<strong>Launch emulator</strong> radio 按钮。
li1-1-2-7-3 = 从 <strong>Android virtual device</strong> 下拉菜单中， 选择你已经创建好的模拟器，然后点击<strong>OK</strong>。
p1-1-2-13 = 模拟器启动需要花费一些时间。你应该解锁屏幕。完成之后My First App会出现在模拟器屏幕上。
p1-1-2-14 = 使用命令行运行app
li1-1-2-8-1 = 切换目录到Android项目的根目录然后执行：
li1-1-2-8-2 = 确认Android SDK <code>platform-tools/</code> 目录已经配置到PATH环境变量中，然后执行:
li1-1-2-8-3 = 在模拟器上，找到 MyFirstApp 然后打开它。
p1-1-2-15 = 以上就是怎样在模拟器上构建和运行你的Android应用！想开始开发，请继续学习  <a href="#c1-1-3">下一节</a>。

#		**********************************************************************************************************
#		Building a Simple User Interface
#		**********************************************************************************************************

title1-1-3 = 构建一个简单的用户界面
p1-1-3-1 = 在本节中，你创建一个XML布局，里面包括一个Text 文本和一个按钮。在下一节中，你的应用程序将会在点击按钮的时候响应用户点击，并且发送text文本到另一个Activity中。
p1-1-3-2 = android应用的图形用户界面通过使用View和ViewGroup的层叠来实现。View对象是普通的UI小部件例如按钮，文本框。ViewGroup对象时不可见的视图容器，用于定义如何布局子视图，例如网格和纵向的列表。
p1-1-3-3 = Android提供View和ViewGroup的子类XML标签，因此你可以使用层叠的UI标签来创建你的UI界面。
p1-1-3-4 = 布局都是ViewGroup的子类。在本次的联系中你将会使用到LinearLayout。
sub_title1-1-3-1 = 创建一个线性布局
li1-1-3-1-1-1-1 = 在Android Studio中, 在 <code>res/layout</code> 目录打开 <code>activity_my.xml</code> 文件。 
li1-1-3-1-1-1-2 = 当你创建这个项目时你选择BlankActivity模板提供了以RelativeLayout为根视图，并包含TextView子视图的<code>activity_my.xml</code> 文件。
li1-1-3-1-1-2-1 = 在 <strong>Preview</strong> 版面, 点击Hide图标关闭Preview版面。
li1-1-3-1-1-2-2 = 在 Android Studio中, 当你打开一个布局文件，首先展示的是Preview面板。点击面板中的元素在设计面板打开 WYSIWYG 工具。在本节，你将会直接操作XML。
li1-1-3-1-1-3 = 删除%lt;TextView&gt; 元素。
li1-1-3-1-1-4 = 修改&lt;RelativeLayout&gt; 元素为&lt;LinearLayout&gt;。
li1-1-3-1-1-5 = 添加android:orientation 属性并且设置为<code>"horizontal"</code>。
li1-1-3-1-1-6 = 删除<code>android:padding</code>属性和<code>tools:context</code> 属性。
p1-1-3-1-1 = 结果像这样：
p1-1-3-1-2 = LinearLayout 是一个ViewGroup(iewGroup的子类)，它让子视图水平或者垂直布局，这同过 android:orientation 属性来指定。LinearLayout的每个子视图按照他在XML中的顺序在屏幕上显示。
p1-1-3-1-3 = 另外两个属性，android:layout_width 和 android:layout_height,对于每个View都是必须的属性，他们指定了View的尺寸。
p1-1-3-1-4 = 因为LinearLayout是布局的根视图，他应该覆盖全部的应用可用的屏幕区域，通过设置为 "match_parent"来实现。这个值表示该View应该扩张他的宽度和高度来匹配它的父View的宽度和高度。
p1-1-3-1-5 = Layout属性的更多信息参考 Layout指南。
sub_title1-1-3-2 = 添加一个文本框
p1-1-3-2-1 = 和其他任何的View对象一样,你必须明确的定义XML属性来指定EditText对象的属性。
li1-1-3-2-1-1 = 在 <code>activity_my.xml</code> 文件中, 在 &gt;LinearLayout&lt; 元素内部, 定义一个&gt;EditText&lt; 元素， 并且给它添加值为<code>@+id/edit_message</code>的<code>id</code>属性。
li1-1-3-2-1-2 = 指定 <code>layout_width</code> 和 <code>layout_height</code> 属性未<code>wrap_content</code>。
li1-1-3-2-1-3 = 指定<code>hint</code> 属性，内容为<code>edit_message</code>。
p1-1-3-2-2 = &lt;EditText&gt; 元素应该按照如下阅读:
p1-1-3-2-3 = 这是你添加的&lt;EditText&gt; 的属性:
dt1-1-3-2-1 = <code>android:id</code>
dd1-1-3-2-1-1 = 这个属性指定了View的唯一标识，这样你就可以在你的App内核代码中通过id来引用这个View，例如读取和操作这个对象(在下一节中将会有详细的介绍) 。
dd1-1-3-2-1-2 = 当你在XML中引用其他资源对象的时候需要使用at 标志 (<code>@</code>)。后面跟着资源类型 (在这里是<code>id</code>), 一个斜杠, 然后是资源的名字(<code>edit_message</code>)。
dd1-1-3-2-1-3 = 只有在你第一次定义一个资源Id的时候需要在资源类型前面使用+号(<code>+</code>)。当你编译这个App时，SDK tools会会使用这个Id名在你的项目的gen/R.java文件中创建一个新的资源ID，这个资源ID指向EditText元素。通过这种方式声明一次资源ID，其他的对这个Id的引用都不需要使用+号。只有在指定一个新的资源Id的时候需要使用+号，但是对于具体的资源像String或者layout不需要使用。参考侧边导航获取关于资源对象的更多信息。
dt1-1-3-2-2 = <code>android:layout_width</code> 和 <code>android:layout_height</code>
dd1-1-3-2-2 = 代替使用具体的width和height，<code>"wrap_content"</code> 这个值指定了视图的大小应该适应视图的内容所需要的大小。如果你使用 <code>"match_parent"</code>, 那么 <code>EditText</code> 元素将会充满屏幕，因为它将会匹配父LinearLayout的大小。更多信息请参考Layouts指南。
dt1-1-3-2-3 = <code>androi:hint</code>
dd1-1-3-2-3 = 当文本字段为空时，默认显示的字符串。代替在使用硬编码指定一个字符串值，<code>"@string/edit_message"</code> 的值指向一个在特殊文件中指定的string资源。因为这是指向一个确定的资源(不仅仅是一个标示符), 所以不需要+ 号。然而，因为你还没有定义这个String资源，一开始将会看到编译错误。在下一节中通过定义String资源可以解决这个错误。
nc1-1-3-2-1 = 注意: 这个string资源和元素Id有相同的名字： <code>edit_message</code>。然而，资源的引用通常通过资源类型划分(例如id或者string)，因此使用相同的名字不会引起冲突。
sub_title1-1-3-3 = 添加String资源
p1-1-3-3-1 = 默认情况下，你的Android项目会包含一个string资源文件<code>res/values/strings.xml</code>。这里，你将会添加一个新的string名为<code>"edit_message"</code>，然后把value设置为"Enter a message"。
li1-1-3-3-1-1 = 在 Android Studio中, 从<code>res/values</code> 目录, 打开 <string>strings.xml</code>。
li1-1-3-3-1-2 = 添加一行名为<code>"edit_message"</code> 值为 "Enter a message"的字符串。
li1-1-3-3-1-3-1 = 添加一行名为<code>"button_send"</code> 值为"Send"的字符串。
li1-1-3-3-1-3-2 = 在下一节中你将会创建使用这些字符串的按钮。
li1-1-3-3-1-4 = 移除<code>"hello world"</code> 这行字符串。
p1-1-3-3-2 = 最终的<code>strings.xml</code> 如下:
p1-1-3-3-3 = 在用户界面的的文本，通常每个字符串定义为资源。String 资源可以使你在同一个位置管理所以的UI文本，这样就可以更加简单的查找和修改文本。将这些字符串提出来，也可以让你的应用本地化到不同的语言，只要指定对应的string资源即可。
p1-1-3-3-4 = 更多关于使用资源文件本地化应用到不同的语言的信息，参考支持不同设备的有关课程。
sub_title1-1-3-4 = 添加一个按钮
li1-1-3-4-1-1 = 在 Android Studio中, 从 <code>res/layout</code> 目录, 编辑 <code>activity_my.xml</code> 文件。
li1-1-3-4-1-2 = 在<code>&lt;LinearLayout&gt;</code> 元素内部, 定义一个<code>&lt;Button&gt;</code> 元素 直接跟在 <code>&lt;EditText&gt;</code> 元素的后面。
li1-1-3-4-1-3 = 把按钮的width和height设置为<code>"wrap_content"</code>，这样按钮就有可以自适应按钮上文本内容的大小。
li1-1-3-4-1-4 = 使用<code>android:text</code>属性定义按钮上的文本标签；设置它的值为你在前面章节中定义的<code>button_send</code> 字符串资源。
p1-1-3-4-1 = 你的&lt;LinearLayout&gt;应该如下：
nc1-1-3-4-1 = 注意: 这个按钮不需要android:id 属性,因为在activity代码中不需要引用它。
p1-1-3-4-2 = 目前为止，布局文件中定义了 <code>EditText</code> 和 <code>Button</code>。小控件的大小自适应他们内容所需要的大小，如图2所示。
p1-1-3-4-3 = 按钮看起来没问题，但是文本框好像文本框有点问题，因为也许用户想输入更多的内容。让文本框自动适应未使用的屏幕宽度看起来不错。你可以在<code>LinearLayout</code>上使用weight属性实现，只需使用 <code>android:layout_weight</code>属性即可。
p1-1-3-4-4 = 这个weight值是一个数值，他指定了每个视图应该占用的剩余空间的大小，与兄弟视图的数量有关。这点有点像饮料配方材料的数量："两份碳酸水，一份果汁" 这意味着饮料里面三分之二是碳酸水。例如，如果你把一个View的weight属性设置为2，另外一个设置为1，那么总和是3，因此第一个View占屏幕剩余空间的2/3，第二个view填充剩下的空间。如果你添加了第三个view然后给它的weight属性设置为1，那么第一个view（weight为2的）就占有剩余空间的1/2，那么剩下的两个分别占有1/4的空间。
p1-1-3-4-5 = 所有view默认的weight值是0，因此如果你只指定一个view的weight的值大于0，那么这个视图将会占有除其他view所需空间之外剩下的所有空间。
sub_title1-1-3-5 = 让输入框填充屏幕大小
p1-1-3-5-1 = 要让你的<code>EditText</code>元素沾满剩余空间，你需要这样做：
li1-1-3-5-1-1 = 打开 <code>activity_my.xml</code> 文件, 设置 <code>&lt;EditText&gt;</code> 元素的 <code>layout_weight</code> 属性值为1。
li1-1-3-5-1-2-1 = 并且, 设置 <code>&lt;EditText&gt;</code> 元素的 <code>layout_width</code>属性值为<code>0dp</code>。
li1-1-3-5-1-2-2 = 为了提高layout的效率，当你指定了weight的时候，你需要修改EditText的width为0(0dp)。把width设置为0 可以提高layout的性能，是因为使用"wrap_content"作为宽度需要系统做额外的不需要的计算，因为weight的值也需要另外的宽度计算来填充剩余的空间。
li1-1-3-5-1-2-3 = 图3展示了你给<code>EditText</code>元素添加了weight之后的结果。
p1-1-3-5-2 = 现在你完成的<code>activity_my.xml</code> 布局文件呢内容应该如下：
sub_title1-1-3-6 = 运行你的App
p1-1-3-6-1 = 这个布局由默认的Activity类引用，这个类是在你创建这个项目的时候由SDK tools创建的。 运行你的app来看最终结果：
li1-1-3-6-1-1 = 在Android Studio中, 点击工具栏上的<strong>Run</strong>。
li1-1-3-6-1-2 = 或者在命令行，切换目录到项目的根目录然后执行：
p1-1-3-6-2 = 继续 <a href="#c1-1-4">下一节</a>来学习怎样响应按钮点击，从text读取内容，开启其他的activity，等更多的内容。

#		**********************************************************************************************************
#		Starting Another Activity
#		**********************************************************************************************************

title1-1-4 = 打开其他的 Activity
p1-1-4-1 = 在完成了 <a href="#c1-1-3">上一节</a>的学习之后, 你已经有了一个app， 这个app展示了一个带有一个文本框和一个按钮的activity(单个屏幕)。在本节中，在点击第二个按钮的时候将会打开一个新的activity。
sub_title1-1-4-1 = 响应第二个按钮
li1-1-4-1-1-1 = 在Android Studio中, 从 <code>res/layout</code> 目录,编辑<code>activity_my.xml</code> 文件。
li1-1-4-1-1-2-1 = 找到 <code>&lt;Button&gt;</code> 元素,添加 <code>android:onClick</code> 属性。
li1-1-4-1-1-2-2 = <code>android:onClick</code> 的值是 <code>"sendMessage"</code>, 是在你activity中的方法的名字，在你点击了按钮之后系统将会调用这个方法。
li1-1-4-1-1-3 = 在 <code>java/com.mycompany.myfirstapp</code> 目录, 打开MyActivity.java 文件。
li1-1-4-1-1-4-1 = 在 MyActivity 类中, 添加如下的<code>sendMessage()</code> 方法块。
li1-1-4-1-1-4-2 = 为了让系统把这个方法和在<code>android:onClick</code>中指定的方法名对应，方法名必须如下所示，另外，这个方法应该：
li1-1-4-1-2-1 = 是 public的
li1-1-4-1-2-2 = 返回值为void
li1-1-4-1-2-3 = 只有一个为View的参数 (指向被点击的View)
p1-1-4-2 = 下面, 你需要填充这个方法，读取文本的内容，并且把文本内容传递到其他的activity。
sub_title1-1-4-2 = 创建一个Intent
li1-1-4-2-1-1-1 = 在 <code>MyActivity.java</code>中, <code>sendMessage()</code> 方法内部, 创建一个Intent使用下面的代码来开启一个名为<code>DisplayMessageActivity</code> 的activity：
nc1-1-4-2-1 = 注意: 对于<code>DisplayMessageActivity</code> 的引用将会抛出一个错误如果你使用像Android Studio这样的IDE的时候，因为这个类还不存在。现在忽略这个错误；你马上就可以创建这个类了。
li1-1-4-2-1-1-2 = 这里使用的构造函数有两个参数：
li1-1-4-2-2-1 = Context 作为第一个参数(使用它是因为Activity类是Context的子类) 
li1-1-4-2-2-2 = app组件中系统将传递这个Intent到了类(这个例子中是将要被打开的activity)
li1-1-4-2-1-1-3 = Android Studio 指示你必须导入Intent类。
li1-1-4-2-1-2 = 在文件头, 引入 Intent 类:
tc1-1-4-2-1 = 提示: 在 Android Studio中, 使用 Alt + Enter (在Mac中是option + return ) 来引入缺失的类。
li1-1-4-2-1-3 = 在 <code>sendMessage()</code> 方法内, 使用 <code>findViewById()</code> 来获取 EditText 元素。
li1-1-4-2-1-4-1 = 在文件头, 引入<code>EditText</code> 类。
li1-1-4-2-1-4-2 =  在 Android Studio中, 使用 Alt + Enter (在Mac中是option + return ) 来引入缺失的类。
li1-1-4-2-1-5-1 = 把文本付给本地变量 <code>message</code> , 然后使用the <code>putExtra()</code> 方法添加text值到intent中。
li1-1-4-2-1-5-2 = Intent可以持有键值对类型的数据被称为Extras。<code>putExtra()</code> 方法第一个参数是key，第二个参数是值。
li1-1-4-2-1-6-1 = 在 <code>MyActivity</code> 类的顶部,添加 <code>EXTRA_MESSAGE</code> 的定义如下:
li1-1-4-2-1-6-2 = 为了在下一个activity中获取extra值，你应该使用public的常量来定义extra的可以。把你包名作为extras的key的前缀是很好的做法。这样在你的应用和其他app交互的时候就可以保证你的key的唯一性，
li1-1-4-2-1-7 = 在<code>sendMessage()</code> 方法中,调用 <code>startActivity()</code> 方法结束这个intent, 把在步骤1中创建的intent传递给它。
p1-1-4-2-1 = 加上新的代码，完成的被第二个按钮调用的 <code>sendMessage()</code> 方法如下：
p1-1-4-2-2 = 系统接收了这个调用并且打开了一个被这个Intent指定的Activity的实例。现在你需要创建<code>DisplayMessageActivity</code> 类来让app运行。
sub_title1-1-4-3 = 创建第二个 Activity
p1-1-4-3-1 = 所以的Activity的子类必须实现<code>onCreate()</code> 方法。 在这个方法中activity接收带有message的intent，然后提取message。并且在 <code>onCreate()</code> 方法中必须使用<code>setContentView()</code>方法来定义activity布局。这是activity初始化activity组件的地方。
p1-1-4-3-2 = 使用 Android Studio创建一个新的Activity
p1-1-4-3-3 = 在你创建一个新的Activity的时候Android Studio 会包含 <code>onCreate()</code> 方法的存根。
li1-1-4-3-1-1 = 在Android Studio中, 在java 目录, 选择包, <strong>com.mycompany.myfirstapp</strong>, 右击, 选择 <strong>New > Activity > Blank Activity</strong>。
li1-1-4-3-1-2-1 = 在 <strong>Choose options</strong> 窗口, 填写activity的详细信息:
li1-1-4-3-2-1 = <strong>Activity Name</strong>: DisplayMessageActivity
li1-1-4-3-2-2 = <strong>Layout Name</strong>: activity_display_message
li1-1-4-3-2-3 = <strong>Title</strong>: My Message
li1-1-4-3-2-4 = <strong>Hierarchical Parent</strong>: com.mycompany.myfirstapp.MyActivity
li1-1-4-3-2-5 = <strong>Package name</strong>: com.mycompany.myfirstapp
li1-1-4-3-1-2-2 = 点击 <strong>Finish</strong>.
li1-1-4-3-1-3-1 = 打开 <code>DisplayMessageActivity.java</code> 文件。
li1-1-4-3-1-3-2 = 类中已经包含了所需的 <code>onCreate()</code> 方法的实现。在后面你将会修改这个方法实现。它同时也包含了<code>onOptionsItemSelected()</code>方法实现,这个方法用于处理action bar的行为。现在暂时不要修改这两个方法。
li1-1-4-3-1-4-1 = 删除 <code>onCreateOptionsMenu()</code> 方法。
li1-1-4-3-1-4-2 = 在这个实例中不需要它。
p1-1-4-3-4 = 如果你是使用 Android Studio开发, 你现在就可以运行app了，但是什么都没有发生。点击第二个按钮打开第二个activity，它使用了模板提供的默认的“Hello World”布局。 后面你将会修改这个activity展示自定义的视图。 
p1-1-4-3-5 = 不使用Android Studio创建activity
p1-1-4-3-6 = 如果你使用不同的 IDE 或者使用命令行工具, 按照如下操作:
li1-1-4-3-2-1 = 在项目的<code>src/</code>目录创建一个名为 <code>DisplayMessageActivity.java</code> 的新文件，next to the original <code>MyActivity.java</code> file.
li1-1-4-3-2-2 = 在文件中添加下面的代码：
nc1-1-4-3-1 = 注意: 如果你使用的是其他的IDE而不是Android Studio，你的项目中不包含<code>setContentView()</code>所需要的<code>setContentView()</code>布局。这没什么问题，因为你在后面可以修改它从而不使用这个布局。
li1-1-4-3-2-3 = 找到你的 <code>strings.xml</code> 文件, 像下面一样添加activity的title：
li1-1-4-3-2-4 = 找到manifest 文件, <code>AndroidManifest.xml</code>, 在 <code>Application </code>元素中, 为<code>DisplayMessageActivity</code>类添加<code>&lt;activity&gt;</code> 元素, 如下所示:
p1-1-4-3-7 =  <code>android:parentActivityName</code> 属性声明了在这个app的逻辑结构中这个activity的父activity的名字。系统将会使用这值实现默认的导航行为，例如在android 4.1（API16）及以上的向上导航。在旧版本中你也可以实现相同的导航操作，只需要使用Support liberary并且添加如下所示的 <code>&lt;meta-data&gt;</code> 元素。
nc1-1-4-3-2 = 注意: 你的Android SDK 应该已经包含了最新的 Android Support Library, 这在你添加Android SDK包的时候就已经安装好了。当在Android Studio中使用模板的时候，Support Library会自动被添加到你的app项目中 (你可以在android dependencies列表中看到library的jar文件)。如果你没有使用Android Studio, 你需要按照配置Support Library的步骤手动的添加这个library到你的项目，然后再返回到这里。
p1-1-4-3-8 = 如果你是使用其他的IDE而不是Android Studio，不要担心这个app还不能编译。在后面你将很快会修改这个activity来展示自定义的视图。
sub_title1-1-4-4 = 接收 Intent
p1-1-4-4-1 = 每一个 <code>Activity</code> 都是通过<code>Intent</code>调用, 不管用户是以怎样的方式导航到这里。你都可以通过调用<code>getIntent()</code> 方法得到开启这个Activity的intent，并且接收intent携带的数据。
li1-1-4-4-1-1 = 在<code>java/com.mycompany.myfirstapp</code> 目录, 修改 <code>DisplayMessageActivity.java</code> 文件。
li1-1-4-4-1-2 = 在<code>onCreate()</code> 方法中, 删除下面的行:
li1-1-4-4-1-3 = 得到intent 并把它复制给局部变量。
li1-1-4-4-1-4-1 = 在文件的开始, 导入 Intent 类。
li1-1-4-4-1-4-2 = 在 Android Studio中, 使用 Alt + Enter (在Mac中是option + return)来导入需要的类。
li1-1-4-4-1-5 = 使用<code>getStringExtra()</code>方法提取通过<code>MyActivity</code>传递过来的消息。
sub_title1-1-4-5 = 展示消息
li1-1-4-5-1-1 = 在 <code>onCreate()</code> 方法, 创建一个<code>TextView</code> 对象。
li1-1-4-5-1-2 = 使用<code>setText()</code>设置文本内容。
li1-1-4-5-1-3 = 然后添加<code>TextView</code>， 并把它传递给 <code>setContentView()</code>，让它作为这个activity布局的根视图。
li1-1-4-5-1-4-1 = 在文件的开始, 导入<code>TextView</code> 类。
li1-1-4-5-1-4-2 = 在 Android Studio中, 使用 Alt + Enter (在Mac中是option + return)来导入需要的类。
p1-1-4-5-1 = 已经完成的<code>DisplayMessageActivity</code>中的 <code>onCreate()</code> 方法如下：
p1-1-4-5-2 = 你现在可以运行这个app了。当它打开的时候，在文本框中输入一些消息，点击Send，输入的消息会在第二个activity中显示。
p1-1-4-5-3 = 到此为止, 你已经创建了你的第一个Android app!
p1-1-4-5-4 = 想要学习更多的内容, 点击下面的链接到下一课。
#		**********************************************************************************************************
#		Adding the Action Bar
#		**********************************************************************************************************

title1-2 = Adding the Action Bar
p1-2-1 = The action bar is one of the most important design elements you can implement for your app's activities. It provides several user interface features that make your app immediately familiar to users by offering consistency between other Android apps. Key functions include:
li1-2-1-1 = A dedicated space for giving your app an identity and indicating the user's location in the app.
li1-2-1-2 = Access to important actions in a predictable way (such as Search).
li1-2-1-3 = Support for navigation and view switching (with tabs or drop-down lists).
p1-2-2 = This training class offers a quick guide to the action bar's basics. For more information about action bar's various features, see the Action Bar guide.

#		**********************************************************************************************************
#		Setting Up the Action Bar
#		**********************************************************************************************************

title1-2-1 = Setting Up the Action Bar
p1-2-1-1 = In its most basic form, the action bar displays the title for the activity and the app icon on the left. Even in this simple form, the action bar is useful for all activities to inform users about where they are and to maintain a consistent identity for your app.
p1-2-1-2 = Setting up a basic action bar requires that your app use an activity theme that enables the action bar. How to request such a theme depends on which version of Android is the lowest supported by your app. So this lesson is divided into two sections depending on which Android version is your lowest supported.
sub_title1-2-1-1 = Support Android 3.0 and Above Only
p1-2-1-1-1 = Beginning with Android 3.0 (API level 11), the action bar is included in all activities that use the <code>Theme.Holo</code> theme (or one of its descendants), which is the default theme when either the <code>targetSdkVersion</code> or <code>minSdkVersion</code> attribute is set to <code>"11"</code> or greater.
p1-2-1-1-2 = So to add the action bar to your activities, simply set either attribute to <code>11</code> or higher. For example:
nc1-2-1-1 = Note: If you've created a custom theme, be sure it uses one of the <code>Theme.Holo</code> themes as its parent. For details, see Styling the Action Bar.
p1-2-1-1-3 = Now the <code>Theme.Holo</code> theme is applied to your app and all activities show the action bar. That's it.
sub_title1-2-1-2 = Support Android 2.1 and Above
p1-2-1-2-1 = Adding the action bar when running on versions older than Android 3.0 (down to Android 2.1) requires that you include the Android Support Library in your application.
p1-2-1-2-2 = To get started, read the Support Library Setup document and set up the <strong>v7 appcompat</strong> library (once you've downloaded the library package, follow the instructions for Adding libraries with resources).
p1-2-1-2-3 = Once you have the Support Library integrated with your app project:
li1-2-1-2-1-1 = Update your activity so that it extends <code>ActionBarActivity</code>. For example:
li1-2-1-2-1-2 = In your manifest file, update either the <code>&lt;application&gt;</code> element or individual <code>&lt;activity&gt;</code> elements to use one of the Theme.AppCompat themes. For example:
nc1-2-1-2-1 = Note: If you've created a custom theme, be sure it uses one of the <code>Theme.AppCompat</code> themes as its parent. For details, see Styling the Action Bar.
p1-2-1-2-4 = Now your activity includes the action bar when running on Android 2.1 (API level 7) or higher.
p1-2-1-2-5 = Remember to properly set your app's API level support in the manifest:

#		**********************************************************************************************************
#		Adding Action Buttons
#		**********************************************************************************************************

title1-2-2 = Adding Action Buttons
p1-2-2-1 = The action bar allows you to add buttons for the most important action items relating to the app's current context. Those that appear directly in the action bar with an icon and/or text are known as action buttons. Actions that can't fit in the action bar or aren't important enough are hidden in the action overflow.
sub_title1-2-2-1 = Specify the Actions in XML
p1-2-2-1-1 = All action buttons and other items available in the action overflow are defined in an XML <code>menu resource</code>. To add actions to the action bar, create a new XML file in your project's <code>res/menu/</code> directory.
p1-2-2-1-2 = Add an <code>&lt;item&gt;</code> element for each item you want to include in the action bar. For example:
p1-2-2-1-3 = This declares that the Search action should appear as an action button when room is available in the action bar, but the Settings action should always appear in the overflow. (By default, all actions appear in the overflow, but it's good practice to explicitly declare your design intentions for each action.)
p1-2-2-1-4 = The icon attribute requires a resource ID for an image. The name that follows <code>@drawable/</code> must be the name of a bitmap image you've saved in your project's <code>res/drawable/</code> directory. For example, "<code>@drawable/ic_action_search</code>" refers to <code>ic_action_search.png</code>. Likewise, the title attribute uses a string resource that's defined by an XML file in your project's <code>res/values/</code> directory, as discussed in Building a Simple User Interface.
nc1-2-2-1-1 = Note: When creating icons and other bitmap images for your app, it's important that you provide multiple versions that are each optimized for a different screen density. This is discussed more in the lesson about Supporting Different Screens.
p1-2-2-1-5 = <strong>If your app is using the Support Library</strong> for compatibility on versions as low as Android 2.1, the showAsAction attribute is not available from the android: namespace. Instead this attribute is provided by the Support Library and you must define your own XML namespace and use that namespace as the attribute prefix. (A custom XML namespace should be based on your app name, but it can be any name you want and is only accessible within the scope of the file in which you declare it.) For example:
sub_title1-2-2-2 = Add the Actions to the Action Bar
p1-2-2-2-1 = To place the menu items into the action bar, implement the <code>onCreateOptionsMenu()</code> callback method in your activity to inflate the menu resource into the given <code>Menu</code> object. For example:
sub_title1-2-2-3 = Respond to Action Buttons
p1-2-2-3-1 = When the user presses one of the action buttons or another item in the action overflow, the system calls your activity's <code>onOptionsItemSelected()</code> callback method. In your implementation of this method, call <code>getItemId()</code> on the given MenuItem to determine which item was pressed\u2014the returned ID matches the value you declared in the corresponding <code>&lt;item&gt;</code> element's android:id attribute.
sub_title1-2-2-4 = Respond to Action Buttons
p1-2-2-4-1 = When the user presses one of the action buttons or another item in the action overflow, the system calls your activity's <code>onOptionsItemSelected()</code> callback method. In your implementation of this method, call <code>getItemId()</code> on the given <code>MenuItem</code> to determine which item was pressed\u2014the returned ID matches the value you declared in the corresponding <code>&lt;item&gt;</code> element's <code>android:id</code> attribute.
sub_title1-2-2-5 = Add Up Button for Low-level Activities
p1-2-2-5-1 = All screens in your app that are not the main entrance to your app (activities that are not the "home" screen) should offer the user a way to navigate to the logical parent screen in the app's hierarchy by pressing the Up button in the action bar.
p1-2-2-5-2 = When running on Android 4.1 (API level 16) or higher, or when using <code>ActionBarActivity</code> from the Support Library, performing Up navigation simply requires that you declare the parent activity in the manifest file and enable the Up button for the action bar.
p1-2-2-5-3 = For example, here's how you can declare an activity's parent in the manifest:
p1-2-2-5-4 = Then enable the app icon as the Up button by calling <code>setDisplayHomeAsUpEnabled()</code>:
p1-2-2-5-5 = Because the system now knows <code>MainActivity</code> is the parent activity for <code>DisplayMessageActivity</code>, when the user presses the Up button, the system navigates to the parent activity as appropriate\u2014you do not need to handle the Up button's event.
p1-2-2-5-6 = For more information about up navigation, see Providing Up Navigation.

#		**********************************************************************************************************
#		Styling the Action Bar
#		**********************************************************************************************************

title1-2-3 = Styling the Action Bar
p1-2-3-1 = The action bar provides your users a familiar and predictable way to perform actions and navigate your app, but that doesn't mean it needs to look exactly the same as it does in other apps. If you want to style the action bar to better fit your product brand, you can easily do so using Android's style and theme resources.
p1-2-3-2 = Android includes a few built-in activity themes that include "dark" or "light" action bar styles. You can also extend these themes to further customize the look for your action bar.
nc1-2-3-1 = Note: If you are using the Support Library APIs for the action bar, then you must use (or override) the Theme.AppCompat family of styles (rather than the Theme.Holo family, available in API level 11 and higher). In doing so, each style property that you declare must be declared twice: once using the platform's style properties (the android: properties) and once using the style properties included in the Support Library (the appcompat.R.attr properties\u2014the context for these properties is actually your app). See the examples below for details.
sub_title1-2-3-1 = Use an Android Theme
p1-2-3-1-1 = Android includes two baseline activity themes that dictate the color for the action bar:
li1-2-3-1-1-1 = <code>Theme.Holo</code> for a "dark" theme.
li1-2-3-1-1-2 = <code>Theme.Holo.Light</code> for a "light" theme.
p1-2-3-1-2 = You can apply these themes to your entire app or to individual activities by declaring them in your manifest file with the <code>android:theme</code> attribute for the <code>&lt;application&gt;</code> element or individual <code>&lt;activity&gt;</code> elements.
p1-2-3-1-3 = For example:
p1-2-3-1-4 = You can also use a dark action bar while the rest of the activity uses the light color scheme by declaring the <code>Theme.Holo.Light.DarkActionBar</code> theme.
p1-2-3-1-5 = When using the Support Library, you must instead use the <code>Theme.AppCompat</code> themes:
li1-2-3-1-1-1 = <code>Theme.AppCompat</code> for the "dark" theme.
li1-2-3-1-1-2 = <code>Theme.AppCompat.Light</code> for the "light" theme.
li1-2-3-1-1-3 = <code>Theme.AppCompat.Light.DarkActionBar</code> for the light theme with a dark action bar.
p1-2-3-1-6 = Be sure that you use action bar icons that properly contrast with the color of your action bar. To help you, the Action Bar Icon Pack includes standard action icons for use with both the Holo light and Holo dark action bar.
sub_title1-2-3-2 = Customize the Background
p1-2-3-2-1 = To change the action bar background, create a custom theme for your activity that overrides the <code>actionBarStyle</code> property. This property points to another style in which you can override the <code>background</code> property to specify a drawable resource for the action bar background.
p1-2-3-2-2 = If your app uses <code>navigation tabs</code> or the <code>split action bar</code>, then you can also specify the background for these bars using the <code>backgroundStacked</code> and <code>backgroundSplit</code> properties, respectively.
cc1-2-3-2-1 = Caution: It's important that you declare an appropriate parent theme from which your custom theme and style inherit their styles. Without a parent style, your action bar will be without many style properties unless you explicitly declare them yourself.
p1-2-3-2-3 = For Android 3.0 and higher only
p1-2-3-2-4 = When supporting Android 3.0 and higher only, you can define the action bar's background like this:
p1-2-3-2-5 = Then apply your theme to your entire app or individual activities:
p1-2-3-2-6 = For Android 2.1 and higher
p1-2-3-2-7 = When using the Support Library, the same theme as above must instead look like this:
p1-2-3-2-8 = Then apply your theme to your entire app or individual activities:
sub_title1-2-3-3 = Customize the Text Color
p1-2-3-3-1 = To modify the color of text in the action bar, you need to override separate properties for each text element:
li1-2-3-3-1-1 = Action bar title: Create a custom style that specifies the textColor property and specify that style for the <code>titleTextStyle</code> property in your custom <code>actionBarStyle</code>.
nc1-2-3-3-1 = Note: The custom style applied to <code>titleTextStyle</code> should use <code>TextAppearance.Holo.Widget.ActionBar</code>.Title as the parent style.
li1-2-3-3-1-2 = Action bar tabs: Override <code>actionBarTabTextStyle</code>. in your activity theme.
li1-2-3-3-1-3 = Action buttons: Override <code>actionMenuTextColor</code> in your activity theme.
p1-2-3-3-2 = For Android 3.0 and higher only
p1-2-3-3-3 = When supporting Android 3.0 and higher only, your style XML file might look like this:
p1-2-3-3-4 = For Android 2.1 and higher
p1-2-3-3-5 = When using the Support Library, your style XML file might look like this:
sub_title1-2-3-4 = Customize the Tab Indicator
p1-2-3-4-1 = To change the indicator used for the <code>navigation tabs</code>, create an activity theme that overrides the <code>actionBarTabStyle</code> property. This property points to another style resource in which you override the <code>background</code> property that should specify a state-list drawable.
nc1-2-3-4-1 = Note: A state-list drawable is important so that the tab currently selected indicates its state with a background different than the other tabs. For more information about how to create a drawable resource that handles multiple button states, read the State List documentation.
p1-2-3-4-2 = For example, here's a state-list drawable that declares a specific background image for several different states of an action bar tab:
p1-2-3-4-3 = For Android 3.0 and higher only
p1-2-3-4-4 = When supporting Android 3.0 and higher only, your style XML file might look like this:
p1-2-3-4-5 = For Android 2.1 and higher
p1-2-3-4-6 = When using the Support Library, your style XML file might look like this:

#		**********************************************************************************************************
#		Overlaying the Action Bar
#		**********************************************************************************************************

title1-2-4 = Overlaying the Action Bar
p1-2-4-1 = By default, the action bar appears at the top of your activity window, slightly reducing the amount of space available for the rest of your activity's layout. If, during the course of user interaction, you want to hide and show the action bar, you can do so by calling <code>hide()</code> and <code>show()</code> on the ActionBar. However, this causes your activity to recompute and redraw the layout based on its new size.
p1-2-4-2 = To avoid resizing your layout when the action bar hides and shows, you can enable overlay mode for the action bar. When in overlay mode, your activity layout uses all the space available as if the action bar is not there and the system draws the action bar in front of your layout. This obscures some of the layout at the top, but now when the action bar hides or appears, the system does not need to resize your layout and the transition is seamless.
tc1-2-4-1 = Tip: If you want your layout to be partially visible behind the action bar, create a custom style for the action bar with a partially transparent background, such as the one shown in figure 1. For information about how to define the action bar background, read <a href="#c1-2-3">Styling the Action Bar</a>.
sub_title1-2-4-1 = Enable Overlay Mode
p1-2-4-1-1 = To enable overlay mode for the action bar, you need to create a custom theme that extends an existing action bar theme and set the <code>android:windowActionBarOverlay</code> property to <code>true</code>.
p1-2-4-1-2 = For Android 3.0 and higher only
p1-2-4-1-3 = If your <code>minSdkVersion</code> is set to 11 or higher, your custom theme should use <code>Theme.Holo</code> theme (or one of its descendants) as your parent theme. For example:
p1-2-4-1-4 = For Android 2.1 and higher
p1-2-4-1-5 = If your app is using the Support Library for compatibility on devices running versions lower than Android 3.0, your custom theme should use <code>Theme.AppCompat</code> theme (or one of its descendants) as your parent theme. For example:
p1-2-4-1-6 = Also notice that this theme includes two definitions for the <code>windowActionBarOverlay</code> style: one with the <code>android:</code> prefix and one without. The one with the android: prefix is for versions of Android that include the style in the platform and the one without the prefix is for older versions that read the style from the Support Library.
sub_title1-2-4-2 = Specify Layout Top-margin
p1-2-4-2-1 = When the action bar is in overlay mode, it might obscure some of your layout that should remain visible. To ensure that such items remain below the action bar at all times, add either margin or padding to the top of the view(s) using the height specified by <code>actionBarSize</code>. For example:
p1-2-4-2-2 = If you're using the Support Library for the action bar, you need to remove the <code>android:</code> prefix. For example:
p1-2-4-2-3 = In this case, the <code>?attr/actionBarSize</code> value without the prefix works on all versions, including Android 3.0 and higher.

#		**********************************************************************************************************
#		Supporting Different Devices
#		**********************************************************************************************************

title1-3 = Supporting Different Devices
p1-3-1 = Android devices come in many shapes and sizes all around the world. With a wide range of device types, you have an opportunity to reach a huge audience with your app. In order to be as successful as possible on Android, your app needs to adapt to various device configurations. Some of the important variations that you should consider include different languages, screen sizes, and versions of the Android platform.
p1-3-2 = This class teaches you how to use basic platform features that leverage alternative resources and other features so your app can provide an optimized user experience on a variety of Android-compatible devices, using a single application package (APK).

#		**********************************************************************************************************
#		Supporting Different Languages
#		**********************************************************************************************************

title1-3-1 = Supporting Different Languages
p1-3-1-1 = It\u2019s always a good practice to extract UI strings from your app code and keep them in an external file. Android makes this easy with a resources directory in each Android project.
p1-3-1-2 = If you created your project using the Android SDK Tools (read Creating an Android Project), the tools create a <code>res/</code> directory in the top level of the project. Within this <code>res/</code> directory are subdirectories for various resource types. There are also a few default files such as <code>res/values/strings.xml</code>, which holds your string values.
sub_title1-3-1-1 = Create Locale Directories and String Files
p1-3-1-1-1 = To add support for more languages, create additional <code>values</code> directories inside <code>res/</code> that include a hyphen and the ISO language code at the end of the directory name. For example, <code>values-es/</code> is the directory containing simple resourcess for the Locales with the language code "es". Android loads the appropriate resources according to the locale settings of the device at run time. For more information, see Providing Alternative Resources.
p1-3-1-1-2 = Once you\u2019ve decided on the languages you will support, create the resource subdirectories and string resource files. For example:
p1-3-1-1-3 = Add the string values for each locale into the appropriate file.
p1-3-1-1-4 = At runtime, the Android system uses the appropriate set of string resources based on the locale currently set for the user's device.
p1-3-1-1-5 = For example, the following are some different string resource files for different languages.
p1-3-1-1-6 = English (default locale), <code>/values/strings.xml:</code>
p1-3-1-1-7 = Spanish, <code>/values-es/strings.xml:</code>
p1-3-1-1-8 = French, <code>/values-fr/strings.xml:</code>
nc1-3-1-1-1 = Note: You can use the locale qualifier (or any configuration qualifer) on any resource type, such as if you want to provide localized versions of your bitmap drawable. For more information, see Localization.
sub_title1-3-1-2 = Use the String Resources
p1-3-1-2-1 = You can reference your string resources in your source code and other XML files using the resource name defined by the <code>&lt;string&gt;</code> element's <code>name</code> attribute.
p1-3-1-2-2 = In your source code, you can refer to a string resource with the syntax <code>R.string.&lt;string_name&gt;</code>. There are a variety of methods that accept a string resource this way.
p1-3-1-2-3 = For example:
p1-3-1-2-4 = In other XML files, you can refer to a string resource with the syntax <code>@string/&lt;string_name&gt;</code> whenever the XML attribute accepts a string value.
p1-3-1-2-5 = For example:

#		**********************************************************************************************************
#		Supporting Different Screens
#		**********************************************************************************************************

title1-3-2 = Android categorizes device screens using two general properties: size and density. You should expect that your app will be installed on devices with screens that range in both size and density. As such, you should include some alternative resources that optimize your app\u2019s appearance for different screen sizes and densities.
p1-3-2-1 = Android categorizes device screens using two general properties: size and density. You should expect that your app will be installed on devices with screens that range in both size and density. As such, you should include some alternative resources that optimize your app\u2019s appearance for different screen sizes and densities.
li1-3-2-1-1 = There are four generalized sizes: small, normal, large, xlarge
li1-3-2-1-2 = And four generalized densities: low (ldpi), medium (mdpi), high (hdpi), extra high (xhdpi)
p1-3-2-2 = To declare different layouts and bitmaps you'd like to use for different screens, you must place these alternative resources in separate directories, similar to how you do for different language strings.
p1-3-2-3 = Also be aware that the screens orientation (landscape or portrait) is considered a variation of screen size, so many apps should revise the layout to optimize the user experience in each orientation.
sub_title1-3-2-1 = Create Different Layouts
p1-3-2-1-1 = To optimize your user experience on different screen sizes, you should create a unique layout XML file for each screen size you want to support. Each layout should be saved into the appropriate resources directory, named with a -<code>&lt;screen_size&gt;</code> suffix. For example, a unique layout for large screens should be saved under <code>res/layout-large/</code>.
nc1-3-2-1-1 = Note: Android automatically scales your layout in order to properly fit the screen. Thus, your layouts for different screen sizes don't need to worry about the absolute size of UI elements but instead focus on the layout structure that affects the user experience (such as the size or position of important views relative to sibling views).
p1-3-2-1-2 = For example, this project includes a default layout and an alternative layout for large screens:
p1-3-2-1-3 = The file names must be exactly the same, but their contents are different in order to provide an optimized UI for the corresponding screen size.
p1-3-2-1-4 = Simply reference the layout file in your app as usual:
p1-3-2-1-5 = The system loads the layout file from the appropriate layout directory based on screen size of the device on which your app is running. More information about how Android selects the appropriate resource is available in the Providing Resources guide.
p1-3-2-1-6 = As another example, here's a project with an alternative layout for landscape orientation:
p1-3-2-1-7 = By default, the <code>layout/main.xml</code> file is used for portrait orientation.
p1-3-2-1-8 = If you want to provide a special layout for landscape, including while on large screens, then you need to use both the <code>large</code> and <code>land</code> qualifier:
nc1-3-2-1-2 = Note: Android 3.2 and above supports an advanced method of defining screen sizes that allows you to specify resources for screen sizes based on the minimum width and height in terms of density-independent pixels. This lesson does not cover this new technique. For more information, read Designing for Multiple Screens.
sub_title1-3-2-2 = Create Different Bitmaps
p1-3-2-2-1 = You should always provide bitmap resources that are properly scaled to each of the generalized density buckets: low, medium, high and extra-high density. This helps you achieve good graphical quality and performance on all screen densities.
p1-3-2-2-2 = To generate these images, you should start with your raw resource in vector format and generate the images for each density using the following size scale:
li1-3-2-2-1-1 = xhdpi: 2.0
li1-3-2-2-1-2 = hdpi: 1.5
li1-3-2-2-1-3 = mdpi: 1.0 (baseline)
li1-3-2-2-1-4 = ldpi: 0.75
p1-3-2-2-3 = This means that if you generate a 200x200 image for xhdpi devices, you should generate the same resource in 150x150 for hdpi, 100x100 for mdpi, and 75x75 for ldpi devices.
p1-3-2-2-4 = Then, place the files in the appropriate drawable resource directory:
p1-3-2-2-5 = Any time you reference <code>@drawable/awesomeimage</code>, the system selects the appropriate bitmap based on the screen's density.
nc1-3-2-2-1 = Note: Low-density (ldpi) resources aren\u2019t always necessary. When you provide hdpi assets, the system scales them down by one half to properly fit ldpi screens.
p1-3-2-2-6 = For more tips and guidelines about creating icon assets for your app, see the Iconography design guide.

#		**********************************************************************************************************
#		Supporting Different Platform Versions
#		**********************************************************************************************************

title1-3-3 = Supporting Different Platform Versions
p1-3-3-1 = While the latest versions of Android often provide great APIs for your app, you should continue to support older versions of Android until more devices get updated. This lesson shows you how to take advantage of the latest APIs while continuing to support older versions as well.
p1-3-3-2 = The dashboard for Platform Versions is updated regularly to show the distribution of active devices running each version of Android, based on the number of devices that visit the Google Play Store. Generally, it\u2019s a good practice to support about 90% of the active devices, while targeting your app to the latest version.
tc1-3-3-1 = Tip: In order to provide the best features and functionality across several Android versions, you should use the Android Support Library in your app, which allows you to use several recent platform APIs on older versions.
sub_title1-3-3-1 = Specify Minimum and Target API Levels
p1-3-3-1-1 = The <code>AndroidManifest.xml</code> file describes details about your app and identifies which versions of Android it supports. Specifically, the <code>minSdkVersion</code> and <code>targetSdkVersion</code> attributes for the <code>&lt;uses-sdk&gt;</code> element identify the lowest API level with which your app is compatible and the highest API level against which you\u2019ve designed and tested your app.
p1-3-3-1-2 = For example:
p1-3-3-1-3 = As new versions of Android are released, some style and behaviors may change. To allow your app to take advantage of these changes and ensure that your app fits the style of each user's device, you should set the <code>targetSdkVersion</code> value to match the latest Android version available.
sub_title1-3-3-2 = Check System Version at Runtime
p1-3-3-2-1 = Android provides a unique code for each platform version in the <code>Build</code> constants class. Use these codes within your app to build conditions that ensure the code that depends on higher API levels is executed only when those APIs are available on the system.
nc1-3-3-2-1 = Note: When parsing XML resources, Android ignores XML attributes that aren\u2019t supported by the current device. So you can safely use XML attributes that are only supported by newer versions without worrying about older versions breaking when they encounter that code. For example, if you set the <code>targetSdkVersion="11"</code>, your app includes the <code>ActionBar</code> by default on Android 3.0 and higher. To then add menu items to the action bar, you need to set <code>android:showAsAction="ifRoom"</code> in your menu resource XML. It's safe to do this in a cross-version XML file, because the older versions of Android simply ignore the <code>showAsAction</code> attribute (that is, you do not need a separate version in <code>res/menu-v11/</code>).
sub_title1-3-3-3 = Use Platform Styles and Themes
p1-3-3-3-1 = Android provides user experience themes that give apps the look and feel of the underlying operating system. These themes can be applied to your app within the manifest file. By using these built in styles and themes, your app will naturally follow the latest look and feel of Android with each new release.
p1-3-3-3-2 = To make your activity look like a dialog box:
p1-3-3-3-3 = To make your activity have a transparent background:
p1-3-3-3-4 = To apply your own custom theme defined in <code>/res/values/styles.xml</code>:
p1-3-3-3-5 = To apply a theme to your entire app (all activities), add the <code>android:theme</code> attribute to the <code>&lt;application&gt;</code> element:
p1-3-3-3-6 = For more about creating and using themes, read the Styles and Themes guide.

#		**********************************************************************************************************
#		Managing the Activity Lifecycle
#		**********************************************************************************************************

title1-4 = Managing the Activity Lifecycle
p1-4-1 = As a user navigates through, out of, and back to your app, the Activity instances in your app transition between different states in their lifecycle. For instance, when your activity starts for the first time, it comes to the foreground of the system and receives user focus. During this process, the Android system calls a series of lifecycle methods on the activity in which you set up the user interface and other components. If the user performs an action that starts another activity or switches to another app, the system calls another set of lifecycle methods on your activity as it moves into the background (where the activity is no longer visible, but the instance and its state remains intact).
p1-4-2 = Within the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity. For example, if you're building a streaming video player, you might pause the video and terminate the network connection when the user switches to another app. When the user returns, you can reconnect to the network and allow the user to resume the video from the same spot.
p1-4-3 = This class explains important lifecycle callback methods that each Activity instance receives and how you can use them so your activity does what the user expects and does not consume system resources when your activity doesn't need them.

#		**********************************************************************************************************
#		Starting an Activity
#		**********************************************************************************************************

title1-4-1 = Starting an Activity
p1-4-1-1 = Unlike other programming paradigms in which apps are launched with a main() method, the Android system initiates code in an Activity instance by invoking specific callback methods that correspond to specific stages of its lifecycle. There is a sequence of callback methods that start up an activity and a sequence of callback methods that tear down an activity.
p1-4-1-2 = This lesson provides an overview of the most important lifecycle methods and shows you how to handle the first lifecycle callback that creates a new instance of your activity.
sub_title1-4-1-1 = Understand the Lifecycle Callbacks
p1-4-1-1-1 = During the life of an activity, the system calls a core set of lifecycle methods in a sequence similar to a step pyramid. That is, each stage of the activity lifecycle is a separate step on the pyramid. As the system creates a new activity instance, each callback method moves the activity state one step toward the top. The top of the pyramid is the point at which the activity is running in the foreground and the user can interact with it.
p1-4-1-1-2 = As the user begins to leave the activity, the system calls other methods that move the activity state back down the pyramid in order to dismantle the activity. In some cases, the activity will move only part way down the pyramid and wait (such as when the user switches to another app), from which point the activity can move back to the top (if the user returns to the activity) and resume where the user left off.
p1-4-1-1-3 = Depending on the complexity of your activity, you probably don't need to implement all the lifecycle methods. However, it's important that you understand each one and implement those that ensure your app behaves the way users expect. Implementing your activity lifecycle methods properly ensures your app behaves well in several ways, including that it:
li1-4-1-1-1-1 = Does not crash if the user receives a phone call or switches to another app while using your app.
li1-4-1-1-1-2 = Does not consume valuable system resources when the user is not actively using it.
li1-4-1-1-1-3 = Does not lose the user's progress if they leave your app and return to it at a later time.
li1-4-1-1-1-4 = Does not crash or lose the user's progress when the screen rotates between landscape and portrait orientation.
p1-4-1-1-4 = As you'll learn in the following lessons, there are several situations in which an activity transitions between different states that are illustrated in figure 1. However, only three of these states can be static. That is, the activity can exist in one of only three states for an extended period of time:
dt1-4-1-1-1-1 = Resumed
dd1-4-1-1-1-1 = In this state, the activity is in the foreground and the user can interact with it. (Also sometimes referred to as the "running" state.)
dt1-4-1-1-1-2 = Paused
dd1-4-1-1-1-2 = In this state, the activity is partially obscured by another activity\u2014the other activity that's in the foreground is semi-transparent or doesn't cover the entire screen. The paused activity does not receive user input and cannot execute any code.
dt1-4-1-1-1-3 = Stopped
dd1-4-1-1-1-3 = In this state, the activity is completely hidden and not visible to the user; it is considered to be in the background. While stopped, the activity instance and all its state information such as member variables is retained, but it cannot execute any code.
p1-4-1-1-5 = The other states (Created and Started) are transient and the system quickly moves from them to the next state by calling the next lifecycle callback method. That is, after the system calls <code>onCreate()</code>, it quickly calls <code>onStart()</code>, which is quickly followed by <code>onResume()</code>.
p1-4-1-1-6 = That's it for the basic activity lifecycle. Now you'll start learning about some of the specific lifecycle behaviors.
sub_title1-4-1-2 = Specify Your App's Launcher Activity
p1-4-1-2-1 = When the user selects your app icon from the Home screen, the system calls the <code>onCreate()</code> method for the Activity in your app that you've declared to be the "launcher" (or "main") activity. This is the activity that serves as the main entry point to your app's user interface.
p1-4-1-2-2 = You can define which activity to use as the main activity in the Android manifest file, <code>AndroidManifest.xml</code>, which is at the root of your project directory.
p1-4-1-2-3 = The main activity for your app must be declared in the manifest with an <code>&lt;intent-filter&gt;</code> that includes the MAIN action and LAUNCHER category. For example:
nc1-4-1-2-1 = Note: When you create a new Android project with the Android SDK tools, the default project files include an Activity class that's declared in the manifest with this filter.
p1-4-1-2-4 = If either the MAIN action or LAUNCHER category are not declared for one of your activities, then your app icon will not appear in the Home screen's list of apps.
sub_title1-4-1-3 = Create a New Instance
p1-4-1-3-1 = Most apps include several different activities that allow the user to perform different actions. Whether an activity is the main activity that's created when the user clicks your app icon or a different activity that your app starts in response to a user action, the system creates every new instance of Activity by calling its <code>onCreate()</code> method.
p1-4-1-3-2 = You must implement the <code>onCreate()</code> method to perform basic application startup logic that should happen only once for the entire life of the activity. For example, your implementation of <code>onCreate()</code> should define the user interface and possibly instantiate some class-scope variables.
p1-4-1-3-3 = For example, the following example of the <code>onCreate()</code> method shows some code that performs some fundamental setup for the activity, such as declaring the user interface (defined in an XML layout file), defining member variables, and configuring some of the UI.
cc1-4-1-3-1 = Caution: Using the <code>SDK_INT</code> to prevent older systems from executing new APIs works in this way on Android 2.0 (API level 5) and higher only. Older versions will encounter a runtime exception.
p1-4-1-3-4 = Once the <code>onCreate()</code> finishes execution, the system calls the <code>onStart()</code> and <code>onResume()</code> methods in quick succession. Your activity never resides in the Created or Started states. Technically, the activity becomes visible to the user when <code>onStart()</code> is called, but <code>onResume()</code> quickly follows and the activity remains in the Resumed state until something occurs to change that, such as when a phone call is received, the user navigates to another activity, or the device screen turns off.
p1-4-1-3-5 = In the other lessons that follow, you'll see how the other start up methods, <code>onStart()</code> and <code>onResume()</code>, are useful during your activity's lifecycle when used to resume the activity from the Paused or Stopped states.
nc1-4-1-3-1 = Note: The <code>onCreate()</code> method includes a parameter called <code>savedInstanceState</code> that's discussed in the latter lesson about Recreating an Activity.
sub_title1-4-1-4 = Destroy the Activity
p1-4-1-4-1 = While the activity's first lifecycle callback is <code>onCreate()</code>, its very last callback is <code>onDestroy()</code>. The system calls this method on your activity as the final signal that your activity instance is being completely removed from the system memory.
p1-4-1-4-2 = Most apps don't need to implement this method because local class references are destroyed with the activity and your activity should perform most cleanup during <code>onPause()</code> and <code>onStop()</code>. However, if your activity includes background threads that you created during <code>onCreate()</code> or other long-running resources that could potentially leak memory if not properly closed, you should kill them during <code>onDestroy()</code>.
nc1-4-1-4-1 = Note: The system calls <code>onDestroy()</code> after it has already called <code>onPause()</code> and <code>onStop()</code> in all situations except one: when you call <code>finish()</code> from within the <code>onCreate()</code. method. In some cases, such as when your activity operates as a temporary decision maker to launch another activity, you might call <code>finish()</code> from within <code>onCreate()</code> to destroy the activity. In this case, the system immediately calls <code>onDestroy()</code> without calling any of the other lifecycle methods.

#		**********************************************************************************************************
#		Pausing and Resuming an Activity
#		**********************************************************************************************************

title1-4-2 = Pausing and Resuming an Activity
p1-4-2-1 = During normal app use, the foreground activity is sometimes obstructed by other visual components that cause the activity to pause. For example, when a semi-transparent activity opens (such as one in the style of a dialog), the previous activity pauses. As long as the activity is still partially visible but currently not the activity in focus, it remains paused.
p1-4-2-2 = However, once the activity is fully-obstructed and not visible, it stops (which is discussed in the next lesson).
p1-4-2-3 = As your activity enters the paused state, the system calls the <code>onPause()</code> method on your Activity, which allows you to stop ongoing actions that should not continue while paused (such as a video) or persist any information that should be permanently saved in case the user continues to leave your app. If the user returns to your activity from the paused state, the system resumes it and calls the <code>onResume()</code> method.
nc1-4-2-1 = Note: When your activity receives a call to <code>onPause()</code>, it may be an indication that the activity will be paused for a moment and the user may return focus to your activity. However, it's usually the first indication that the user is leaving your activity.
sub_title1-4-2-1 = Pause Your Activity
p1-4-2-1-1 = When the system calls <code>onPause()</code> for your activity, it technically means your activity is still partially visible, but most often is an indication that the user is leaving the activity and it will soon enter the Stopped state. You should usually use the <code>onPause()</code> callback to:
li1-4-2-1-1-1 = Stop animations or other ongoing actions that could consume CPU.
li1-4-2-1-1-2 = Commit unsaved changes, but only if users expect such changes to be permanently saved when they leave (such as a draft email).
li1-4-2-1-1-3 = Release system resources, such as broadcast receivers, handles to sensors (like GPS), or any resources that may affect battery life while your activity is paused and the user does not need them.
p1-4-2-1-2 = For example, if your application uses the Camera, the <code>onPause()</code> method is a good place to release it.
p1-4-2-1-3 = Generally, you should not use <code>onPause()</code> to store user changes (such as personal information entered into a form) to permanent storage. The only time you should persist user changes to permanent storage within <code>onPause()</code> is when you're certain users expect the changes to be auto-saved (such as when drafting an email). However, you should avoid performing CPU-intensive work during <code>onPause()</code>, such as writing to a database, because it can slow the visible transition to the next activity (you should instead perform heavy-load shutdown operations during <code>onStop()</code>.).
p1-4-2-1-4 = You should keep the amount of operations done in the onPause() method relatively simple in order to allow for a speedy transition to the user's next destination if your activity is actually being stopped.
nc1-4-2-1-1 = Note: When your activity is paused, the Activity instance is kept resident in memory and is recalled when the activity resumes. You don\u2019t need to re-initialize components that were created during any of the callback methods leading up to the Resumed state.
sub_title1-4-2-2 = Resume Your Activity
p1-4-2-2-1 = When the user resumes your activity from the Paused state, the system calls the onResume() method.
p1-4-2-2-2 = Be aware that the system calls this method every time your activity comes into the foreground, including when it's created for the first time. As such, you should implement <code>onResume()</code. to initialize components that you release during <code>onPause()</code> and perform any other initializations that must occur each time the activity enters the Resumed state (such as begin animations and initialize components only used while the activity has user focus).
p1-4-2-2-3 = The following example of <code>onResume()</code> is the counterpart to the <code>onPause()</code> example above, so it initializes the camera that's released when the activity pauses.

#		**********************************************************************************************************
#		Stopping and Restarting an Activity
#		**********************************************************************************************************

title1-4-3 = Stopping and Restarting an Activity
p1-4-3-1 = Properly stopping and restarting your activity is an important process in the activity lifecycle that ensures your users perceive that your app is always alive and doesn't lose their progress. There are a few of key scenarios in which your activity is stopped and restarted:
li1-4-3-1-1 = The user opens the Recent Apps window and switches from your app to another app. The activity in your app that's currently in the foreground is stopped. If the user returns to your app from the Home screen launcher icon or the Recent Apps window, the activity restarts.
li1-4-3-1-2 = The user performs an action in your app that starts a new activity. The current activity is stopped when the second activity is created. If the user then presses the Back button, the first activity is restarted.
li1-4-3-1-3 = The user receives a phone call while using your app on his or her phone.
p1-4-3-2 = The Activity class provides two lifecycle methods, <code>onStop()</code> and <code>onRestart()</code>, which allow you to specifically handle how your activity handles being stopped and restarted. Unlike the paused state, which identifies a partial UI obstruction, the stopped state guarantees that the UI is no longer visible and the user's focus is in a separate activity (or an entirely separate app).
nc1-4-3-1 = Note: Because the system retains your Activity instance in system memory when it is stopped, it's possible that you don't need to implement the <code>onStop()</code> and <code>onRestart()</code> (or even <code>onStart()</code> methods at all. For most activities that are relatively simple, the activity will stop and restart just fine and you might only need to use <code>onPause()</code> to pause ongoing actions and disconnect from system resources.
sub_title1-4-3-1 = Stop Your Activity
p1-4-3-1-1 = When your activity receives a call to the <code>onStop()</code. method, it's no longer visible and should release almost all resources that aren't needed while the user is not using it. Once your activity is stopped, the system might destroy the instance if it needs to recover system memory. In extreme cases, the system might simply kill your app process without calling the activity's final <code>onDestroy()</code> callback, so it's important you use <code>onStop()</code> to release resources that might leak memory.
p1-4-3-1-2 = Although the <code>onPause()</code> method is called before <code>onStop()</code>, you should use <code>onStop()</code> to perform larger, more CPU intensive shut-down operations, such as writing information to a database.
p1-4-3-1-3 = For example, here's an implementation of <code>onStop()</code> that saves the contents of a draft note to persistent storage:
p1-4-3-1-4 = When your activity is stopped, the Activity object is kept resident in memory and is recalled when the activity resumes. You don\u2019t need to re-initialize components that were created during any of the callback methods leading up to the Resumed state. The system also keeps track of the current state for each View in the layout, so if the user entered text into an <code>EditText</code> widget, that content is retained so you don't need to save and restore it.
nc1-4-3-1-1 = Note: Even if the system destroys your activity while it's stopped, it still retains the state of the View objects (such as text in an EditText) in a Bundle (a blob of key-value pairs) and restores them if the user navigates back to the same instance of the activity (the next lesson talks more about using a Bundle to save other state data in case your activity is destroyed and recreated).
sub_title1-4-3-2 = Start/Restart Your Activity
p1-4-3-2-1 = When your activity comes back to the foreground from the stopped state, it receives a call to <code>onRestart()</code>. The system also calls the <code>onStart()</code> method, which happens every time your activity becomes visible (whether being restarted or created for the first time). The <code>onRestart()</code> method, however, is called only when the activity resumes from the stopped state, so you can use it to perform special restoration work that might be necessary only if the activity was previously stopped, but not destroyed.
p1-4-3-2-2 = It's uncommon that an app needs to use <code>onRestart()</code> to restore the activity's state, so there aren't any guidelines for this method that apply to the general population of apps. However, because your <code>onStop()</code> method should essentially clean up all your activity's resources, you'll need to re-instantiate them when the activity restarts. Yet, you also need to instantiate them when your activity is created for the first time (when there's no existing instance of the activity). For this reason, you should usually use the <code>onStart()</code> callback method as the counterpart to the <code>onStop()</code> method, because the system calls <code>onStart()</code> both when it creates your activity and when it restarts the activity from the stopped state.
p1-4-3-2-3 = For example, because the user might have been away from your app for a long time before coming back it, the <code>onStart()</code> method is a good place to verify that required system features are enabled:
p1-4-3-2-4 = When the system destroys your activity, it calls the <code>onDestroy()</code> method for your Activity. Because you should generally have released most of your resources with <code>onStop()</code>, by the time you receive a call to <code>onDestroy()</code>, there's not much that most apps need to do. This method is your last chance to clean out resources that could lead to a memory leak, so you should be sure that additional threads are destroyed and other long-running actions like method tracing are also stopped.

#		**********************************************************************************************************
#		Recreating an Activity
#		**********************************************************************************************************

title1-4-4 = Recreating an Activity
p1-4-4-1 = There are a few scenarios in which your activity is destroyed due to normal app behavior, such as when the user presses the Back button or your activity signals its own destruction by calling <code>finish()</code>. The system may also destroy your activity if it's currently stopped and hasn't been used in a long time or the foreground activity requires more resources so the system must shut down background processes to recover memory.
p1-4-4-2 = When your activity is destroyed because the user presses Back or the activity finishes itself, the system's concept of that Activity instance is gone forever because the behavior indicates the activity is no longer needed. However, if the system destroys the activity due to system constraints (rather than normal app behavior), then although the actual Activity instance is gone, the system remembers that it existed such that if the user navigates back to it, the system creates a new instance of the activity using a set of saved data that describes the state of the activity when it was destroyed. The saved data that the system uses to restore the previous state is called the "instance state" and is a collection of key-value pairs stored in a Bundle object.
cc1-4-4-1 = Caution: Your activity will be destroyed and recreated each time the user rotates the screen. When the screen changes orientation, the system destroys and recreates the foreground activity because the screen configuration has changed and your activity might need to load alternative resources (such as the layout).
p1-4-4-3 = By default, the system uses the Bundle instance state to save information about each View object in your activity layout (such as the text value entered into an EditText object). So, if your activity instance is destroyed and recreated, the state of the layout is restored to its previous state with no code required by you. However, your activity might have more state information that you'd like to restore, such as member variables that track the user's progress in the activity.
nc1-4-4-1 = Note: In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the <code>android:id</code> attribute.
p1-4-4-4 = To save additional data about the activity state, you must override the <code>onSaveInstanceState()</code> callback method. The system calls this method when the user is leaving your activity and passes it the Bundle object that will be saved in the event that your activity is destroyed unexpectedly. If the system must recreate the activity instance later, it passes the same Bundle object to both the <code>onRestoreInstanceState()</code> and <code>onCreate()</code> methods.
sub_title1-4-4-1 = Save Your Activity State
p1-4-4-1-1 = As your activity begins to stop, the system calls <code>onSaveInstanceState()</code> so your activity can save state information with a collection of key-value pairs. The default implementation of this method saves information about the state of the activity's view hierarchy, such as the text in an EditText widget or the scroll position of a ListView.
p1-4-4-1-2 = To save additional state information for your activity, you must implement <code>onSaveInstanceState()</code> and add key-value pairs to the Bundle object. For example:
cc1-4-4-1-1 = Caution: Always call the superclass implementation of <code>onSaveInstanceState()</code> so the default implementation can save the state of the view hierarchy.
sub_title1-4-4-2 = Restore Your Activity State
p1-4-4-2-1 = When your activity is recreated after it was previously destroyed, you can recover your saved state from the Bundle that the system passes your activity. Both the <code>onCreate()</code> and <code>onRestoreInstanceState()</code> callback methods receive the same Bundle that contains the instance state information.
p1-4-4-2-2 = Because the <code>onCreate()</code> method is called whether the system is creating a new instance of your activity or recreating a previous one, you must check whether the state Bundle is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed.
p1-4-4-2-3 = For example, here's how you can restore some state data in <code>onCreate()</code>:
p1-4-4-2-4 = Instead of restoring the state during <code>onCreate()</code> you may choose to implement <code>onRestoreInstanceState()</code>, which the system calls after the <code>onStart()</code> method. The system calls <code>onRestoreInstanceState()</code> only if there is a saved state to restore, so you do not need to check whether the Bundle is null:
cc1-4-4-2-1 = Caution: Always call the superclass implementation of <code>onRestoreInstanceState()</code> so the default implementation can restore the state of the view hierarchy.
p1-4-4-2-5 = To learn more about recreating your activity due to a restart event at runtime (such as when the screen rotates), read Handling Runtime Changes.

#		**********************************************************************************************************
#		Building a Dynamic UI with Fragments
#		**********************************************************************************************************

title1-5 = Building a Dynamic UI with Fragments
p1-5-1 = To create a dynamic and multi-pane user interface on Android, you need to encapsulate UI components and activity behaviors into modules that you can swap into and out of your activities. You can create these modules with the Fragment class, which behaves somewhat like a nested activity that can define its own layout and manage its own lifecycle.
p1-5-2 = When a fragment specifies its own layout, it can be configured in different combinations with other fragments inside an activity to modify your layout configuration for different screen sizes (a small screen might show one fragment at a time, but a large screen can show two or more).
p1-5-3 = This class shows you how to create a dynamic user experience with fragments and optimize your app's user experience for devices with different screen sizes, all while continuing to support devices running versions as old as Android 1.6.

#		**********************************************************************************************************
#		Creating a Fragment
#		**********************************************************************************************************

title1-5-1 = Creating a Fragment
p1-5-1-1 = You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running (sort of like a "sub activity" that you can reuse in different activities). This lesson shows how to extend the Fragment class using the <code>Support Library</code> so your app remains compatible with devices running system versions as low as Android 1.6.
nc1-5-1-1 = Note: If you decide that the minimum API level your app requires is 11 or higher, you don't need to use the Support Library and can instead use the framework's built in Fragment class and related APIs. Just be aware that this lesson is focused on using the APIs from the Support Library, which use a specific package signature and sometimes slightly different API names than the versions included in the platform.
p1-5-1-2 = Before you begin this lesson, you must set up your Android project to use the Support Library. If you have not used the Support Library before, set up your project to use the v4 library by following the Support Library Setup document. However, you can also include the action bar in your activities by instead using the v7 appcompat library, which is compatible with Android 2.1 (API level 7) and also includes the Fragment APIs.
sub_title1-5-1-1 = Create a Fragment Class
p1-5-1-1-1 = To create a fragment, extend the Fragment class, then override key lifecycle methods to insert your app logic, similar to the way you would with an Activity class.
p1-5-1-1-2 = One difference when creating a Fragment is that you must use the <code>onCreateView()</code> callback to define the layout. In fact, this is the only callback you need in order to get a fragment running. For example, here's a simple fragment that specifies its own layout:
p1-5-1-1-3 = Just like an activity, a fragment should implement other lifecycle callbacks that allow you to manage its state as it is added or removed from the activity and as the activity transitions between its lifecycle states. For instance, when the activity's <code>onPause()</code> method is called, any fragments in the activity also receive a call to <code>onPause()</code>.
p1-5-1-1-4 = More information about the fragment lifecycle and callback methods is available in the Fragments developer guide.
sub_title1-5-1-2 = Add a Fragment to an Activity using XML
p1-5-1-2-1 = While fragments are reusable, modular UI components, each instance of a Fragment class must be associated with a parent FragmentActivity. You can achieve this association by defining each fragment within your activity layout XML file.
nc1-5-1-2-1 = Note: FragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity.
p1-5-1-2-2 = Here is an example layout file that adds two fragments to an activity when the device screen is considered "large" (specified by the <code>large</code> qualifier in the directory name).
tc1-5-1-2-1 = Tip: For more about creating layouts for different screen sizes, read Supporting Different Screen Sizes.
p1-5-1-2-3 = Then apply the layout to your activity:
p1-5-1-2-4 = If you're using the <code>v7 appcompat library</code>, your activity should instead extend ActionBarActivity, which is a subclass of FragmentActivity (for more information, read Adding the Action Bar).
nc1-5-1-2-2 = Note: When you add a fragment to an activity layout by defining the fragment in the layout XML file, you cannot remove the fragment at runtime. If you plan to swap your fragments in and out during user interaction, you must add the fragment to the activity when the activity first starts, as shown in the next lesson.

#		**********************************************************************************************************
#		Building a Flexible UI
#		**********************************************************************************************************

title1-5-2 = Building a Flexible UI
p1-5-2-1 = When designing your application to support a wide range of screen sizes, you can reuse your fragments in different layout configurations to optimize the user experience based on the available screen space.
p1-5-2-2 = For example, on a handset device it might be appropriate to display just one fragment at a time for a single-pane user interface. Conversely, you may want to set fragments side-by-side on a tablet which has a wider screen size to display more information to the user.
p1-5-2-3 = The <code>FragmentManager</code> class provides methods that allow you to add, remove, and replace fragments to an activity at runtime in order to create a dynamic experience.
sub_title1-5-2-1 = Add a Fragment to an Activity at Runtime
p1-5-2-1-1 = Rather than defining the fragments for an activity in the layout file\u2014as shown in the <a href="#c1-5-1">previous lesson</a> with the <code>&lt;fragment&gt;</code> element\u2014you can add a fragment to the activity during the activity runtime. This is necessary if you plan to change fragments during the life of the activity.
p1-5-2-1-2 = To perform a transaction such as add or remove a fragment, you must use the <code>FragmentManager</code> to create a <code>FragmentTransaction</code>, which provides APIs to add, remove, replace, and perform other fragment transactions.
p1-5-2-1-3 = If your activity allows the fragments to be removed and replaced, you should add the initial fragment(s) to the activity during the activity's <code>onCreate()</code> method.
p1-5-2-1-4 = An important rule when dealing with fragments\u2014especially when adding fragments at runtime\u2014is that your activity layout must include a container View in which you can insert the fragment.
p1-5-2-1-5 = The following layout is an alternative to the layout shown in the <a href="#c1-5-1">previous lesson</a> that shows only one fragment at a time. In order to replace one fragment with another, the activity's layout includes an empty FrameLayout that acts as the fragment container.
p1-5-2-1-6 = Notice that the filename is the same as the layout file in the previous lesson, but the layout directory does not have the large qualifier, so this layout is used when the device screen is smaller than large because the screen does not fit both fragments at the same time.
p1-5-2-1-7 = <code>res/layout/news_articles.xml:</code>
p1-5-2-1-8 = Inside your activity, call <code>getSupportFragmentManager()</code> to get a <code>FragmentManager</code> using the Support Library APIs. Then call <code>beginTransaction()</code> to create a FragmentTransaction and call <code>add()</code> to add a fragment.
p1-5-2-1-9 = You can perform multiple fragment transaction for the activity using the same FragmentTransaction. When you're ready to make the changes, you must call <code>commit()</code>.
p1-5-2-1-10 = For example, here's how to add a fragment to the previous layout:
p1-5-2-1-11 = Because the fragment has been added to the FrameLayout container at runtime\u2014instead of defining it in the activity's layout with a <code>&lt;fragment&gt;</code> element\u2014the activity can remove the fragment and replace it with a different one.
sub_title1-5-2-2 = Replace One Fragment with Another
p1-5-2-2-1 = The procedure to replace a fragment is similar to adding one, but requires the <code>replace()</code> method instead of <code>add()</code>.
p1-5-2-2-2 = Keep in mind that when you perform fragment transactions, such as replace or remove one, it's often appropriate to allow the user to navigate backward and "undo" the change. To allow the user to navigate backward through the fragment transactions, you must call <code>addToBackStack()</code> before you commit the <code>FragmentTransaction</code>.
nc1-5-2-2-1 = Note: When you remove or replace a fragment and add the transaction to the back stack, the fragment that is removed is stopped (not destroyed). If the user navigates back to restore the fragment, it restarts. If you do not add the transaction to the back stack, then the fragment is destroyed when removed or replaced.
p1-5-2-2-3 = Example of replacing one fragment with another:
p1-5-2-2-4 = The <code>addToBackStack()</code> method takes an optional string parameter that specifies a unique name for the transaction. The name isn't needed unless you plan to perform advanced fragment operations using the FragmentManager.BackStackEntry APIs.

#		**********************************************************************************************************
#		Communicating with Other Fragments
#		**********************************************************************************************************

title1-5-3 = Communicating with Other Fragments
p1-5-3-1 = In order to reuse the Fragment UI components, you should build each as a completely self-contained, modular component that defines its own layout and behavior. Once you have defined these reusable Fragments, you can associate them with an Activity and connect them with the application logic to realize the overall composite UI.
p1-5-3-2 = Often you will want one Fragment to communicate with another, for example to change the content based on a user event. All Fragment-to-Fragment communication is done through the associated Activity. Two Fragments should never communicate directly.
sub_title1-5-3-1 = Define an Interface
p1-5-3-1-1 = To allow a Fragment to communicate up to its Activity, you can define an interface in the Fragment class and implement it within the Activity. The Fragment captures the interface implementation during its onAttach() lifecycle method and can then call the Interface methods in order to communicate with the Activity.
p1-5-3-1-2 = Here is an example of Fragment to Activity communication:
p1-5-3-1-3 = Now the fragment can deliver messages to the activity by calling the <code>onArticleSelected()</code> method (or other methods in the interface) using the <code>mCallback</code> instance of the <code>OnHeadlineSelectedListener</code> interface.
p1-5-3-1-4 = For example, the following method in the fragment is called when the user clicks on a list item. The fragment uses the callback interface to deliver the event to the parent activity.
sub_title1-5-3-2 = Implement the Interface
p1-5-3-2-1 = In order to receive event callbacks from the fragment, the activity that hosts it must implement the interface defined in the fragment class.
p1-5-3-2-2 = For example, the following activity implements the interface from the above example.
sub_title1-5-3-3 = Deliver a Message to a Fragment
p1-5-3-3-1 = The host activity can deliver messages to a fragment by capturing the Fragment instance with <code>findFragmentById()</code>, then directly call the fragment's public methods.
p1-5-3-3-2 = For instance, imagine that the activity shown above may contain another fragment that's used to display the item specified by the data returned in the above callback method. In this case, the activity can pass the information received in the callback method to the other fragment that will display the item:

#		**********************************************************************************************************
#		Saving Data
#		**********************************************************************************************************

title1-6 = Saving Data
p1-6-1 = ost Android apps need to save data, even if only to save information about the app state during <code>onPause()</code> so the user's progress is not lost. Most non-trivial apps also need to save user settings, and some apps must manage large amounts of information in files and databases. This class introduces you to the principal data storage options in Android, including:
li1-6-1-1 = Saving key-value pairs of simple data types in a shared preferences file
li1-6-1-2 = Saving arbitrary files in Android's file system
li1-6-1-3 = Using databases managed by SQLite

#		**********************************************************************************************************
#		Saving Key-Value Sets
#		**********************************************************************************************************

title1-6-1 = Saving Key-Value Sets 
p1-6-1-1 = If you have a relatively small collection of key-values that you'd like to save, you should use the <code>SharedPreferences</code> APIs. A <code>SharedPreferences</code> object points to a file containing key-value pairs and provides simple methods to read and write them. Each <code>SharedPreferences</code> file is managed by the framework and can be private or shared.
p1-6-1-2 = This class shows you how to use the <code>SharedPreferences</code> APIs to store and retrieve simple values.
nc1-6-1-1 = Note: The SharedPreferences APIs are only for reading and writing key-value pairs and you should not confuse them with the Preference APIs, which help you build a user interface for your app settings (although they use SharedPreferences as their implementation to save the app settings). For information about using the Preference APIs, see the Settings guide.
sub_title1-6-1-1 = Get a Handle to a SharedPreferences 
p1-6-1-1-1 = You can create a new shared preference file or access an existing one by calling one of two methods:
li1-6-1-1-1-1 = <code>getSharedPreferences()</code> \u2014 Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any Context in your app.
li1-6-1-1-1-2 = <code>getPreferences()</code> \u2014 Use this from an Activity if you need to use only one shared preference file for the activity. Because this retrieves a default shared preference file that belongs to the activity, you don't need to supply a name.
p1-6-1-1-2 = For example, the following code is executed inside a Fragment. It accesses the shared preferences file that's identified by the resource string <code>R.string.preference_file_key</code> and opens it using the private mode so the file is accessible by only your app.
p1-6-1-1-3 = When naming your shared preference files, you should use a name that's uniquely identifiable to your app, such as <code>"com.example.myapp.PREFERENCE_FILE_KEY"</code>
p1-6-1-1-4 = Alternatively, if you need just one shared preference file for your activity, you can use the <code>getPreferences()</code> method:
cc1-6-1-1-1 = Caution: If you create a shared preferences file with <code>MODE_WORLD_READABLE</code> or <code>MODE_WORLD_WRITEABLE</code>, then any other apps that know the file identifier can access your data.
sub_title1-6-1-2 = Write to Shared Preferences
p1-6-1-2-1 = To write to a shared preferences file, create a <code>SharedPreferences.Editor</code> by calling <code>edit()</code> on your <code>SharedPreferences</code>.
p1-6-1-2-2 = Pass the keys and values you want to write with methods such as <code>putInt()</code> and <code>putString()</code>. Then call <code>commit()</code> to save the changes. For example:
sub_title1-6-1-3 = Read from Shared Preferences
p1-6-1-3-1 = To retrieve values from a shared preferences file, call methods such as <code>getInt()</code> and <code>getString()</code>, providing the key for the value you want, and optionally a default value to return if the key isn't present. For example:

#		**********************************************************************************************************
#		Saving Files
#		**********************************************************************************************************

title1-6-2 = Saving Files
p1-6-2-1 = Android uses a file system that's similar to disk-based file systems on other platforms. This lesson describes how to work with the Android file system to read and write files with the <code>File</code> APIs.
p1-6-2-2 = A <code>File</code> object is suited to reading or writing large amounts of data in start-to-finish order without skipping around. For example, it's good for image files or anything exchanged over a network.
p1-6-2-3 = This lesson shows how to perform basic file-related tasks in your app. The lesson assumes that you are familiar with the basics of the Linux file system and the standard file input/output APIs in <code>java.io</code>.
sub_title1-6-2-1 = Choose Internal or External Storage
p1-6-2-1-1 = All Android devices have two file storage areas: "internal" and "external" storage. These names come from the early days of Android, when most devices offered built-in non-volatile memory (internal storage), plus a removable storage medium such as a micro SD card (external storage). Some devices divide the permanent storage space into "internal" and "external" partitions, so even without a removable storage medium, there are always two storage spaces and the API behavior is the same whether the external storage is removable or not. The following lists summarize the facts about each storage space.
p1-6-2-1-2 = Internal storage:
li1-6-2-1-1-1 = It's always available.
li1-6-2-1-1-2 = Files saved here are accessible by only your app by default.
li1-6-2-1-1-3 = When the user uninstalls your app, the system removes all your app's files from internal storage.
p1-6-2-1-3 = Internal storage is best when you want to be sure that neither the user nor other apps can access your files.
p1-6-2-1-4 = External storage:
li1-6-2-1-2-1 = It's not always available, because the user can mount the external storage as USB storage and in some cases remove it from the device.
li1-6-2-1-2-2 = It's world-readable, so files saved here may be read outside of your control.
li1-6-2-1-2-3 = When the user uninstalls your app, the system removes your app's files from here only if you save them in the directory from <code>getExternalFilesDir()</code>.
p1-6-2-1-5 = External storage is the best place for files that don't require access restrictions and for files that you want to share with other apps or allow the user to access with a computer.
tc1-6-2-1-1 = Tip: Although apps are installed onto the internal storage by default, you can specify the <code>android:installLocation</code> attribute in your manifest so your app may be installed on external storage. Users appreciate this option when the APK size is very large and they have an external storage space that's larger than the internal storage. For more information, see App Install Location.
sub_title1-6-2-2 = Obtain Permissions for External Storage
p1-6-2-2-1 = To write to the external storage, you must request the <code>WRITE_EXTERNAL_STORAGE</code> permission in your <code>manifest file</code>:
cc1-6-2-2-1-1 = Caution: Currently, all apps have the ability to read the external storage without a special permission. However, this will change in a future release. If your app needs to read the external storage (but not write to it), then you will need to declare the READ_EXTERNAL_STORAGE permission. To ensure that your app continues to work as expected, you should declare this permission now, before the change takes effect.
cc1-6-2-2-1-2 = However, if your app uses the <code>WRITE_EXTERNAL_STORAGE</code> permission, then it implicitly has permission to read the external storage as well.
p1-6-2-2-2 = You don\u2019t need any permissions to save files on the internal storage. Your application always has permission to read and write files in its internal storage directory.
sub_title1-6-2-3 = Save a File on Internal Storage
p1-6-2-3-1 = When saving a file to internal storage, you can acquire the appropriate directory as a File by calling one of two methods:
dt1-6-2-3-1 = getFilesDir() 
dd1-6-2-3-1 = Returns a File representing an internal directory for your app.
dt1-6-2-3-2 = getCacheDir()
dd1-6-2-3-2 = Returns a File representing an internal directory for your app's temporary cache files. Be sure to delete each file once it is no longer needed and implement a reasonable size limit for the amount of memory you use at any given time, such as 1MB. If the system begins running low on storage, it may delete your cache files without warning.
p1-6-2-3-2 = To create a new file in one of these directories, you can use the <code>File()</code> constructor, passing the <code>File</code> provided by one of the above methods that specifies your internal storage directory. For example:
p1-6-2-3-3 = Alternatively, you can call <code>openFileOutput()</code> to get a <code>FileOutputStream</code> that writes to a file in your internal directory. For example, here's how to write some text to a file:
p1-6-2-3-4 = Or, if you need to cache some files, you should instead use <code>createTempFile()</code>. For example, the following method extracts the file name from a URL and creates a file with that name in your app's internal cache directory:
nc1-6-2-3-1 = Note: Your app's internal storage directory is specified by your app's package name in a special location of the Android file system. Technically, another app can read your internal files if you set the file mode to be readable. However, the other app would also need to know your app package name and file names. Other apps cannot browse your internal directories and do not have read or write access unless you explicitly set the files to be readable or writable. So as long as you use <code>MODE_PRIVATE</code> for your files on the internal storage, they are never accessible to other apps.
sub_title1-6-2-4 = Save a File on External Storage
p1-6-2-4-1 = Because the external storage may be unavailable\u2014such as when the user has mounted the storage to a PC or has removed the SD card that provides the external storage\u2014you should always verify that the volume is available before accessing it. You can query the external storage state by calling <code>getExternalStorageState()</code>. If the returned state is equal to <code>MEDIA_MOUNTED</code>, then you can read and write your files. For example, the following methods are useful to determine the storage availability:
p1-6-2-4-2 = Although the external storage is modifiable by the user and other apps, there are two categories of files you might save here:
dt1-6-2-4-1 = Public files
dd1-6-2-4-1-1 = Files that should be freely available to other apps and to the user. When the user uninstalls your app, these files should remain available to the user.
dd1-6-2-4-1-2 = For example, photos captured by your app or other downloaded files.
dt1-6-2-4-2 = Private files
dd1-6-2-4-2-1 = Files that rightfully belong to your app and should be deleted when the user uninstalls your app. Although these files are technically accessible by the user and other apps because they are on the external storage, they are files that realistically don't provide value to the user outside your app. When the user uninstalls your app, the system deletes all files in your app's external private directory.
dd1-6-2-4-2-2 = For example, additional resources downloaded by your app or temporary media files.
p1-6-2-4-3 = If you want to save public files on the external storage, use the <code>getExternalStoragePublicDirectory()</code> method to get a File representing the appropriate directory on the external storage. The method takes an argument specifying the type of file you want to save so that they can be logically organized with other public files, such as <code>DIRECTORY_MUSIC</code> or <code>DIRECTORY_PICTURES</code>. For example:
p1-6-2-4-4 = If you want to save files that are private to your app, you can acquire the appropriate directory by calling <code>getExternalFilesDir()</code> and passing it a name indicating the type of directory you'd like. Each directory created this way is added to a parent directory that encapsulates all your app's external storage files, which the system deletes when the user uninstalls your app.
p1-6-2-4-5 = For example, here's a method you can use to create a directory for an individual photo album:
p1-6-2-4-6 = If none of the pre-defined sub-directory names suit your files, you can instead call <code>getExternalFilesDir()</code> and pass null. This returns the root directory for your app's private directory on the external storage.
p1-6-2-4-7 = Remember that <code>getExternalFilesDir()</code> creates a directory inside a directory that is deleted when the user uninstalls your app. If the files you're saving should remain available after the user uninstalls your app\u2014such as when your app is a camera and the user will want to keep the photos\u2014you should instead use <code>getExternalStoragePublicDirectory()</code>.
p1-6-2-4-8 = Regardless of whether you use <code>getExternalStoragePublicDirectory()</code> for files that are shared or <code>getExternalFilesDir()</code> for files that are private to your app, it's important that you use directory names provided by API constants like <code>DIRECTORY_PICTURES</code>. These directory names ensure that the files are treated properly by the system. For instance, files saved in <code>DIRECTORY_RINGTONES</code> are categorized by the system media scanner as ringtones instead of music.
sub_title1-6-2-5 = Query Free Space
p1-6-2-5-1 = If you know ahead of time how much data you're saving, you can find out whether sufficient space is available without causing an <code>IOException</code> by calling <code>getFreeSpace()</code> or <code>getTotalSpace()</code>. These methods provide the current available space and the total space in the storage volume, respectively. This information is also useful to avoid filling the storage volume above a certain threshold.
p1-6-2-5-2 = However, the system does not guarantee that you can write as many bytes as are indicated by <code>getFreeSpace()</code>. If the number returned is a few MB more than the size of the data you want to save, or if the file system is less than 90% full, then it's probably safe to proceed. Otherwise, you probably shouldn't write to storage.
nc1-6-2-5-1 = Note: You aren't required to check the amount of available space before you save your file. You can instead try writing the file right away, then catch an <code>IOException</code> if one occurs. You may need to do this if you don't know exactly how much space you need. For example, if you change the file's encoding before you save it by converting a PNG image to JPEG, you won't know the file's size beforehand.
sub_title1-6-2-6 = Delete a File
p1-6-2-6-1 = You should always delete files that you no longer need. The most straightforward way to delete a file is to have the opened file reference call <code>delete()</code> on itself.
p1-6-2-6-2 = If the file is saved on internal storage, you can also ask the <code>Context</code> to locate and delete a file by calling <code>deleteFile()</code>:
nc1-6-2-6-1-1 = Note: When the user uninstalls your app, the Android system deletes the following:
li1-6-2-6-1-1 = All files you saved on internal storage
li1-6-2-6-1-2 = All files you saved on external storage using <code>getExternalFilesDir()</code>.
nc1-6-2-6-1-2 = However, you should manually delete all cached files created with <code>getCacheDir()</code> on a regular basis and also regularly delete other files you no longer need.

#		**********************************************************************************************************
#		Saving Data in SQL Databases
#		**********************************************************************************************************

title1-6-3 = Saving Data in SQL Databases
p1-6-3-1 = Saving data to a database is ideal for repeating or structured data, such as contact information. This class assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the <code>android.database.sqlite</code> package.
sub_title1-6-3-1 = Define a Schema and Contract
p1-6-3-1-1 = One of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.
p1-6-3-1-2 = A contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.
p1-6-3-1-3 = A good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table that enumerates its columns.
nc1-6-3-1-1 = Note: By implementing the <code>BaseColumns</code> interface, your inner class can inherit a primary key field called _ID that some Android classes such as cursor adaptors will expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.
p1-6-3-1-4 = For example, this snippet defines the table name and column names for a single table:
sub_title1-6-3-2 = Create a Database Using a SQL Helper
p1-6-3-2-1 = Once you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:
p1-6-3-2-2 = Just like files that you save on the device's <code>internal storage</code>, Android stores your database in private disk space that's associated application. Your data is secure, because by default this area is not accessible to other applications.
p1-6-3-2-3 = A useful set of APIs is available in the <code>SQLiteOpenHelper</code> class. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call <code>getWritableDatabase()</code> or <code>getReadableDatabase()</code>.
nc1-6-3-2-1 = Note: Because they can be long-running, be sure that you call <code>getWritableDatabase()</code> or <code>getReadableDatabase()</code> in a background thread, such as with <code>AsyncTask</code> or <code>IntentService</code>.
p1-6-3-2-4 = To use SQLiteOpenHelper, create a subclass that overrides the <code>onCreate()</code>, <code>onUpgrade()</code> and <code>onOpen()</code> callback methods. You may also want to implement <code>onDowngrade()</code>, but it's not required.
p1-6-3-2-5 = For example, here's an implementation of SQLiteOpenHelper that uses some of the commands shown above:
p1-6-3-2-6 = To access your database, instantiate your subclass of <code>SQLiteOpenHelper</code>:
sub_title1-6-3-3 = Put Information into a Database
p1-6-3-3-1 = Insert data into the database by passing a <code>ContentValues</code> object to the <code>insert()</code> method:
p1-6-3-3-2 = The first argument for <code>insert()</code> is simply the table name. The second argument provides the name of a column in which the framework can insert NULL in the event that the <code>ContentValues</code> is empty (if you instead set this to <code>"null"</code>, then the framework will not insert a row when there are no values).
sub_title1-6-3-4 = Read Information from a Database
p1-6-3-4-1 = To read from a database, use the <code>query()</code> method, passing it your selection criteria and desired columns. The method combines elements of <code>insert()</code> and <code>update()</code>, except the column list defines the data you want to fetch, rather than the data to insert. The results of the query are returned to you in a <code>Cursor</code> object.
p1-6-3-4-2 = To look at a row in the cursor, use one of the Cursor move methods, which you must always call before you begin reading values. Generally, you should start by calling <code>moveToFirst()</code>, which places the "read position" on the first entry in the results. For each row, you can read a column's value by calling one of the Cursor get methods, such as <code>getString()</code> or <code>getLong()</code>. For each of the get methods, you must pass the index position of the column you desire, which you can get by calling <code>getColumnIndex()</code> or <code>getColumnIndexOrThrow()</code>. For example:
sub_title1-6-3-5 = Delete Information from a Database
p1-6-3-5-1 = To delete rows from a table, you need to provide selection criteria that identify the rows. The database API provides a mechanism for creating selection criteria that protects against SQL injection. The mechanism divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.
sub_title1-6-3-6 = Update a Database
p1-6-3-6-1 = When you need to modify a subset of your database values, use the <code>update()</code> method.
p1-6-3-6-2 = Updating the table combines the content values syntax of <code>insert()</code> with the where syntax of <code>delete()</code>.

#		**********************************************************************************************************
#		Interacting with Other Apps
#		**********************************************************************************************************

title1-7 = Interacting with Other Apps
p1-7-1 = An Android app typically has several activities. Each activity displays a user interface that allows the user to perform a specific task (such as view a map or take a photo). To take the user from one activity to another, your app must use an Intent to define your app's "intent" to do something. When you pass an Intent to the system with a method such as <code>startActivity()</code>, the system uses the Intent to identify and start the appropriate app component. Using intents even allows your app to start an activity that is contained in a separate app.
p1-7-2 = An Intent can be explicit in order to start a specific component (a specific Activity instance) or implicit in order to start any component that can handle the intended action (such as "capture a photo").
p1-7-3 = This class shows you how to use an Intent to perform some basic interactions with other apps, such as start another app, receive a result from that app, and make your app able to respond to intents from other apps.

#		**********************************************************************************************************
#		Sending the User to Another App
#		**********************************************************************************************************

title1-7-1 = Sending the User to Another App
p1-7-1-1 = One of Android's most important features is an app's ability to send the user to another app based on an "action" it would like to perform. For example, if your app has the address of a business that you'd like to show on a map, you don't have to build an activity in your app that shows a map. Instead, you can create a request to view the address using an Intent. The Android system then starts an app that's able to show the address on a map.
p1-7-1-2 = As explained in the first class, Building Your First App, you must use intents to navigate between activities in your own app. You generally do so with an explicit intent, which defines the exact class name of the component you want to start. However, when you want to have a separate app perform an action, such as "view a map," you must use an implicit intent.
p1-7-1-3 = This lesson shows you how to create an implicit intent for a particular action, and how to use it to start an activity that performs the action in another app.
sub_title1-7-1-1 = Build an Implicit Intent
p1-7-1-1-1 = Implicit intents do not declare the class name of the component to start, but instead declare an action to perform. The action specifies the thing you want to do, such as view, edit, send, or get something. Intents often also include data associated with the action, such as the address you want to view, or the email message you want to send. Depending on the intent you want to create, the data might be a Uri, one of several other data types, or the intent might not need data at all.
p1-7-1-1-2 = If your data is a Uri, there's a simple <code>Intent()</code> constructor you can use define the action and data.
p1-7-1-1-3 = For example, here's how to create an intent to initiate a phone call using the Uri data to specify the telephone number:
p1-7-1-1-4 = When your app invokes this intent by calling <code>startActivity()</code>, the Phone app initiates a call to the given phone number.
p1-7-1-1-5 = Here are a couple other intents and their action and Uri data pairs:
li1-7-1-1-1-1 = View a map:
li1-7-1-1-1-2 = View a web page:
p1-7-1-1-6 = Other kinds of implicit intents require "extra" data that provide different data types, such as a string. You can add one or more pieces of extra data using the various <code>putExtra()</code> methods.
p1-7-1-1-7 = By default, the system determines the appropriate MIME type required by an intent based on the Uri data that's included. If you don't include a Uri in the intent, you should usually use <code>setType()</code> to specify the type of data associated with the intent. Setting the MIME type further specifies which kinds of activities should receive the intent.
p1-7-1-1-8 = Here are some more intents that add extra data to specify the desired action:
li1-7-1-1-2-1 = Send an email with an attachment:
li1-7-1-1-2-2 = Create a calendar event:
nc1-7-1-1-1 = Note: This intent for a calendar event is supported only with API level 14 and higher.
nc1-7-1-1-2 = Note: It's important that you define your Intent to be as specific as possible. For example, if you want to display an image using the ACTION_VIEW intent, you should specify a MIME type of <code>image/*</code>. This prevents apps that can "view" other types of data (like a map app) from being triggered by the intent.
sub_title1-7-1-2 = Verify There is an App to Receive the Intent
p1-7-1-2-1 = Although the Android platform guarantees that certain intents will resolve to one of the built-in apps (such as the Phone, Email, or Calendar app), you should always include a verification step before invoking an intent.
cc1-7-1-2-1 = Caution: If you invoke an intent and there is no app available on the device that can handle the intent, your app will crash.
p1-7-1-2-2 = To verify there is an activity available that can respond to the intent, call <code>queryIntentActivities()</code> to get a list of activities capable of handling your Intent. If the returned List is not empty, you can safely use the intent. For example:
p1-7-1-2-3 = If <code>isIntentSafe</code> is <code>true</code>, then at least one app will respond to the intent. If it is <code>false</code>, then there aren't any apps to handle the intent.
nc1-7-1-2-1 = Note: You should perform this check when your activity first starts in case you need to disable the feature that uses the intent before the user attempts to use it. If you know of a specific app that can handle the intent, you can also provide a link for the user to download the app (see how to link to your product on Google Play).
sub_title1-7-1-3 = Start an Activity with the Intent
p1-7-1-3-1 = Once you have created your Intent and set the extra info, call <code>startActivity()</code> to send it to the system. If the system identifies more than one activity that can handle the intent, it displays a dialog for the user to select which app to use, as shown in figure 1. If there is only one activity that handles the intent, the system immediately starts it.
p1-7-1-3-2 = Here's a complete example that shows how to create an intent to view a map, verify that an app exists to handle the intent, then start it:
sub_title1-7-1-4 = Show an App Chooser
p1-7-1-4-1 = Notice that when you start an activity by passing your Intent to <code>startActivity()</code> and there is more than one app that responds to the intent, the user can select which app to use by default (by selecting a checkbox at the bottom of the dialog; see figure 1). This is nice when performing an action for which the user generally wants to use the same app every time, such as when opening a web page (users likely use just one web browser) or taking a photo (users likely prefer one camera).
p1-7-1-4-2 = However, if the action to be performed could be handled by multiple apps and the user might prefer a different app each time\u2014such as a "share" action, for which users might have several apps through which they might share an item\u2014you should explicitly show a chooser dialog as shown in figure 2. The chooser dialog forces the user to select which app to use for the action every time (the user cannot select a default app for the action).
p1-7-1-4-3 = To show the chooser, create an Intent using <code>createChooser()</code> and pass it to <code>startActivity()</code>. For example:
p1-7-1-4-4 = This displays a dialog with a list of apps that respond to the intent passed to the <code>createChooser()</code> method and uses the supplied text as the dialog title.

#		**********************************************************************************************************
#		Getting a Result from an Activity
#		**********************************************************************************************************

title1-7-2 = Getting a Result from an Activity
p1-7-2-1 = Starting another activity doesn't have to be one-way. You can also start another activity and receive a result back. To receive a result, call <code>startActivityForResult()</code> (instead of <code>startActivity()</code>).
p1-7-2-2 = For example, your app can start a camera app and receive the captured photo as a result. Or, you might start the People app in order for the user to select a contact and you'll receive the contact details as a result.
p1-7-2-3 = Of course, the activity that responds must be designed to return a result. When it does, it sends the result as another Intent object. Your activity receives it in the <code>onActivityResult()</code> callback.
nc1-7-2-1 = Note: You can use explicit or implicit intents when you call <code>startActivityForResult()</code>. When starting one of your own activities to receive a result, you should use an explicit intent to ensure that you receive the expected result.
sub_title1-7-2-1 = Start the Activity
p1-7-2-1-1 = There's nothing special about the Intent object you use when starting an activity for a result, but you do need to pass an additional integer argument to the <code>startActivityForResult()</code> method.
p1-7-2-1-2 = The integer argument is a "request code" that identifies your request. When you receive the result Intent, the callback provides the same request code so that your app can properly identify the result and determine how to handle it.
p1-7-2-1-3 = For example, here's how to start an activity that allows the user to pick a contact:
sub_title1-7-2-2 = Receive the Result
p1-7-2-2-1 = When the user is done with the subsequent activity and returns, the system calls your activity's <code>onActivityResult()</code> method. This method includes three arguments:
li1-7-2-2-1-1 = The request code you passed to startActivityForResult().
li1-7-2-2-1-2 = A result code specified by the second activity. This is either <code>RESULT_OK</code> if the operation was successful or <code>RESULT_CANCELED</code> if the user backed out or the operation failed for some reason.
li1-7-2-2-1-3 = An Intent that carries the result data.
p1-7-2-2-2 = For example, here's how you can handle the result for the "pick a contact" intent:
p1-7-2-2-3 = In this example, the result Intent returned by Android's Contacts or People app provides a content Uri that identifies the contact the user selected.
p1-7-2-2-4 = In order to successfully handle the result, you must understand what the format of the result Intent will be. Doing so is easy when the activity returning a result is one of your own activities. Apps included with the Android platform offer their own APIs that you can count on for specific result data. For instance, the People app (Contacts app on some older versions) always returns a result with the content URI that identifies the selected contact, and the Camera app returns a Bitmap in the "data" extra (see the class about Capturing Photos).
p1-7-2-2-5 = Bonus: Read the contact data
p1-7-2-2-6 = The code above showing how to get a result from the People app doesn't go into details about how to actually read the data from the result, because it requires more advanced discussion about content providers. However, if you're curious, here's some more code that shows how to query the result data to get the phone number from the selected contact:
nc1-7-2-2-1 = Note: Before Android 2.3 (API level 9), performing a query on the Contacts Provider (like the one shown above) requires that your app declare the <code>READ_CONTACTS</code> permission (see Security and Permissions). However, beginning with Android 2.3, the Contacts/People app grants your app a temporary permission to read from the Contacts Provider when it returns you a result. The temporary permission applies only to the specific contact requested, so you cannot query a contact other than the one specified by the intent's Uri, unless you do declare the <code>READ_CONTACTS</code> permission.

#		**********************************************************************************************************
#		Allowing Other Apps to Start Your Activity
#		**********************************************************************************************************

title1-7-3 = Allowing Other Apps to Start Your Activity
p1-7-3-1 = The previous two lessons focused on one side of the story: starting another app's activity from your app. But if your app can perform an action that might be useful to another app, your app should be prepared to respond to action requests from other apps. For instance, if you build a social app that can share messages or photos with the user's friends, it's in your best interest to support the <code>ACTION_SEND</code> intent so users can initiate a "share" action from another app and launch your app to perform the action.
p1-7-3-2 = To allow other apps to start your activity, you need to add an <code>&lt;intent-filter&gt;</code> element in your manifest file for the corresponding <code>&lt;activity&gt;</code> element.
p1-7-3-3 = When your app is installed on a device, the system identifies your intent filters and adds the information to an internal catalog of intents supported by all installed apps. When an app calls startActivity() or startActivityForResult(), with an implicit intent, the system finds which activity (or activities) can respond to the intent.