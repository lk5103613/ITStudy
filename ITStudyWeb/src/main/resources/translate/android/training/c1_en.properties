
#		**********************************************************************************************************
#		Getting Started
#		**********************************************************************************************************

title1 = Getting Started
p1-1 = Welcome to Training for Android developers. Here you will find sets of lessons within classes that describe how to accomplish a specific task with code samples you can re-use in your app. Classes are organized into several groups you can see at the top-level of the left navigation.
p1-2 = This first group, Getting Started, teaches you the bare essentials for Android app development. If you\'re a new Android app developer, you should complete each of these classes in order:

#		**********************************************************************************************************
#		Building Your First App
#		**********************************************************************************************************

title1-1 = Building Your First App
p1-1-1 = Welcome to Android application development!
p1-1-2 = This class teaches you how to build your first Android app. You\u2019ll learn how to create an Android project and run a debuggable version of the app. You will also learn some fundamentals of Android app design, including how to build a simple user interface and handle user input.
sub_title1-1-1 = Set Up Your Environment
p1-1-3 = Before you start this class, be sure you have your development environment set up. You need to:
p1-1-4 = 1. Download <a href="http://developer.android.com/sdk/index.html">Android Studio</a>.
p1-1-5 = 2. Download the latest SDK tools and platforms using the <a href="http://developer.android.com/tools/help/sdk-manager.html">SDK Manager</a>.
nc1-1-1 = Note: Although most of this training class expects that you are using Android Studio, some procedures include alternative instructions for using the SDK tools from the command line instead.
p1-1-6 = This class uses a tutorial format to create a small Android app that teaches you some fundamental concepts about Android development, so it is important that you follow each step.

#		**********************************************************************************************************
#		Creating an Android Project
#		**********************************************************************************************************

title1-1-1 = Creating an Android Project
p1-1-1-1 = An Android project contains all the files that comprise the source code for your Android app.
p1-1-1-2 = This lesson shows how to create a new project either using Android Studio or using the SDK tools from a command line.
nc1-1-1-1 = Note: You should already have the Android SDK installed, and if you're using Android Studio, you should also have Android Studio installed. If you don't have these, follow the guide to Installing the Android SDK before you start this lesson.
sub_title1-1-1-1 = Create a Project with Android Studio
p1-1-1-3 = In Android Studio, create a new project:
li1-1-1-1-1 = If you don't have a project opened, in the <strong>Welcome</strong> screen, click <strong>New Project</strong>.
li1-1-1-1-2 = If you have a project opened, from the File menu, select <strong>New Project</strong>.
p1-1-1-4 = Under Configure your new project, fill in the fields as shown in figure 1 and click <strong>Next</strong>.
p1-1-1-5 = It will probably be easier to follow these lessons if you use the same values as shown.
li1-1-1-2-1 = <strong>Application Name</strong> is the app name that appears to users. For this project, use "My First App."
li1-1-1-2-2 = <strong>Company domain</strong> provides a qualifier that will be appended to the package name; Android Studio will remember this qualifier for each new project you create.
li1-1-1-2-3 = <strong>Package name</strong> is the fully qualified name for the project (following the same rules as those for naming packages in the Java programming language). Your package name must be unique across all packages installed on the Android system. You can <strong>Edit</strong> this value independently from the application name or the company domain.
li1-1-1-2-4 = <strong>Project location</strong> is the directory on your system that holds the project files.
p1-1-1-6 = Under <strong>Select the form factors your app will run on</strong>, check the box for Phone and Tablet.
p1-1-1-7 = For <strong>Minimum SDK</strong>, select <strong>API 8: Android 2.2 (Froyo)</strong>.
p1-1-1-8 = The Minimum Required SDK is the earliest version of Android that your app supports, indicated using the API level. To support as many devices as possible, you should set this to the lowest version available that allows your app to provide its core feature set. If any feature of your app is possible only on newer versions of Android and it's not critical to the app's core feature set, you can enable the feature only when running on the versions that support it (as discussed in Supporting Different Platform Versions).
p1-1-1-9 = Leave all of the other options (TV, Wear, and Glass) unchecked and click <strong>Next</strong>.
p1-1-1-10 = Under <strong>Add an activity to your project</strong>, select <strong>Blank Activity</strong> and click <strong>Next</strong>.
p1-1-1-11 = Under <strong>Describe the new activity for your project</strong>, leave the fields as they are and click <strong>Finish</strong>.
p1-1-1-12 = Your Android project is now a basic "Hello World" app that contains some default files. Take a moment to review the most important of these:
dt1-1-1-1 = <code>app/src/main/res/layout/activity_my.xml</code>
dd1-1-1-1 = This is the XML layout file for the activity you added when you created the project with Android Studio. Following the New Project workflow, Android Studio presents this file with both a text view and a preview of the screen UI. The file includes some default settings and a TextView element that displays the message, "Hello world!"
dt1-1-1-2 = <code>app/src/main/java/com.mycompany.myfirstapp/MyActivity.java</code>
dd1-1-1-2 = A tab for this file appears in Android Studio when the New Project workflow finishes. When you select the file you see the class definition for the activity you created. When you build and run the app, the Activity class starts the activity and loads the layout file that says "Hello World!"
dt1-1-1-3 = <code>app/src/res/AndroidManifest.xml</code>
dd1-1-1-3 = The manifest file describes the fundamental characteristics of the app and defines each of its components. You'll revisit this file as you follow these lessons and add more components to your app.
dt1-1-1-4 = <code>app/build.gradle</code>
dd1-1-1-4 = Android Studio uses Gradle to compile and build your app. There is a <code>build.gradle</code> file for each module of your project, as well as a <code>build.gradle</code> file for the entire project. Usually, you're only interested in the <code>build.gradle</code> file for the module, in this case the app or application module. This is where your app's build dependencies are set, including the <code>defaultConfig</code> settings:
li1-1-1-3-1 = <code>compiledSdkVersion</code> is the platform version against which you will compile your app. By default, this is set to the latest version of Android available in your SDK. (It should be Android 4.1 or greater; if you don't have such a version available, you must install one using the SDK Manager.) You can still build your app to support older versions, but setting this to the latest version allows you to enable new features and optimize your app for a great user experience on the latest devices.
li1-1-1-3-2 = <code>applicationId</code> is the fully qualified package name for your application that you specified during the New Project workflow.
li1-1-1-3-3 = <code>minSdkVersion</code> is the Minimum SDK version you specified during the New Project workflow. This is the earliest version of the Android SDK that your app supports.
li1-1-1-3-4 = <code>targetSdkVersion</code> indicates the highest version of Android with which you have tested your application. As new versions of Android become available, you should test your app on the new version and update this value to match the latest API level and thereby take advantage of new platform features. For more information, read Supporting Different Platform Versions.
p1-1-1-13 = See Building Your Project with Gradle for more information about Gradle.
p1-1-1-14 = Note also the <code>/res</code> subdirectories that contain the resources for your application:
dt1-1-1-5 = <code>drawable-hdpi/</code>
dd1-1-1-5 = Directory for drawable objects (such as bitmaps) that are designed for high-density (hdpi) screens. Other drawable directories contain assets designed for other screen densities. Here you'll find the ic_launcher.png that appears when you run the default app.
dt1-1-1-6 = <code>layout/</code>
dd1-1-1-6 = Directory for files that define your app's user interface like activity_my.xml, discussed above, which describes a basic layout for the MyActivity class.
dt1-1-1-7 = <code>values/</code>
dd1-1-1-7 = Directory for other XML files that contain a collection of resources, such as string and color definitions. The strings.xml file defines the "Hello world!" string that displays when you run the default app.
p1-1-1-15 = To run the app, continue to the <a href="#c1-1-2">next lesson</a>.
sub_title1-1-1-2 = Create a Project with Command Line Tools
p1-1-1-16 = If you're not using the Android Studio IDE, you can instead create your project using the SDK tools from a command line:
p1-1-1-17 = Change directories into the Android SDK\u2019s <code>tools/</code> path.
p1-1-1-18 = Execute:
p1-1-1-19 = This prints a list of the available Android platforms that you\u2019ve downloaded for your SDK. Find the platform against which you want to compile your app. Make a note of the target ID. We recommend that you select the highest version possible. You can still build your app to support older versions, but setting the build target to the latest version allows you to optimize your app for the latest devices.
p1-1-1-20 = If you don't see any targets listed, you need to install some using the Android SDK Manager tool. See <a href="http://developer.android.com/sdk/installing/adding-packages.html">Adding SDK Packages</a>.
p1-1-1-21 = Execute:
p1-1-1-22 = Replace <code>&lt;target-id&gt;</code> with an ID from the list of targets (from the previous step) and replace <code>&lt;path-to-workspace&gt;</code> with the location in which you want to save your Android projects.
tc1-1-1-1 = Tip: Add the platform-tools/ as well as the tools/ directory to your PATH environment variable.
p1-1-1-23 = Your Android project is now a basic "Hello World" app that contains some default files. To run the app, continue to the <a href="#c1-1-2">next lesson</a>.

#		**********************************************************************************************************
#		Running Your App
#		**********************************************************************************************************

title1-1-2 = Running Your App
p1-1-2-1 = If you followed the <a href="#c1-1-1">previous lesson</a> to create an Android project, it includes a default set of "Hello World" source files that allow you to immediately run the app.
p1-1-2-2 = How you run your app depends on two things: whether you have a real device running Android and whether you're using Android Studio. This lesson shows you how to install and run your app on a real device and on the Android emulator, and in both cases with either Android Studio or the command line tools.
sub_title1-1-2-1 = Run on a Real Device
p1-1-2-3 = If you have a device running Android, here's how to install and run your app.
p1-1-2-4 = Set up your device
li1-1-2-1-1 = Plug in your device to your development machine with a USB cable. If you're developing on Windows, you might need to install the appropriate USB driver for your device. For help installing drivers, see the OEM USB Drivers document.
li1-1-2-1-2 = Enable <strong>USB debugging</strong> on your device.
li1-1-2-2-1 = On most devices running Android 3.2 or older, you can find the option under <strong>Settings > Applications > Development</strong>.
li1-1-2-2-2 = On Android 4.0 and newer, it's in <strong>Settings > Developer options</strong>.
nc1-1-2-1 = Note: On Android 4.2 and newer, <strong>Developer options</strong> is hidden by default. To make it available, go to <strong>Settings > About phone</strong> and tap <strong>Build number</strong> seven times. Return to the previous screen to find <strong>Developer options</strong>.
p1-1-2-5 = Run the app from Android Studio
li1-1-2-3-1 = Select one of your project's files and click <code>Run</code> from the toolbar.
li1-1-2-3-2 = In the <strong>Choose Device</strong> window that appears, select the <strong>Choose a running device</strong> radio button, select your device, and click <strong>OK</strong> .
p1-1-2-6 = Android Studio installs the app on your connected device and starts it.
p1-1-2-7 = Run the app from a command line
li1-1-2-4-1 = Change directories to the root of your Android project and execute:
li1-1-2-4-2 = Make sure the Android SDK <code>platform-tools/</code> directory is included in your PATH environment variable, then execute:
li1-1-2-4-3 = On your device, locate MyFirstApp and open it.
p1-1-2-8 = That's how you build and run your Android app on a device! To start developing, continue to the <a href="#c1-1-3">next lesson</a>.
sub_title1-1-2-2 = Run on the Emulator
p1-1-2-9 = Whether you're using Android Studio or the command line, to run your app on the emulator you need to first create an Android Virtual Device (AVD). An AVD is a device configuration for the Android emulator that allows you to model a specific device.
p1-1-2-10 = Create an AVD
li1-1-2-5-1 = Launch the Android Virtual Device Manager:
li1-1-2-6-1 = In Android Studio, select <strong>Tools > Android > AVD Manager</strong>, or click the AVD Manager icon  in the toolbar.
li1-1-2-6-2 = Or, from the command line, change directories to <code>&lt;sdk&gt;/tools/</code> and execute:
nc1-1-2-2 = Note: The AVD Manager that appears when launched from the command line is different from the version in Android Studio, so the following instructions may not apply.
li1-1-2-5-2 = On the AVD Manager main screen (figure 1), click <strong>Create Virtual Device</strong>.
li1-1-2-5-3 = In the Select Hardware window, select a device configuration, such as Nexus 6, then click <strong>Next</strong>.
li1-1-2-5-4 = Select the desired system version for the AVD and click <strong>Next</strong>.
li1-1-2-5-5 = Verify the configuration settings, then click <strong>Finish</strong>.
p1-1-2-11 = For more information about using AVDs, see Managing AVDs with AVD Manager.
p1-1-2-12 = Run the app from Android Studio
li1-1-2-7-1 = In Android Studio, select your project and click <strong>Run</strong> from the toolbar.
li1-1-2-7-2 = In the <strong>Choose Device</strong> window, click the <strong>Launch emulator</strong> radio button.
li1-1-2-7-3 = From the <strong>Android virtual device</strong> pull-down menu, select the emulator you created, and click <strong>OK</strong>.
p1-1-2-13 = It can take a few minutes for the emulator to load itself. You may have to unlock the screen. When you do, My First App appears on the emulator screen.
p1-1-2-14 = Run your app from the command line
li1-1-2-8-1 = Change directories to the root of your Android project and execute:
li1-1-2-8-2 = Make sure the Android SDK <code>platform-tools/</code> directory is included in your PATH environment variable, then execute:
li1-1-2-8-3 = On the emulator, locate MyFirstApp and open it.
p1-1-2-15 = That's how you build and run your Android app on the emulator! To start developing, continue to the <a href="#c1-1-3">next lesson</a>.

#		**********************************************************************************************************
#		Building a Simple User Interface
#		**********************************************************************************************************

title1-1-3 = Building a Simple User Interface
p1-1-3-1 = In this lesson, you create a layout in XML that includes a text field and a button. In the next lesson, your app responds when the button is pressed by sending the content of the text field to another activity.
p1-1-3-2 = The graphical user interface for an Android app is built using a hierarchy of View and ViewGroup objects. View objects are usually UI widgets such as buttons or text fields. ViewGroup objects are invisible view containers that define how the child views are laid out, such as in a grid or a vertical list.
p1-1-3-3 = Android provides an XML vocabulary that corresponds to the subclasses of View and ViewGroup so you can define your UI in XML using a hierarchy of UI elements.
p1-1-3-4 = Layouts are subclasses of the ViewGroup. In this exercise, you'll work with a LinearLayout.
sub_title1-1-3-1 = Create a Linear Layout
li1-1-3-1-1-1-1 = In Android Studio, from the <code>res/layout</code> directory, open the <code>activity_my.xml</code> file. 
li1-1-3-1-1-1-2 = The BlankActivity template you chose when you created this project includes the <code>activity_my.xml</code> file with a RelativeLayout root view and a TextView child view.
li1-1-3-1-1-2-1 = In the <strong>Preview</strong> pane, click the Hide icon  to close the Preview pane.
li1-1-3-1-1-2-2 = In Android Studio, when you open a layout file, you\u2019re first shown the Preview pane. Clicking elements in this pane opens the WYSIWYG tools in the Design pane. For this lesson, you\u2019re going to work directly with the XML.
li1-1-3-1-1-3 = Delete the %lt;TextView&gt; element.
li1-1-3-1-1-4 = Change the &lt;RelativeLayout&gt; element to &lt;LinearLayout&gt;.
li1-1-3-1-1-5 = Add the android:orientation attribute and set it to <code>"horizontal"</code>.
li1-1-3-1-1-6 = Remove the <code>android:padding</code> attributes and the <code>tools:context</code> attribute.
p1-1-3-1-1 = The result looks like this:
p1-1-3-1-2 = LinearLayout is a view group (a subclass of ViewGroup) that lays out child views in either a vertical or horizontal orientation, as specified by the android:orientation attribute. Each child of a LinearLayout appears on the screen in the order in which it appears in the XML.
p1-1-3-1-3 = Two other attributes, android:layout_width and android:layout_height, are required for all views in order to specify their size.
p1-1-3-1-4 = Because the LinearLayout is the root view in the layout, it should fill the entire screen area that's available to the app by setting the width and height to "match_parent". This value declares that the view should expand its width or height to match the width or height of the parent view.
p1-1-3-1-5 = For more information about layout properties, see the Layout guide.
sub_title1-1-3-2 = Add a Text Field
p1-1-3-2-1 = As with every View object, you must define certain XML attributes to specify the EditText object's properties.
li1-1-3-2-1-1 = In the <code>activity_my.xml</code> file, within the &gt;LinearLayout&lt; element, define an &gt;EditText&lt; element with the <code>id</code> attribute set to <code>@+id/edit_message</code>.
li1-1-3-2-1-2 = Define the <code>layout_width</code> and <code>layout_height</code> attributes as <code>wrap_content</code>.
li1-1-3-2-1-3 = Define a <code>hint</code> attribute as a string object named <code>edit_message</code>.
p1-1-3-2-2 = The &lt;EditText&gt; element should read as follows:
p1-1-3-2-3 = Here are the &lt;EditText&gt; attributes you added:
dt1-1-3-2-1 = <code>android:id</code>
dd1-1-3-2-1-1 = This provides a unique identifier for the view, which you can use to reference the object from your app code, such as to read and manipulate the object (you'll see this in the next lesson).
dd1-1-3-2-1-2 = The at sign (<code>@</code>) is required when you're referring to any resource object from XML. It is followed by the resource type (<code>id</code> in this case), a slash, then the resource name (<code>edit_message</code>).
dd1-1-3-2-1-3 = The plus sign (<code>+</code>) before the resource type is needed only when you're defining a resource ID for the first time. When you compile the app, the SDK tools use the ID name to create a new resource ID in your project's gen/R.java file that refers to the EditText element. With the resource ID declared once this way, other references to the ID do not need the plus sign. Using the plus sign is necessary only when specifying a new resource ID and not needed for concrete resources such as strings or layouts. See the sidebox for more information about resource objects.
dt1-1-3-2-2 = <code>android:layout_width</code> and <code>android:layout_height</code>
dd1-1-3-2-2 = Instead of using specific sizes for the width and height, the <code>"wrap_content"</code> value specifies that the view should be only as big as needed to fit the contents of the view. If you were to instead use <code>"match_parent"</code>, then the <code>EditText</code> element would fill the screen, because it would match the size of the parent LinearLayout. For more information, see the Layouts guide.
dt1-1-3-2-3 = <code>androi:hint</code>
dd1-1-3-2-3 = This is a default string to display when the text field is empty. Instead of using a hard-coded string as the value, the <code>"@string/edit_message"</code> value refers to a string resource defined in a separate file. Because this refers to a concrete resource (not just an identifier), it does not need the plus sign. However, because you haven't defined the string resource yet, you\u2019ll see a compiler error at first. You'll fix this in the next section by defining the string.
nc1-1-3-2-1 = Note: This string resource has the same name as the element ID: <code>edit_message</code>. However, references to resources are always scoped by the resource type (such as id or string), so using the same name does not cause collisions.
sub_title1-1-3-3 = Add String Resources
p1-1-3-3-1 = By default, your Android project includes a string resource file at <code>res/values/strings.xml</code>. Here, you'll add a new string named <code>"edit_message"</code> and set the value to "Enter a message."
li1-1-3-3-1-1 = In Android Studio, from the <code>res/values</code> directory, open <string>strings.xml</code>.
li1-1-3-3-1-2 = Add a line for a string named <code>"edit_message"</code> with the value, "Enter a message".
li1-1-3-3-1-3-1 = Add a line for a string named <code>"button_send"</code> with the value, "Send".
li1-1-3-3-1-3-2 = You'll create the button that uses this string in the next section.
li1-1-3-3-1-4 = Remove the line for the <code>"hello world"</code> string.
p1-1-3-3-2 = The result for <code>strings.xml</code> looks like this:
p1-1-3-3-3 = For text in the user interface, always specify each string as a resource. String resources allow you to manage all UI text in a single location, which makes the text easier to find and update. Externalizing the strings also allows you to localize your app to different languages by providing alternative definitions for each string resource.
p1-1-3-3-4 = For more information about using string resources to localize your app for other languages, see the Supporting Different Devices class.
sub_title1-1-3-4 = Add a Button
li1-1-3-4-1-1 = In Android Studio, from the <code>res/layout</code> directory, edit the <code>activity_my.xml</code> file.
li1-1-3-4-1-2 = Within the <code>&lt;LinearLayout&gt;</code> element, define a <code>&lt;Button&gt;</code> element immediately following the <code>&lt;EditText&gt;</code> element.
li1-1-3-4-1-3 = Set the button's width and height attributes to <code>"wrap_content"</code> so the button is only as big as necessary to fit the button's text label.
li1-1-3-4-1-4 = Define the button's text label with the <code>android:text</code> attribute; set its value to the <code>button_send</code> string resource you defined in the previous section.
p1-1-3-4-1 = Your &lt;LinearLayout&gt; should look like this:
nc1-1-3-4-1 = Note: This button doesn't need the android:id attribute, because it won't be referenced from the activity code.
p1-1-3-4-2 = The layout is currently designed so that both the <code>EditText</code> and <code>Button</code>. widgets are only as big as necessary to fit their content, as shown in figure 2.
p1-1-3-4-3 = This works fine for the button, but not as well for the text field, because the user might type something longer. It would be nice to fill the unused screen width with the text field. You can do this inside a <code>LinearLayout</code> with the weight property, which you can specify using the <code>android:layout_weight</code> attribute.
p1-1-3-4-4 = The weight value is a number that specifies the amount of remaining space each view should consume, relative to the amount consumed by sibling views. This works kind of like the amount of ingredients in a drink recipe: "2 parts soda, 1 part syrup" means two-thirds of the drink is soda. For example, if you give one view a weight of 2 and another one a weight of 1, the sum is 3, so the first view fills 2/3 of the remaining space and the second view fills the rest. If you add a third view and give it a weight of 1, then the first view (with weight of 2) now gets 1/2 the remaining space, while the remaining two each get 1/4.
p1-1-3-4-5 = The default weight for all views is 0, so if you specify any weight value greater than 0 to only one view, then that view fills whatever space remains after all views are given the space they require.
sub_title1-1-3-5 = Make the Input Box Fill in the Screen Width
p1-1-3-5-1 = To fill the remaining space in your layout with the <code>EditText</code> element, do the following:
li1-1-3-5-1-1 = In the <code>activity_my.xml</code> file, assign the <code>&lt;EditText&gt;</code> element's <code>layout_weight</code> attribute a value of 1.
li1-1-3-5-1-2-1 = Also, assign <code>&lt;EditText&gt;</code> element's <code>layout_width</code> attribute a value of <code>0dp</code>.
li1-1-3-5-1-2-2 = To improve the layout efficiency when you specify the weight, you should change the width of the EditText to be zero (0dp). Setting the width to zero improves layout performance because using "wrap_content" as the width requires the system to calculate a width that is ultimately irrelevant because the weight value requires another width calculation to fill the remaining space.
li1-1-3-5-1-2-3 = Figure 3 shows the result when you assign all weight to the <code>EditText</code> element.
p1-1-3-5-2 = Here\u2019s how your complete <code>activity_my.xml</code> layout file should now look:
sub_title1-1-3-6 = Run Your App
p1-1-3-6-1 = This layout is applied by the default Activity class that the SDK tools generated when you created the project. Run the app to see the results:
li1-1-3-6-1-1 = In Android Studio, from the toolbar, click <strong>Run</strong>.
li1-1-3-6-1-2 = Or from a command line, change directories to the root of your Android project and execute:
p1-1-3-6-2 = Continue to the <a href="#c1-1-4">next lesson</a> to learn how to respond to button presses, read content from the text field, start another activity, and more.

#		**********************************************************************************************************
#		Starting Another Activity
#		**********************************************************************************************************

title1-1-4 = Starting Another Activity
p1-1-4-1 = After completing the <a href="#c1-1-3">previous lesson</a>, you have an app that shows an activity (a single screen) with a text field and a button. In this lesson, you\u2019ll add some code to <code>MyActivity</code> that starts a new activity when the user clicks the Send button.
sub_title1-1-4-1 = Respond to the Send Button
li1-1-4-1-1-1 = In Android Studio, from the <code>res/layout</code> directory, edit the <code>activity_my.xml</code> file.
li1-1-4-1-1-2-1 = To the <code>&lt;Button&gt;</code> element, add the <code>android:onClick</code> attribute.
li1-1-4-1-1-2-2 = The <code>android:onClick</code> attribute\u2019s value, <code>"sendMessage"</code>, is the name of a method in your activity that the system calls when the user clicks the button.
li1-1-4-1-1-3 = In the <code>java/com.mycompany.myfirstapp</code> directory, open the MyActivity.java file.
li1-1-4-1-1-4-1 = Within the MyActivity class, add the <code>sendMessage()</code> method stub shown below.
li1-1-4-1-1-4-2 = In order for the system to match this method to the method name given to <code>android:onClick</code>, the signature must be exactly as shown. Specifically, the method must:
li1-1-4-1-2-1 = Be public
li1-1-4-1-2-2 = Have a void return value
li1-1-4-1-2-3 = Have a View as the only parameter (this will be the View that was clicked)
p1-1-4-2 = Next, you\u2019ll fill in this method to read the contents of the text field and deliver that text to another activity.
sub_title1-1-4-2 = Build an Intent
li1-1-4-2-1-1-1 = In <code>MyActivity.java</code>, inside the <code>sendMessage()</code> method, create an Intent to start an activity called <code>DisplayMessageActivity</code> with the following code:
nc1-1-4-2-1 = Note: The reference to <code>DisplayMessageActivity</code> will raise an error if you\u2019re using an IDE such as Android Studio because the class doesn\u2019t exist yet. Ignore the error for now; you\u2019ll create the class soon.
li1-1-4-2-1-1-2 = The constructor used here takes two parameters:
li1-1-4-2-2-1 = A Context as its first parameter (this is used because the Activity class is a subclass of Context) 
li1-1-4-2-2-2 = The Class of the app component to which the system should deliver the Intent (in this case, the activity that should be started)
li1-1-4-2-1-1-3 = Android Studio indicates that you must import the Intent class.
li1-1-4-2-1-2 = At the top of the file, import the Intent class:
tc1-1-4-2-1 = Tip: In Android Studio, press Alt + Enter (option + return on Mac) to import missing classes.
li1-1-4-2-1-3 = Inside the <code>sendMessage()</code> method, use <code>findViewById()</code> to get the EditText element.
li1-1-4-2-1-4-1 = At the top of the file, import the <code>EditText</code> class.
li1-1-4-2-1-4-2 = In Android Studio, press Alt + Enter (option + return on Mac) to import missing classes.
li1-1-4-2-1-5-1 = Assign the text to a local <code>message</code> variable, and use the <code>putExtra()</code> method to add its text value to the intent.
li1-1-4-2-1-5-2 = An Intent can carry data types as key-value pairs called extras. The <code>putExtra()</code> method takes the key name in the first parameter and the value in the second parameter.
li1-1-4-2-1-6-1 = At the top of the <code>MyActivity</code> class, add the <code>EXTRA_MESSAGE</code> definition as follows:
li1-1-4-2-1-6-2 = For the next activity to query the extra data, you should define the key for your intent's extra using a public constant. It's generally a good practice to define keys for intent extras using your app's package name as a prefix. This ensures the keys are unique, in case your app interacts with other apps.
li1-1-4-2-1-7 = In the <code>sendMessage()</code> method, to finish the intent, call the <code>startActivity()</code> method, passing it the Intent object created in step 1.
p1-1-4-2-1 = With this new code, the complete <code>sendMessage()</code> method that's invoked by the Send button now looks like this:
p1-1-4-2-2 = The system receives this call and starts an instance of the Activity specified by the Intent. Now you need to create the <code>DisplayMessageActivity</code> class in order for this to work.
sub_title1-1-4-3 = Create the Second Activity
p1-1-4-3-1 = All subclasses of Activity must implement the <code>onCreate()</code> method. This method is where the activity receives the intent with the message, then renders the message. Also, the <code>onCreate()</code> method must define the activity layout with the <code>setContentView()</code> method. This is where the activity performs the initial setup of the activity components.
p1-1-4-3-2 = Create a new activity using Android Studio
p1-1-4-3-3 = Android Studio includes a stub for the <code>onCreate()</code> method when you create a new activity.
li1-1-4-3-1-1 = In Android Studio, in the java directory, select the package, <strong>com.mycompany.myfirstapp</strong>, right-click, and select <strong>New > Activity > Blank Activity</strong>.
li1-1-4-3-1-2-1 = In the <strong>Choose options</strong> window, fill in the activity details:
li1-1-4-3-2-1 = <strong>Activity Name</strong>: DisplayMessageActivity
li1-1-4-3-2-2 = <strong>Layout Name</strong>: activity_display_message
li1-1-4-3-2-3 = <strong>Title</strong>: My Message
li1-1-4-3-2-4 = <strong>Hierarchical Parent</strong>: com.mycompany.myfirstapp.MyActivity
li1-1-4-3-2-5 = <strong>Package name</strong>: com.mycompany.myfirstapp
li1-1-4-3-1-2-2 = Click <strong>Finish</strong>.
li1-1-4-3-1-3-1 = Open the <code>DisplayMessageActivity.java</code> file.
li1-1-4-3-1-3-2 = The class already includes an implementation of the required <code>onCreate()</code> method. You will update the implementation of this method later. It also includes an implementation of <code>onOptionsItemSelected()</code>, which handles the action bar's Up behavior. Keep these two methods as they are for now.
li1-1-4-3-1-4-1 = Remove the <code>onCreateOptionsMenu()</code> method.
li1-1-4-3-1-4-2 = You won't need it for this app.
p1-1-4-3-4 = If you're developing with Android Studio, you can run the app now, but not much happens. Clicking the Send button starts the second activity, but it uses a default "Hello world" layout provided by the template. You'll soon update the activity to instead display a custom text view.
p1-1-4-3-5 = Create the activity without Android Studio
p1-1-4-3-6 = If you're using a different IDE or the command line tools, do the following:
li1-1-4-3-2-1 = Create a new file named <code>DisplayMessageActivity.java</code> in the project's <code>src/</code> directory, next to the original <code>MyActivity.java</code> file.
li1-1-4-3-2-2 = Add the following code to the file:
nc1-1-4-3-1 = Note: If you are using an IDE other than Android Studio, your project does not contain the <code>activity_display_message</code> layout that's requested by <code>setContentView()</code>. That's OK because you will update this method later and won't be using that layout.
li1-1-4-3-2-3 = To your <code>strings.xml</code> file, add the new activity's title as follows:
li1-1-4-3-2-4 = In your manifest file, <code>AndroidManifest.xml</code>, within the <code>Application element</code>, add the <code>&lt;activity&gt;</code> element for your <code>DisplayMessageActivity</code> class, as follows:
p1-1-4-3-7 = The <code>android:parentActivityName</code> attribute declares the name of this activity's parent activity within the app's logical hierarchy. The system uses this value to implement default navigation behaviors, such as Up navigation on Android 4.1 (API level 16) and higher. You can provide the same navigation behaviors for older versions of Android by using the Support Library and adding the <code>&lt;meta-data&gt;</code> element as shown here.
nc1-1-4-3-2 = Note: Your Android SDK should already include the latest Android Support Library, which you installed during the Adding SDK Packages step. When using the templates in Android Studio, the Support Library is automatically added to your app project (you can see the library's JAR file listed under Android Dependencies). If you're not using Android Studio, you need to manually add the library to your project\u2014follow the guide for setting up the Support Library then return here.
p1-1-4-3-8 = If you're using a different IDE than Android Studio, don't worry that the app won't yet compile. You'll soon update the activity to display a custom text view.
sub_title1-1-4-4 = Receive the Intent
p1-1-4-4-1 = Every <code>Activity</code> is invoked by an <code>Intent</code>, regardless of how the user navigated there. You can get the Intent that started your activity by calling <code>MgetIntent()</code> and retrieve the data contained within the intent.
li1-1-4-4-1-1 = In the <code>java/com.mycompany.myfirstapp</code> directory, edit the <code>DisplayMessageActivity.java</code> file.
li1-1-4-4-1-2 = In the <code>onCreate()</code> method, remove the following line:
li1-1-4-4-1-3 = Get the intent and assign it to a local variable.
li1-1-4-4-1-4-1 = At the top of the file, import the Intent class.
li1-1-4-4-1-4-2 = In Android Studio, press Alt + Enter (option + return on Mac) to import missing classes.
li1-1-4-4-1-5 = Extract the message delivered by <code>MyActivity</code> with the <code>getStringExtra()</code> method.
sub_title1-1-4-5 = Display the Message
li1-1-4-5-1-1 = In the <code>onCreate()</code> method, create a <code>TextView</code> object.
li1-1-4-5-1-2 = Set the text size and message with <code>setText()</code>.
li1-1-4-5-1-3 = Then add the <code>TextView</code> as the root view of the activity\u2019s layout by passing it to <code>setContentView()</code>.
li1-1-4-5-1-4-1 = At the top of the file, import the <code>TextView</code> class.
li1-1-4-5-1-4-2 = In Android Studio, press Alt + Enter (option + return on Mac) to import missing classes.
p1-1-4-5-1 = The complete <code>onCreate()</code> method for <code>DisplayMessageActivity</code> now looks like this:
p1-1-4-5-2 = You can now run the app. When it opens, type a message in the text field, click Send, and the message appears on the second activity.
p1-1-4-5-3 = That's it, you've built your first Android app!
p1-1-4-5-4 = To learn more, follow the link below to the next class.

#		**********************************************************************************************************
#		Adding the Action Bar
#		**********************************************************************************************************

title1-2 = Adding the Action Bar
p1-2-1 = The action bar is one of the most important design elements you can implement for your app's activities. It provides several user interface features that make your app immediately familiar to users by offering consistency between other Android apps. Key functions include:
li1-2-1-1 = A dedicated space for giving your app an identity and indicating the user's location in the app.
li1-2-1-2 = Access to important actions in a predictable way (such as Search).
li1-2-1-3 = Support for navigation and view switching (with tabs or drop-down lists).
p1-2-2 = This training class offers a quick guide to the action bar's basics. For more information about action bar's various features, see the Action Bar guide.

#		**********************************************************************************************************
#		Setting Up the Action Bar
#		**********************************************************************************************************

title1-2-1 = Setting Up the Action Bar
p1-2-1-1 = In its most basic form, the action bar displays the title for the activity and the app icon on the left. Even in this simple form, the action bar is useful for all activities to inform users about where they are and to maintain a consistent identity for your app.
p1-2-1-2 = Setting up a basic action bar requires that your app use an activity theme that enables the action bar. How to request such a theme depends on which version of Android is the lowest supported by your app. So this lesson is divided into two sections depending on which Android version is your lowest supported.
sub_title1-2-1-1 = Support Android 3.0 and Above Only
p1-2-1-1-1 = Beginning with Android 3.0 (API level 11), the action bar is included in all activities that use the <code>Theme.Holo</code> theme (or one of its descendants), which is the default theme when either the <code>targetSdkVersion</code> or <code>minSdkVersion</code> attribute is set to <code>"11"</code> or greater.
p1-2-1-1-2 = So to add the action bar to your activities, simply set either attribute to <code>11</code> or higher. For example:
nc1-2-1-1 = Note: If you've created a custom theme, be sure it uses one of the <code>Theme.Holo</code> themes as its parent. For details, see Styling the Action Bar.
p1-2-1-1-3 = Now the <code>Theme.Holo</code> theme is applied to your app and all activities show the action bar. That's it.
sub_title1-2-1-2 = Support Android 2.1 and Above
p1-2-1-2-1 = Adding the action bar when running on versions older than Android 3.0 (down to Android 2.1) requires that you include the Android Support Library in your application.
p1-2-1-2-2 = To get started, read the Support Library Setup document and set up the <strong>v7 appcompat</strong> library (once you've downloaded the library package, follow the instructions for Adding libraries with resources).
p1-2-1-2-3 = Once you have the Support Library integrated with your app project:
li1-2-1-2-1-1 = Update your activity so that it extends <code>ActionBarActivity</code>. For example:
li1-2-1-2-1-2 = In your manifest file, update either the <code>&lt;application&gt;</code> element or individual <code>&lt;activity&gt;</code> elements to use one of the Theme.AppCompat themes. For example:
nc1-2-1-2-1 = Note: If you've created a custom theme, be sure it uses one of the <code>Theme.AppCompat</code> themes as its parent. For details, see Styling the Action Bar.
p1-2-1-2-4 = Now your activity includes the action bar when running on Android 2.1 (API level 7) or higher.
p1-2-1-2-5 = Remember to properly set your app's API level support in the manifest:

#		**********************************************************************************************************
#		Adding Action Buttons
#		**********************************************************************************************************

title1-2-2 = Adding Action Buttons
p1-2-2-1 = The action bar allows you to add buttons for the most important action items relating to the app's current context. Those that appear directly in the action bar with an icon and/or text are known as action buttons. Actions that can't fit in the action bar or aren't important enough are hidden in the action overflow.
sub_title1-2-2-1 = Specify the Actions in XML
p1-2-2-1-1 = All action buttons and other items available in the action overflow are defined in an XML <code>menu resource</code>. To add actions to the action bar, create a new XML file in your project's <code>res/menu/</code> directory.
p1-2-2-1-2 = Add an <code>&lt;item&gt;</code> element for each item you want to include in the action bar. For example:
p1-2-2-1-3 = This declares that the Search action should appear as an action button when room is available in the action bar, but the Settings action should always appear in the overflow. (By default, all actions appear in the overflow, but it's good practice to explicitly declare your design intentions for each action.)
p1-2-2-1-4 = The icon attribute requires a resource ID for an image. The name that follows <code>@drawable/</code> must be the name of a bitmap image you've saved in your project's <code>res/drawable/</code> directory. For example, "<code>@drawable/ic_action_search</code>" refers to <code>ic_action_search.png</code>. Likewise, the title attribute uses a string resource that's defined by an XML file in your project's <code>res/values/</code> directory, as discussed in Building a Simple User Interface.
nc1-2-2-1-1 = Note: When creating icons and other bitmap images for your app, it's important that you provide multiple versions that are each optimized for a different screen density. This is discussed more in the lesson about Supporting Different Screens.
p1-2-2-1-5 = <strong>If your app is using the Support Library</strong> for compatibility on versions as low as Android 2.1, the showAsAction attribute is not available from the android: namespace. Instead this attribute is provided by the Support Library and you must define your own XML namespace and use that namespace as the attribute prefix. (A custom XML namespace should be based on your app name, but it can be any name you want and is only accessible within the scope of the file in which you declare it.) For example:
sub_title1-2-2-2 = Add the Actions to the Action Bar
p1-2-2-2-1 = To place the menu items into the action bar, implement the <code>onCreateOptionsMenu()</code> callback method in your activity to inflate the menu resource into the given <code>Menu</code> object. For example:
sub_title1-2-2-3 = Respond to Action Buttons
p1-2-2-3-1 = When the user presses one of the action buttons or another item in the action overflow, the system calls your activity's <code>onOptionsItemSelected()</code> callback method. In your implementation of this method, call <code>getItemId()</code> on the given MenuItem to determine which item was pressed\u2014the returned ID matches the value you declared in the corresponding <code>&lt;item&gt;</code> element's android:id attribute.
sub_title1-2-2-4 = Respond to Action Buttons
p1-2-2-4-1 = When the user presses one of the action buttons or another item in the action overflow, the system calls your activity's <code>onOptionsItemSelected()</code> callback method. In your implementation of this method, call <code>getItemId()</code> on the given <code>MenuItem</code> to determine which item was pressed\u2014the returned ID matches the value you declared in the corresponding <code>&lt;item&gt;</code> element's <code>android:id</code> attribute.
sub_title1-2-2-5 = Add Up Button for Low-level Activities
p1-2-2-5-1 = All screens in your app that are not the main entrance to your app (activities that are not the "home" screen) should offer the user a way to navigate to the logical parent screen in the app's hierarchy by pressing the Up button in the action bar.
p1-2-2-5-2 = When running on Android 4.1 (API level 16) or higher, or when using <code>ActionBarActivity</code> from the Support Library, performing Up navigation simply requires that you declare the parent activity in the manifest file and enable the Up button for the action bar.
p1-2-2-5-3 = For example, here's how you can declare an activity's parent in the manifest:
p1-2-2-5-4 = Then enable the app icon as the Up button by calling <code>setDisplayHomeAsUpEnabled()</code>:
p1-2-2-5-5 = Because the system now knows <code>MainActivity</code> is the parent activity for <code>DisplayMessageActivity</code>, when the user presses the Up button, the system navigates to the parent activity as appropriate\u2014you do not need to handle the Up button's event.
p1-2-2-5-6 = For more information about up navigation, see Providing Up Navigation.

#		**********************************************************************************************************
#		Styling the Action Bar
#		**********************************************************************************************************

title1-2-3 = Styling the Action Bar
p1-2-3-1 = The action bar provides your users a familiar and predictable way to perform actions and navigate your app, but that doesn't mean it needs to look exactly the same as it does in other apps. If you want to style the action bar to better fit your product brand, you can easily do so using Android's style and theme resources.
p1-2-3-2 = Android includes a few built-in activity themes that include "dark" or "light" action bar styles. You can also extend these themes to further customize the look for your action bar.
nc1-2-3-1 = Note: If you are using the Support Library APIs for the action bar, then you must use (or override) the Theme.AppCompat family of styles (rather than the Theme.Holo family, available in API level 11 and higher). In doing so, each style property that you declare must be declared twice: once using the platform's style properties (the android: properties) and once using the style properties included in the Support Library (the appcompat.R.attr properties\u2014the context for these properties is actually your app). See the examples below for details.
sub_title1-2-3-1 = Use an Android Theme
p1-2-3-1-1 = Android includes two baseline activity themes that dictate the color for the action bar:
li1-2-3-1-1-1 = <code>Theme.Holo</code> for a "dark" theme.
li1-2-3-1-1-2 = <code>Theme.Holo.Light</code> for a "light" theme.
p1-2-3-1-2 = You can apply these themes to your entire app or to individual activities by declaring them in your manifest file with the <code>android:theme</code> attribute for the <code>&lt;application&gt;</code> element or individual <code>&lt;activity&gt;</code> elements.
p1-2-3-1-3 = For example:
p1-2-3-1-4 = You can also use a dark action bar while the rest of the activity uses the light color scheme by declaring the <code>Theme.Holo.Light.DarkActionBar</code> theme.
p1-2-3-1-5 = When using the Support Library, you must instead use the <code>Theme.AppCompat</code> themes:
li1-2-3-1-1-1 = <code>Theme.AppCompat</code> for the "dark" theme.
li1-2-3-1-1-2 = <code>Theme.AppCompat.Light</code> for the "light" theme.
li1-2-3-1-1-3 = <code>Theme.AppCompat.Light.DarkActionBar</code> for the light theme with a dark action bar.
p1-2-3-1-6 = Be sure that you use action bar icons that properly contrast with the color of your action bar. To help you, the Action Bar Icon Pack includes standard action icons for use with both the Holo light and Holo dark action bar.
sub_title1-2-3-2 = Customize the Background
p1-2-3-2-1 = To change the action bar background, create a custom theme for your activity that overrides the <code>actionBarStyle</code> property. This property points to another style in which you can override the <code>background</code> property to specify a drawable resource for the action bar background.
p1-2-3-2-2 = If your app uses <code>navigation tabs</code> or the <code>split action bar</code>, then you can also specify the background for these bars using the <code>backgroundStacked</code> and <code>backgroundSplit</code> properties, respectively.
cc1-2-3-2-1 = Caution: It's important that you declare an appropriate parent theme from which your custom theme and style inherit their styles. Without a parent style, your action bar will be without many style properties unless you explicitly declare them yourself.
p1-2-3-2-3 = For Android 3.0 and higher only
p1-2-3-2-4 = When supporting Android 3.0 and higher only, you can define the action bar's background like this:
p1-2-3-2-5 = Then apply your theme to your entire app or individual activities:
p1-2-3-2-6 = For Android 2.1 and higher
p1-2-3-2-7 = When using the Support Library, the same theme as above must instead look like this:
p1-2-3-2-8 = Then apply your theme to your entire app or individual activities:
sub_title1-2-3-3 = Customize the Text Color
p1-2-3-3-1 = To modify the color of text in the action bar, you need to override separate properties for each text element:
li1-2-3-3-1-1 = Action bar title: Create a custom style that specifies the textColor property and specify that style for the <code>titleTextStyle</code> property in your custom <code>actionBarStyle</code>.
nc1-2-3-3-1 = Note: The custom style applied to <code>titleTextStyle</code> should use <code>TextAppearance.Holo.Widget.ActionBar</code>.Title as the parent style.
li1-2-3-3-1-2 = Action bar tabs: Override <code>actionBarTabTextStyle</code>. in your activity theme.
li1-2-3-3-1-3 = Action buttons: Override <code>actionMenuTextColor</code> in your activity theme.
p1-2-3-3-2 = For Android 3.0 and higher only
p1-2-3-3-3 = When supporting Android 3.0 and higher only, your style XML file might look like this:
p1-2-3-3-4 = For Android 2.1 and higher
p1-2-3-3-5 = When using the Support Library, your style XML file might look like this:
sub_title1-2-3-4 = Customize the Tab Indicator
p1-2-3-4-1 = To change the indicator used for the <code>navigation tabs</code>, create an activity theme that overrides the <code>actionBarTabStyle</code> property. This property points to another style resource in which you override the <code>background</code> property that should specify a state-list drawable.
nc1-2-3-4-1 = Note: A state-list drawable is important so that the tab currently selected indicates its state with a background different than the other tabs. For more information about how to create a drawable resource that handles multiple button states, read the State List documentation.
p1-2-3-4-2 = For example, here's a state-list drawable that declares a specific background image for several different states of an action bar tab:
p1-2-3-4-3 = For Android 3.0 and higher only
p1-2-3-4-4 = When supporting Android 3.0 and higher only, your style XML file might look like this:
p1-2-3-4-5 = For Android 2.1 and higher
p1-2-3-4-6 = When using the Support Library, your style XML file might look like this:

#		**********************************************************************************************************
#		Overlaying the Action Bar
#		**********************************************************************************************************

title1-2-4 = Overlaying the Action Bar
p1-2-4-1 = By default, the action bar appears at the top of your activity window, slightly reducing the amount of space available for the rest of your activity's layout. If, during the course of user interaction, you want to hide and show the action bar, you can do so by calling <code>hide()</code> and <code>show()</code> on the ActionBar. However, this causes your activity to recompute and redraw the layout based on its new size.
p1-2-4-2 = To avoid resizing your layout when the action bar hides and shows, you can enable overlay mode for the action bar. When in overlay mode, your activity layout uses all the space available as if the action bar is not there and the system draws the action bar in front of your layout. This obscures some of the layout at the top, but now when the action bar hides or appears, the system does not need to resize your layout and the transition is seamless.
tc1-2-4-1 = Tip: If you want your layout to be partially visible behind the action bar, create a custom style for the action bar with a partially transparent background, such as the one shown in figure 1. For information about how to define the action bar background, read <a href="#c1-2-3">Styling the Action Bar</a>.
sub_title1-2-4-1 = Enable Overlay Mode
p1-2-4-1-1 = To enable overlay mode for the action bar, you need to create a custom theme that extends an existing action bar theme and set the <code>android:windowActionBarOverlay</code> property to <code>true</code>.
p1-2-4-1-2 = For Android 3.0 and higher only
p1-2-4-1-3 = If your <code>minSdkVersion</code> is set to 11 or higher, your custom theme should use <code>Theme.Holo</code> theme (or one of its descendants) as your parent theme. For example:
p1-2-4-1-4 = For Android 2.1 and higher
p1-2-4-1-5 = If your app is using the Support Library for compatibility on devices running versions lower than Android 3.0, your custom theme should use <code>Theme.AppCompat</code> theme (or one of its descendants) as your parent theme. For example:
p1-2-4-1-6 = Also notice that this theme includes two definitions for the <code>windowActionBarOverlay</code> style: one with the <code>android:</code> prefix and one without. The one with the android: prefix is for versions of Android that include the style in the platform and the one without the prefix is for older versions that read the style from the Support Library.
sub_title1-2-4-2 = Specify Layout Top-margin
p1-2-4-2-1 = When the action bar is in overlay mode, it might obscure some of your layout that should remain visible. To ensure that such items remain below the action bar at all times, add either margin or padding to the top of the view(s) using the height specified by <code>actionBarSize</code>. For example:
p1-2-4-2-2 = If you're using the Support Library for the action bar, you need to remove the <code>android:</code> prefix. For example:
p1-2-4-2-3 = In this case, the <code>?attr/actionBarSize</code> value without the prefix works on all versions, including Android 3.0 and higher.

#		**********************************************************************************************************
#		Supporting Different Devices
#		**********************************************************************************************************

title1-3 = Supporting Different Devices
p1-3-1 = Android devices come in many shapes and sizes all around the world. With a wide range of device types, you have an opportunity to reach a huge audience with your app. In order to be as successful as possible on Android, your app needs to adapt to various device configurations. Some of the important variations that you should consider include different languages, screen sizes, and versions of the Android platform.
p1-3-2 = This class teaches you how to use basic platform features that leverage alternative resources and other features so your app can provide an optimized user experience on a variety of Android-compatible devices, using a single application package (APK).

#		**********************************************************************************************************
#		Supporting Different Languages
#		**********************************************************************************************************

title1-3-1 = Supporting Different Languages
p1-3-1-1 = It\u2019s always a good practice to extract UI strings from your app code and keep them in an external file. Android makes this easy with a resources directory in each Android project.
p1-3-1-2 = If you created your project using the Android SDK Tools (read Creating an Android Project), the tools create a <code>res/</code> directory in the top level of the project. Within this <code>res/</code> directory are subdirectories for various resource types. There are also a few default files such as <code>res/values/strings.xml</code>, which holds your string values.
sub_title1-3-1-1 = Create Locale Directories and String Files
p1-3-1-1-1 = To add support for more languages, create additional <code>values</code> directories inside <code>res/</code> that include a hyphen and the ISO language code at the end of the directory name. For example, <code>values-es/</code> is the directory containing simple resourcess for the Locales with the language code "es". Android loads the appropriate resources according to the locale settings of the device at run time. For more information, see Providing Alternative Resources.
p1-3-1-1-2 = Once you\u2019ve decided on the languages you will support, create the resource subdirectories and string resource files. For example:
p1-3-1-1-3 = Add the string values for each locale into the appropriate file.
p1-3-1-1-4 = At runtime, the Android system uses the appropriate set of string resources based on the locale currently set for the user's device.
p1-3-1-1-5 = For example, the following are some different string resource files for different languages.
p1-3-1-1-6 = English (default locale), <code>/values/strings.xml:</code>
p1-3-1-1-7 = Spanish, <code>/values-es/strings.xml:</code>
p1-3-1-1-8 = French, <code>/values-fr/strings.xml:</code>
nc1-3-1-1-1 = Note: You can use the locale qualifier (or any configuration qualifer) on any resource type, such as if you want to provide localized versions of your bitmap drawable. For more information, see Localization.
sub_title1-3-1-2 = Use the String Resources
p1-3-1-2-1 = You can reference your string resources in your source code and other XML files using the resource name defined by the <code>&lt;string&gt;</code> element's <code>name</code> attribute.
p1-3-1-2-2 = In your source code, you can refer to a string resource with the syntax <code>R.string.&lt;string_name&gt;</code>. There are a variety of methods that accept a string resource this way.
p1-3-1-2-3 = For example:
p1-3-1-2-4 = In other XML files, you can refer to a string resource with the syntax <code>@string/&lt;string_name&gt;</code> whenever the XML attribute accepts a string value.
p1-3-1-2-5 = For example:

#		**********************************************************************************************************
#		Supporting Different Screens
#		**********************************************************************************************************

title1-3-2 = Android categorizes device screens using two general properties: size and density. You should expect that your app will be installed on devices with screens that range in both size and density. As such, you should include some alternative resources that optimize your app\u2019s appearance for different screen sizes and densities.
p1-3-2-1 = Android categorizes device screens using two general properties: size and density. You should expect that your app will be installed on devices with screens that range in both size and density. As such, you should include some alternative resources that optimize your app\u2019s appearance for different screen sizes and densities.
li1-3-2-1-1 = There are four generalized sizes: small, normal, large, xlarge
li1-3-2-1-2 = And four generalized densities: low (ldpi), medium (mdpi), high (hdpi), extra high (xhdpi)
p1-3-2-2 = To declare different layouts and bitmaps you'd like to use for different screens, you must place these alternative resources in separate directories, similar to how you do for different language strings.
p1-3-2-3 = Also be aware that the screens orientation (landscape or portrait) is considered a variation of screen size, so many apps should revise the layout to optimize the user experience in each orientation.
sub_title1-3-2-1 = Create Different Layouts
p1-3-2-1-1 = To optimize your user experience on different screen sizes, you should create a unique layout XML file for each screen size you want to support. Each layout should be saved into the appropriate resources directory, named with a -<code>&lt;screen_size&gt;</code> suffix. For example, a unique layout for large screens should be saved under <code>res/layout-large/</code>.
nc1-3-2-1-1 = Note: Android automatically scales your layout in order to properly fit the screen. Thus, your layouts for different screen sizes don't need to worry about the absolute size of UI elements but instead focus on the layout structure that affects the user experience (such as the size or position of important views relative to sibling views).
p1-3-2-1-2 = For example, this project includes a default layout and an alternative layout for large screens:
p1-3-2-1-3 = The file names must be exactly the same, but their contents are different in order to provide an optimized UI for the corresponding screen size.
p1-3-2-1-4 = Simply reference the layout file in your app as usual:
p1-3-2-1-5 = The system loads the layout file from the appropriate layout directory based on screen size of the device on which your app is running. More information about how Android selects the appropriate resource is available in the Providing Resources guide.
p1-3-2-1-6 = As another example, here's a project with an alternative layout for landscape orientation:
p1-3-2-1-7 = By default, the <code>layout/main.xml</code> file is used for portrait orientation.
p1-3-2-1-8 = If you want to provide a special layout for landscape, including while on large screens, then you need to use both the <code>large</code> and <code>land</code> qualifier:
nc1-3-2-1-2 = Note: Android 3.2 and above supports an advanced method of defining screen sizes that allows you to specify resources for screen sizes based on the minimum width and height in terms of density-independent pixels. This lesson does not cover this new technique. For more information, read Designing for Multiple Screens.
sub_title1-3-2-2 = Create Different Bitmaps
p1-3-2-2-1 = You should always provide bitmap resources that are properly scaled to each of the generalized density buckets: low, medium, high and extra-high density. This helps you achieve good graphical quality and performance on all screen densities.
p1-3-2-2-2 = To generate these images, you should start with your raw resource in vector format and generate the images for each density using the following size scale:
li1-3-2-2-1-1 = xhdpi: 2.0
li1-3-2-2-1-2 = hdpi: 1.5
li1-3-2-2-1-3 = mdpi: 1.0 (baseline)
li1-3-2-2-1-4 = ldpi: 0.75
p1-3-2-2-3 = This means that if you generate a 200x200 image for xhdpi devices, you should generate the same resource in 150x150 for hdpi, 100x100 for mdpi, and 75x75 for ldpi devices.
p1-3-2-2-4 = Then, place the files in the appropriate drawable resource directory:
p1-3-2-2-5 = Any time you reference <code>@drawable/awesomeimage</code>, the system selects the appropriate bitmap based on the screen's density.
nc1-3-2-2-1 = Note: Low-density (ldpi) resources aren\u2019t always necessary. When you provide hdpi assets, the system scales them down by one half to properly fit ldpi screens.
p1-3-2-2-6 = For more tips and guidelines about creating icon assets for your app, see the Iconography design guide.

#		**********************************************************************************************************
#		Supporting Different Platform Versions
#		**********************************************************************************************************

title1-3-3 = Supporting Different Platform Versions
p1-3-3-1 = While the latest versions of Android often provide great APIs for your app, you should continue to support older versions of Android until more devices get updated. This lesson shows you how to take advantage of the latest APIs while continuing to support older versions as well.
p1-3-3-2 = The dashboard for Platform Versions is updated regularly to show the distribution of active devices running each version of Android, based on the number of devices that visit the Google Play Store. Generally, it\u2019s a good practice to support about 90% of the active devices, while targeting your app to the latest version.
tc1-3-3-1 = Tip: In order to provide the best features and functionality across several Android versions, you should use the Android Support Library in your app, which allows you to use several recent platform APIs on older versions.
sub_title1-3-3-1 = Specify Minimum and Target API Levels
p1-3-3-1-1 = The <code>AndroidManifest.xml</code> file describes details about your app and identifies which versions of Android it supports. Specifically, the <code>minSdkVersion</code> and <code>targetSdkVersion</code> attributes for the <code>&lt;uses-sdk&gt;</code> element identify the lowest API level with which your app is compatible and the highest API level against which you\u2019ve designed and tested your app.
p1-3-3-1-2 = For example:
p1-3-3-1-3 = As new versions of Android are released, some style and behaviors may change. To allow your app to take advantage of these changes and ensure that your app fits the style of each user's device, you should set the <code>targetSdkVersion</code> value to match the latest Android version available.
sub_title1-3-3-2 = Check System Version at Runtime
p1-3-3-2-1 = Android provides a unique code for each platform version in the <code>Build</code> constants class. Use these codes within your app to build conditions that ensure the code that depends on higher API levels is executed only when those APIs are available on the system.
nc1-3-3-2-1 = Note: When parsing XML resources, Android ignores XML attributes that aren\u2019t supported by the current device. So you can safely use XML attributes that are only supported by newer versions without worrying about older versions breaking when they encounter that code. For example, if you set the <code>targetSdkVersion="11"</code>, your app includes the <code>ActionBar</code> by default on Android 3.0 and higher. To then add menu items to the action bar, you need to set <code>android:showAsAction="ifRoom"</code> in your menu resource XML. It's safe to do this in a cross-version XML file, because the older versions of Android simply ignore the <code>showAsAction</code> attribute (that is, you do not need a separate version in <code>res/menu-v11/</code>).
sub_title1-3-3-3 = Use Platform Styles and Themes
p1-3-3-3-1 = Android provides user experience themes that give apps the look and feel of the underlying operating system. These themes can be applied to your app within the manifest file. By using these built in styles and themes, your app will naturally follow the latest look and feel of Android with each new release.
p1-3-3-3-2 = To make your activity look like a dialog box:
p1-3-3-3-3 = To make your activity have a transparent background:
p1-3-3-3-4 = To apply your own custom theme defined in <code>/res/values/styles.xml</code>:
p1-3-3-3-5 = To apply a theme to your entire app (all activities), add the <code>android:theme</code> attribute to the <code>&lt;application&gt;</code> element:
p1-3-3-3-6 = For more about creating and using themes, read the Styles and Themes guide.

#		**********************************************************************************************************
#		Managing the Activity Lifecycle
#		**********************************************************************************************************

title1-4 = Managing the Activity Lifecycle
p1-4-1 = As a user navigates through, out of, and back to your app, the Activity instances in your app transition between different states in their lifecycle. For instance, when your activity starts for the first time, it comes to the foreground of the system and receives user focus. During this process, the Android system calls a series of lifecycle methods on the activity in which you set up the user interface and other components. If the user performs an action that starts another activity or switches to another app, the system calls another set of lifecycle methods on your activity as it moves into the background (where the activity is no longer visible, but the instance and its state remains intact).
p1-4-2 = Within the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity. For example, if you're building a streaming video player, you might pause the video and terminate the network connection when the user switches to another app. When the user returns, you can reconnect to the network and allow the user to resume the video from the same spot.
p1-4-3 = This class explains important lifecycle callback methods that each Activity instance receives and how you can use them so your activity does what the user expects and does not consume system resources when your activity doesn't need them.

#		**********************************************************************************************************
#		Starting an Activity
#		**********************************************************************************************************

title1-4-1 = Starting an Activity
p1-4-1-1 = Unlike other programming paradigms in which apps are launched with a main() method, the Android system initiates code in an Activity instance by invoking specific callback methods that correspond to specific stages of its lifecycle. There is a sequence of callback methods that start up an activity and a sequence of callback methods that tear down an activity.
p1-4-1-2 = This lesson provides an overview of the most important lifecycle methods and shows you how to handle the first lifecycle callback that creates a new instance of your activity.
sub_title1-4-1-1 = Understand the Lifecycle Callbacks
p1-4-1-1-1 = During the life of an activity, the system calls a core set of lifecycle methods in a sequence similar to a step pyramid. That is, each stage of the activity lifecycle is a separate step on the pyramid. As the system creates a new activity instance, each callback method moves the activity state one step toward the top. The top of the pyramid is the point at which the activity is running in the foreground and the user can interact with it.
p1-4-1-1-2 = As the user begins to leave the activity, the system calls other methods that move the activity state back down the pyramid in order to dismantle the activity. In some cases, the activity will move only part way down the pyramid and wait (such as when the user switches to another app), from which point the activity can move back to the top (if the user returns to the activity) and resume where the user left off.
p1-4-1-1-3 = Depending on the complexity of your activity, you probably don't need to implement all the lifecycle methods. However, it's important that you understand each one and implement those that ensure your app behaves the way users expect. Implementing your activity lifecycle methods properly ensures your app behaves well in several ways, including that it:
li1-4-1-1-1-1 = Does not crash if the user receives a phone call or switches to another app while using your app.
li1-4-1-1-1-2 = Does not consume valuable system resources when the user is not actively using it.
li1-4-1-1-1-3 = Does not lose the user's progress if they leave your app and return to it at a later time.
li1-4-1-1-1-4 = Does not crash or lose the user's progress when the screen rotates between landscape and portrait orientation.
p1-4-1-1-4 = As you'll learn in the following lessons, there are several situations in which an activity transitions between different states that are illustrated in figure 1. However, only three of these states can be static. That is, the activity can exist in one of only three states for an extended period of time:
dt1-4-1-1-1-1 = Resumed
dd1-4-1-1-1-1 = In this state, the activity is in the foreground and the user can interact with it. (Also sometimes referred to as the "running" state.)
dt1-4-1-1-1-2 = Paused
dd1-4-1-1-1-2 = In this state, the activity is partially obscured by another activity\u2014the other activity that's in the foreground is semi-transparent or doesn't cover the entire screen. The paused activity does not receive user input and cannot execute any code.
dt1-4-1-1-1-3 = Stopped
dd1-4-1-1-1-3 = In this state, the activity is completely hidden and not visible to the user; it is considered to be in the background. While stopped, the activity instance and all its state information such as member variables is retained, but it cannot execute any code.
p1-4-1-1-5 = The other states (Created and Started) are transient and the system quickly moves from them to the next state by calling the next lifecycle callback method. That is, after the system calls <code>onCreate()</code>, it quickly calls <code>onStart()</code>, which is quickly followed by <code>onResume()</code>.
p1-4-1-1-6 = That's it for the basic activity lifecycle. Now you'll start learning about some of the specific lifecycle behaviors.
sub_title1-4-1-2 = Specify Your App's Launcher Activity
p1-4-1-2-1 = When the user selects your app icon from the Home screen, the system calls the <code>onCreate()</code> method for the Activity in your app that you've declared to be the "launcher" (or "main") activity. This is the activity that serves as the main entry point to your app's user interface.
p1-4-1-2-2 = You can define which activity to use as the main activity in the Android manifest file, <code>AndroidManifest.xml</code>, which is at the root of your project directory.
p1-4-1-2-3 = The main activity for your app must be declared in the manifest with an <code>&lt;intent-filter&gt;</code> that includes the MAIN action and LAUNCHER category. For example:
nc1-4-1-2-1 = Note: When you create a new Android project with the Android SDK tools, the default project files include an Activity class that's declared in the manifest with this filter.
p1-4-1-2-4 = If either the MAIN action or LAUNCHER category are not declared for one of your activities, then your app icon will not appear in the Home screen's list of apps.
sub_title1-4-1-3 = Create a New Instance
p1-4-1-3-1 = Most apps include several different activities that allow the user to perform different actions. Whether an activity is the main activity that's created when the user clicks your app icon or a different activity that your app starts in response to a user action, the system creates every new instance of Activity by calling its <code>onCreate()</code> method.
p1-4-1-3-2 = You must implement the <code>onCreate()</code> method to perform basic application startup logic that should happen only once for the entire life of the activity. For example, your implementation of <code>onCreate()</code> should define the user interface and possibly instantiate some class-scope variables.
p1-4-1-3-3 = For example, the following example of the <code>onCreate()</code> method shows some code that performs some fundamental setup for the activity, such as declaring the user interface (defined in an XML layout file), defining member variables, and configuring some of the UI.
cc1-4-1-3-1 = Caution: Using the <code>SDK_INT</code> to prevent older systems from executing new APIs works in this way on Android 2.0 (API level 5) and higher only. Older versions will encounter a runtime exception.
p1-4-1-3-4 = Once the <code>onCreate()</code> finishes execution, the system calls the <code>onStart()</code> and <code>onResume()</code> methods in quick succession. Your activity never resides in the Created or Started states. Technically, the activity becomes visible to the user when <code>onStart()</code> is called, but <code>onResume()</code> quickly follows and the activity remains in the Resumed state until something occurs to change that, such as when a phone call is received, the user navigates to another activity, or the device screen turns off.
p1-4-1-3-5 = In the other lessons that follow, you'll see how the other start up methods, <code>onStart()</code> and <code>onResume()</code>, are useful during your activity's lifecycle when used to resume the activity from the Paused or Stopped states.
nc1-4-1-3-1 = Note: The <code>onCreate()</code> method includes a parameter called <code>savedInstanceState</code> that's discussed in the latter lesson about Recreating an Activity.
sub_title1-4-1-4 = Destroy the Activity
p1-4-1-4-1 = While the activity's first lifecycle callback is <code>onCreate()</code>, its very last callback is <code>onDestroy()</code>. The system calls this method on your activity as the final signal that your activity instance is being completely removed from the system memory.
p1-4-1-4-2 = Most apps don't need to implement this method because local class references are destroyed with the activity and your activity should perform most cleanup during <code>onPause()</code> and <code>onStop()</code>. However, if your activity includes background threads that you created during <code>onCreate()</code> or other long-running resources that could potentially leak memory if not properly closed, you should kill them during <code>onDestroy()</code>.
nc1-4-1-4-1 = Note: The system calls <code>onDestroy()</code> after it has already called <code>onPause()</code> and <code>onStop()</code> in all situations except one: when you call <code>finish()</code> from within the <code>onCreate()</code. method. In some cases, such as when your activity operates as a temporary decision maker to launch another activity, you might call <code>finish()</code> from within <code>onCreate()</code> to destroy the activity. In this case, the system immediately calls <code>onDestroy()</code> without calling any of the other lifecycle methods.

#		**********************************************************************************************************
#		Pausing and Resuming an Activity
#		**********************************************************************************************************

title1-4-2 = Pausing and Resuming an Activity
p1-4-2-1 = During normal app use, the foreground activity is sometimes obstructed by other visual components that cause the activity to pause. For example, when a semi-transparent activity opens (such as one in the style of a dialog), the previous activity pauses. As long as the activity is still partially visible but currently not the activity in focus, it remains paused.
p1-4-2-2 = However, once the activity is fully-obstructed and not visible, it stops (which is discussed in the next lesson).
p1-4-2-3 = As your activity enters the paused state, the system calls the <code>onPause()</code> method on your Activity, which allows you to stop ongoing actions that should not continue while paused (such as a video) or persist any information that should be permanently saved in case the user continues to leave your app. If the user returns to your activity from the paused state, the system resumes it and calls the <code>onResume()</code> method.
nc1-4-2-1 = Note: When your activity receives a call to <code>onPause()</code>, it may be an indication that the activity will be paused for a moment and the user may return focus to your activity. However, it's usually the first indication that the user is leaving your activity.
sub_title1-4-2-1 = Pause Your Activity
p1-4-2-1-1 = When the system calls <code>onPause()</code> for your activity, it technically means your activity is still partially visible, but most often is an indication that the user is leaving the activity and it will soon enter the Stopped state. You should usually use the <code>onPause()</code> callback to:
li1-4-2-1-1-1 = Stop animations or other ongoing actions that could consume CPU.
li1-4-2-1-1-2 = Commit unsaved changes, but only if users expect such changes to be permanently saved when they leave (such as a draft email).
li1-4-2-1-1-3 = Release system resources, such as broadcast receivers, handles to sensors (like GPS), or any resources that may affect battery life while your activity is paused and the user does not need them.
p1-4-2-1-2 = For example, if your application uses the Camera, the <code>onPause()</code> method is a good place to release it.
p1-4-2-1-3 = Generally, you should not use <code>onPause()</code> to store user changes (such as personal information entered into a form) to permanent storage. The only time you should persist user changes to permanent storage within <code>onPause()</code> is when you're certain users expect the changes to be auto-saved (such as when drafting an email). However, you should avoid performing CPU-intensive work during <code>onPause()</code>, such as writing to a database, because it can slow the visible transition to the next activity (you should instead perform heavy-load shutdown operations during <code>onStop()</code>.).
p1-4-2-1-4 = You should keep the amount of operations done in the onPause() method relatively simple in order to allow for a speedy transition to the user's next destination if your activity is actually being stopped.
nc1-4-2-1-1 = Note: When your activity is paused, the Activity instance is kept resident in memory and is recalled when the activity resumes. You don\u2019t need to re-initialize components that were created during any of the callback methods leading up to the Resumed state.
sub_title1-4-2-2 = Resume Your Activity
p1-4-2-2-1 = When the user resumes your activity from the Paused state, the system calls the onResume() method.
p1-4-2-2-2 = Be aware that the system calls this method every time your activity comes into the foreground, including when it's created for the first time. As such, you should implement <code>onResume()</code. to initialize components that you release during <code>onPause()</code> and perform any other initializations that must occur each time the activity enters the Resumed state (such as begin animations and initialize components only used while the activity has user focus).
p1-4-2-2-3 = The following example of <code>onResume()</code> is the counterpart to the <code>onPause()</code> example above, so it initializes the camera that's released when the activity pauses.

#		**********************************************************************************************************
#		Stopping and Restarting an Activity
#		**********************************************************************************************************

title1-4-3 = Stopping and Restarting an Activity
p1-4-3-1 = Properly stopping and restarting your activity is an important process in the activity lifecycle that ensures your users perceive that your app is always alive and doesn't lose their progress. There are a few of key scenarios in which your activity is stopped and restarted:
li1-4-3-1-1 = The user opens the Recent Apps window and switches from your app to another app. The activity in your app that's currently in the foreground is stopped. If the user returns to your app from the Home screen launcher icon or the Recent Apps window, the activity restarts.
li1-4-3-1-2 = The user performs an action in your app that starts a new activity. The current activity is stopped when the second activity is created. If the user then presses the Back button, the first activity is restarted.
li1-4-3-1-3 = The user receives a phone call while using your app on his or her phone.
p1-4-3-2 = The Activity class provides two lifecycle methods, <code>onStop()</code> and <code>onRestart()</code>, which allow you to specifically handle how your activity handles being stopped and restarted. Unlike the paused state, which identifies a partial UI obstruction, the stopped state guarantees that the UI is no longer visible and the user's focus is in a separate activity (or an entirely separate app).
nc1-4-3-1 = Note: Because the system retains your Activity instance in system memory when it is stopped, it's possible that you don't need to implement the <code>onStop()</code> and <code>onRestart()</code> (or even <code>onStart()</code> methods at all. For most activities that are relatively simple, the activity will stop and restart just fine and you might only need to use <code>onPause()</code> to pause ongoing actions and disconnect from system resources.
sub_title1-4-3-1 = Stop Your Activity
p1-4-3-1-1 = When your activity receives a call to the <code>onStop()</code. method, it's no longer visible and should release almost all resources that aren't needed while the user is not using it. Once your activity is stopped, the system might destroy the instance if it needs to recover system memory. In extreme cases, the system might simply kill your app process without calling the activity's final <code>onDestroy()</code> callback, so it's important you use <code>onStop()</code> to release resources that might leak memory.
p1-4-3-1-2 = Although the <code>onPause()</code> method is called before <code>onStop()</code>, you should use <code>onStop()</code> to perform larger, more CPU intensive shut-down operations, such as writing information to a database.
p1-4-3-1-3 = For example, here's an implementation of <code>onStop()</code> that saves the contents of a draft note to persistent storage:
p1-4-3-1-4 = When your activity is stopped, the Activity object is kept resident in memory and is recalled when the activity resumes. You don\u2019t need to re-initialize components that were created during any of the callback methods leading up to the Resumed state. The system also keeps track of the current state for each View in the layout, so if the user entered text into an <code>EditText</code> widget, that content is retained so you don't need to save and restore it.
nc1-4-3-1-1 = Note: Even if the system destroys your activity while it's stopped, it still retains the state of the View objects (such as text in an EditText) in a Bundle (a blob of key-value pairs) and restores them if the user navigates back to the same instance of the activity (the next lesson talks more about using a Bundle to save other state data in case your activity is destroyed and recreated).
sub_title1-4-3-2 = Start/Restart Your Activity
p1-4-3-2-1 = When your activity comes back to the foreground from the stopped state, it receives a call to <code>onRestart()</code>. The system also calls the <code>onStart()</code> method, which happens every time your activity becomes visible (whether being restarted or created for the first time). The <code>onRestart()</code> method, however, is called only when the activity resumes from the stopped state, so you can use it to perform special restoration work that might be necessary only if the activity was previously stopped, but not destroyed.
p1-4-3-2-2 = It's uncommon that an app needs to use <code>onRestart()</code> to restore the activity's state, so there aren't any guidelines for this method that apply to the general population of apps. However, because your <code>onStop()</code> method should essentially clean up all your activity's resources, you'll need to re-instantiate them when the activity restarts. Yet, you also need to instantiate them when your activity is created for the first time (when there's no existing instance of the activity). For this reason, you should usually use the <code>onStart()</code> callback method as the counterpart to the <code>onStop()</code> method, because the system calls <code>onStart()</code> both when it creates your activity and when it restarts the activity from the stopped state.
p1-4-3-2-3 = For example, because the user might have been away from your app for a long time before coming back it, the <code>onStart()</code> method is a good place to verify that required system features are enabled:
p1-4-3-2-4 = When the system destroys your activity, it calls the <code>onDestroy()</code> method for your Activity. Because you should generally have released most of your resources with <code>onStop()</code>, by the time you receive a call to <code>onDestroy()</code>, there's not much that most apps need to do. This method is your last chance to clean out resources that could lead to a memory leak, so you should be sure that additional threads are destroyed and other long-running actions like method tracing are also stopped.

#		**********************************************************************************************************
#		Recreating an Activity
#		**********************************************************************************************************

title1-4-4 = Recreating an Activity
p1-4-4-1 = There are a few scenarios in which your activity is destroyed due to normal app behavior, such as when the user presses the Back button or your activity signals its own destruction by calling <code>finish()</code>. The system may also destroy your activity if it's currently stopped and hasn't been used in a long time or the foreground activity requires more resources so the system must shut down background processes to recover memory.
p1-4-4-2 = When your activity is destroyed because the user presses Back or the activity finishes itself, the system's concept of that Activity instance is gone forever because the behavior indicates the activity is no longer needed. However, if the system destroys the activity due to system constraints (rather than normal app behavior), then although the actual Activity instance is gone, the system remembers that it existed such that if the user navigates back to it, the system creates a new instance of the activity using a set of saved data that describes the state of the activity when it was destroyed. The saved data that the system uses to restore the previous state is called the "instance state" and is a collection of key-value pairs stored in a Bundle object.
cc1-4-4-1 = Caution: Your activity will be destroyed and recreated each time the user rotates the screen. When the screen changes orientation, the system destroys and recreates the foreground activity because the screen configuration has changed and your activity might need to load alternative resources (such as the layout).
p1-4-4-3 = By default, the system uses the Bundle instance state to save information about each View object in your activity layout (such as the text value entered into an EditText object). So, if your activity instance is destroyed and recreated, the state of the layout is restored to its previous state with no code required by you. However, your activity might have more state information that you'd like to restore, such as member variables that track the user's progress in the activity.
nc1-4-4-1 = Note: In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the <code>android:id</code> attribute.
p1-4-4-4 = To save additional data about the activity state, you must override the <code>onSaveInstanceState()</code> callback method. The system calls this method when the user is leaving your activity and passes it the Bundle object that will be saved in the event that your activity is destroyed unexpectedly. If the system must recreate the activity instance later, it passes the same Bundle object to both the <code>onRestoreInstanceState()</code> and <code>onCreate()</code> methods.
sub_title1-4-4-1 = Save Your Activity State
p1-4-4-1-1 = As your activity begins to stop, the system calls <code>onSaveInstanceState()</code> so your activity can save state information with a collection of key-value pairs. The default implementation of this method saves information about the state of the activity's view hierarchy, such as the text in an EditText widget or the scroll position of a ListView.
p1-4-4-1-2 = To save additional state information for your activity, you must implement <code>onSaveInstanceState()</code> and add key-value pairs to the Bundle object. For example:
cc1-4-4-1-1 = Caution: Always call the superclass implementation of <code>onSaveInstanceState()</code> so the default implementation can save the state of the view hierarchy.
sub_title1-4-4-2 = Restore Your Activity State
p1-4-4-2-1 = When your activity is recreated after it was previously destroyed, you can recover your saved state from the Bundle that the system passes your activity. Both the <code>onCreate()</code> and <code>onRestoreInstanceState()</code> callback methods receive the same Bundle that contains the instance state information.
p1-4-4-2-2 = Because the <code>onCreate()</code> method is called whether the system is creating a new instance of your activity or recreating a previous one, you must check whether the state Bundle is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed.
p1-4-4-2-3 = For example, here's how you can restore some state data in <code>onCreate()</code>:
p1-4-4-2-4 = Instead of restoring the state during <code>onCreate()</code> you may choose to implement <code>onRestoreInstanceState()</code>, which the system calls after the <code>onStart()</code> method. The system calls <code>onRestoreInstanceState()</code> only if there is a saved state to restore, so you do not need to check whether the Bundle is null:
cc1-4-4-2-1 = Caution: Always call the superclass implementation of <code>onRestoreInstanceState()</code> so the default implementation can restore the state of the view hierarchy.
p1-4-4-2-5 = To learn more about recreating your activity due to a restart event at runtime (such as when the screen rotates), read Handling Runtime Changes.

#		**********************************************************************************************************
#		Building a Dynamic UI with Fragments
#		**********************************************************************************************************

title1-5 = Building a Dynamic UI with Fragments
p1-5-1 = To create a dynamic and multi-pane user interface on Android, you need to encapsulate UI components and activity behaviors into modules that you can swap into and out of your activities. You can create these modules with the Fragment class, which behaves somewhat like a nested activity that can define its own layout and manage its own lifecycle.
p1-5-2 = When a fragment specifies its own layout, it can be configured in different combinations with other fragments inside an activity to modify your layout configuration for different screen sizes (a small screen might show one fragment at a time, but a large screen can show two or more).
p1-5-3 = This class shows you how to create a dynamic user experience with fragments and optimize your app's user experience for devices with different screen sizes, all while continuing to support devices running versions as old as Android 1.6.

#		**********************************************************************************************************
#		Creating a Fragment
#		**********************************************************************************************************

title1-5-1 = Creating a Fragment
p1-5-1-1 = You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running (sort of like a "sub activity" that you can reuse in different activities). This lesson shows how to extend the Fragment class using the <code>Support Library</code> so your app remains compatible with devices running system versions as low as Android 1.6.
nc1-5-1-1 = Note: If you decide that the minimum API level your app requires is 11 or higher, you don't need to use the Support Library and can instead use the framework's built in Fragment class and related APIs. Just be aware that this lesson is focused on using the APIs from the Support Library, which use a specific package signature and sometimes slightly different API names than the versions included in the platform.
p1-5-1-2 = Before you begin this lesson, you must set up your Android project to use the Support Library. If you have not used the Support Library before, set up your project to use the v4 library by following the Support Library Setup document. However, you can also include the action bar in your activities by instead using the v7 appcompat library, which is compatible with Android 2.1 (API level 7) and also includes the Fragment APIs.
sub_title1-5-1-1 = Create a Fragment Class
p1-5-1-1-1 = To create a fragment, extend the Fragment class, then override key lifecycle methods to insert your app logic, similar to the way you would with an Activity class.
p1-5-1-1-2 = One difference when creating a Fragment is that you must use the <code>onCreateView()</code> callback to define the layout. In fact, this is the only callback you need in order to get a fragment running. For example, here's a simple fragment that specifies its own layout:
p1-5-1-1-3 = Just like an activity, a fragment should implement other lifecycle callbacks that allow you to manage its state as it is added or removed from the activity and as the activity transitions between its lifecycle states. For instance, when the activity's <code>onPause()</code> method is called, any fragments in the activity also receive a call to <code>onPause()</code>.
p1-5-1-1-4 = More information about the fragment lifecycle and callback methods is available in the Fragments developer guide.
sub_title1-5-1-2 = Add a Fragment to an Activity using XML
p1-5-1-2-1 = While fragments are reusable, modular UI components, each instance of a Fragment class must be associated with a parent FragmentActivity. You can achieve this association by defining each fragment within your activity layout XML file.
nc1-5-1-2-1 = Note: FragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity.
p1-5-1-2-2 = Here is an example layout file that adds two fragments to an activity when the device screen is considered "large" (specified by the <code>large</code> qualifier in the directory name).
tc1-5-1-2-1 = Tip: For more about creating layouts for different screen sizes, read Supporting Different Screen Sizes.
p1-5-1-2-3 = Then apply the layout to your activity:
p1-5-1-2-4 = If you're using the <code>v7 appcompat library</code>, your activity should instead extend ActionBarActivity, which is a subclass of FragmentActivity (for more information, read Adding the Action Bar).
nc1-5-1-2-2 = Note: When you add a fragment to an activity layout by defining the fragment in the layout XML file, you cannot remove the fragment at runtime. If you plan to swap your fragments in and out during user interaction, you must add the fragment to the activity when the activity first starts, as shown in the next lesson.

#		**********************************************************************************************************
#		Building a Flexible UI
#		**********************************************************************************************************

title1-5-2 = Building a Flexible UI
p1-5-2-1 = When designing your application to support a wide range of screen sizes, you can reuse your fragments in different layout configurations to optimize the user experience based on the available screen space.
p1-5-2-2 = For example, on a handset device it might be appropriate to display just one fragment at a time for a single-pane user interface. Conversely, you may want to set fragments side-by-side on a tablet which has a wider screen size to display more information to the user.
p1-5-2-3 = The <code>FragmentManager</code> class provides methods that allow you to add, remove, and replace fragments to an activity at runtime in order to create a dynamic experience.
sub_title1-5-2-1 = Add a Fragment to an Activity at Runtime
p1-5-2-1-1 = Rather than defining the fragments for an activity in the layout file\u2014as shown in the <a href="#c1-5-1">previous lesson</a> with the <code>&lt;fragment&gt;</code> element\u2014you can add a fragment to the activity during the activity runtime. This is necessary if you plan to change fragments during the life of the activity.
p1-5-2-1-2 = To perform a transaction such as add or remove a fragment, you must use the <code>FragmentManager</code> to create a <code>FragmentTransaction</code>, which provides APIs to add, remove, replace, and perform other fragment transactions.
p1-5-2-1-3 = If your activity allows the fragments to be removed and replaced, you should add the initial fragment(s) to the activity during the activity's <code>onCreate()</code> method.
p1-5-2-1-4 = An important rule when dealing with fragments\u2014especially when adding fragments at runtime\u2014is that your activity layout must include a container View in which you can insert the fragment.
p1-5-2-1-5 = The following layout is an alternative to the layout shown in the <a href="#c1-5-1">previous lesson</a> that shows only one fragment at a time. In order to replace one fragment with another, the activity's layout includes an empty FrameLayout that acts as the fragment container.
p1-5-2-1-6 = Notice that the filename is the same as the layout file in the previous lesson, but the layout directory does not have the large qualifier, so this layout is used when the device screen is smaller than large because the screen does not fit both fragments at the same time.
p1-5-2-1-7 = <code>res/layout/news_articles.xml:</code>
p1-5-2-1-8 = Inside your activity, call <code>getSupportFragmentManager()</code> to get a <code>FragmentManager</code> using the Support Library APIs. Then call <code>beginTransaction()</code> to create a FragmentTransaction and call <code>add()</code> to add a fragment.
p1-5-2-1-9 = You can perform multiple fragment transaction for the activity using the same FragmentTransaction. When you're ready to make the changes, you must call <code>commit()</code>.
p1-5-2-1-10 = For example, here's how to add a fragment to the previous layout:
p1-5-2-1-11 = Because the fragment has been added to the FrameLayout container at runtime\u2014instead of defining it in the activity's layout with a <code>&lt;fragment&gt;</code> element\u2014the activity can remove the fragment and replace it with a different one.
sub_title1-5-2-2 = Replace One Fragment with Another
p1-5-2-2-1 = The procedure to replace a fragment is similar to adding one, but requires the <code>replace()</code> method instead of <code>add()</code>.
p1-5-2-2-2 = Keep in mind that when you perform fragment transactions, such as replace or remove one, it's often appropriate to allow the user to navigate backward and "undo" the change. To allow the user to navigate backward through the fragment transactions, you must call <code>addToBackStack()</code> before you commit the <code>FragmentTransaction</code>.
nc1-5-2-2-1 = Note: When you remove or replace a fragment and add the transaction to the back stack, the fragment that is removed is stopped (not destroyed). If the user navigates back to restore the fragment, it restarts. If you do not add the transaction to the back stack, then the fragment is destroyed when removed or replaced.
p1-5-2-2-3 = Example of replacing one fragment with another:
p1-5-2-2-4 = The <code>addToBackStack()</code> method takes an optional string parameter that specifies a unique name for the transaction. The name isn't needed unless you plan to perform advanced fragment operations using the FragmentManager.BackStackEntry APIs.

#		**********************************************************************************************************
#		Communicating with Other Fragments
#		**********************************************************************************************************

title1-5-3 = Communicating with Other Fragments
p1-5-3-1 = In order to reuse the Fragment UI components, you should build each as a completely self-contained, modular component that defines its own layout and behavior. Once you have defined these reusable Fragments, you can associate them with an Activity and connect them with the application logic to realize the overall composite UI.
p1-5-3-2 = Often you will want one Fragment to communicate with another, for example to change the content based on a user event. All Fragment-to-Fragment communication is done through the associated Activity. Two Fragments should never communicate directly.
sub_title1-5-3-1 = Define an Interface
p1-5-3-1-1 = To allow a Fragment to communicate up to its Activity, you can define an interface in the Fragment class and implement it within the Activity. The Fragment captures the interface implementation during its onAttach() lifecycle method and can then call the Interface methods in order to communicate with the Activity.
p1-5-3-1-2 = Here is an example of Fragment to Activity communication:
p1-5-3-1-3 = Now the fragment can deliver messages to the activity by calling the <code>onArticleSelected()</code> method (or other methods in the interface) using the <code>mCallback</code> instance of the <code>OnHeadlineSelectedListener</code> interface.
p1-5-3-1-4 = For example, the following method in the fragment is called when the user clicks on a list item. The fragment uses the callback interface to deliver the event to the parent activity.
sub_title1-5-3-2 = Implement the Interface
p1-5-3-2-1 = In order to receive event callbacks from the fragment, the activity that hosts it must implement the interface defined in the fragment class.
p1-5-3-2-2 = For example, the following activity implements the interface from the above example.
sub_title1-5-3-3 = Deliver a Message to a Fragment
p1-5-3-3-1 = The host activity can deliver messages to a fragment by capturing the Fragment instance with <code>findFragmentById()</code>, then directly call the fragment's public methods.
p1-5-3-3-2 = For instance, imagine that the activity shown above may contain another fragment that's used to display the item specified by the data returned in the above callback method. In this case, the activity can pass the information received in the callback method to the other fragment that will display the item:

#		**********************************************************************************************************
#		Saving Data
#		**********************************************************************************************************

title1-6 = Saving Data
p1-6-1 = ost Android apps need to save data, even if only to save information about the app state during <code>onPause()</code> so the user's progress is not lost. Most non-trivial apps also need to save user settings, and some apps must manage large amounts of information in files and databases. This class introduces you to the principal data storage options in Android, including:
li1-6-1-1 = Saving key-value pairs of simple data types in a shared preferences file
li1-6-1-2 = Saving arbitrary files in Android's file system
li1-6-1-3 = Using databases managed by SQLite

#		**********************************************************************************************************
#		Saving Key-Value Sets
#		**********************************************************************************************************

title1-6-1 = Saving Key-Value Sets 
p1-6-1-1 = If you have a relatively small collection of key-values that you'd like to save, you should use the <code>SharedPreferences</code> APIs. A <code>SharedPreferences</code> object points to a file containing key-value pairs and provides simple methods to read and write them. Each <code>SharedPreferences</code> file is managed by the framework and can be private or shared.
p1-6-1-2 = This class shows you how to use the <code>SharedPreferences</code> APIs to store and retrieve simple values.
nc1-6-1-1 = Note: The SharedPreferences APIs are only for reading and writing key-value pairs and you should not confuse them with the Preference APIs, which help you build a user interface for your app settings (although they use SharedPreferences as their implementation to save the app settings). For information about using the Preference APIs, see the Settings guide.
sub_title1-6-1-1 = Get a Handle to a SharedPreferences 
p1-6-1-1-1 = You can create a new shared preference file or access an existing one by calling one of two methods:
li1-6-1-1-1-1 = <code>getSharedPreferences()</code> \u2014 Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any Context in your app.
li1-6-1-1-1-2 = <code>getPreferences()</code> \u2014 Use this from an Activity if you need to use only one shared preference file for the activity. Because this retrieves a default shared preference file that belongs to the activity, you don't need to supply a name.
p1-6-1-1-2 = For example, the following code is executed inside a Fragment. It accesses the shared preferences file that's identified by the resource string <code>R.string.preference_file_key</code> and opens it using the private mode so the file is accessible by only your app.
p1-6-1-1-3 = When naming your shared preference files, you should use a name that's uniquely identifiable to your app, such as <code>"com.example.myapp.PREFERENCE_FILE_KEY"</code>
p1-6-1-1-4 = Alternatively, if you need just one shared preference file for your activity, you can use the <code>getPreferences()</code> method:
cc1-6-1-1-1 = Caution: If you create a shared preferences file with <code>MODE_WORLD_READABLE</code> or <code>MODE_WORLD_WRITEABLE</code>, then any other apps that know the file identifier can access your data.
sub_title1-6-1-2 = Write to Shared Preferences
p1-6-1-2-1 = To write to a shared preferences file, create a <code>SharedPreferences.Editor</code> by calling <code>edit()</code> on your <code>SharedPreferences</code>.
p1-6-1-2-2 = Pass the keys and values you want to write with methods such as <code>putInt()</code> and <code>putString()</code>. Then call <code>commit()</code> to save the changes. For example:
sub_title1-6-1-3 = Read from Shared Preferences
p1-6-1-3-1 = To retrieve values from a shared preferences file, call methods such as <code>getInt()</code> and <code>getString()</code>, providing the key for the value you want, and optionally a default value to return if the key isn't present. For example:

#		**********************************************************************************************************
#		Saving Files
#		**********************************************************************************************************

title1-6-2 = Saving Files
p1-6-2-1 = Android uses a file system that's similar to disk-based file systems on other platforms. This lesson describes how to work with the Android file system to read and write files with the <code>File</code> APIs.
p1-6-2-2 = A <code>File</code> object is suited to reading or writing large amounts of data in start-to-finish order without skipping around. For example, it's good for image files or anything exchanged over a network.
p1-6-2-3 = This lesson shows how to perform basic file-related tasks in your app. The lesson assumes that you are familiar with the basics of the Linux file system and the standard file input/output APIs in <code>java.io</code>.
sub_title1-6-2-1 = Choose Internal or External Storage
p1-6-2-1-1 = All Android devices have two file storage areas: "internal" and "external" storage. These names come from the early days of Android, when most devices offered built-in non-volatile memory (internal storage), plus a removable storage medium such as a micro SD card (external storage). Some devices divide the permanent storage space into "internal" and "external" partitions, so even without a removable storage medium, there are always two storage spaces and the API behavior is the same whether the external storage is removable or not. The following lists summarize the facts about each storage space.
p1-6-2-1-2 = Internal storage:
li1-6-2-1-1-1 = It's always available.
li1-6-2-1-1-2 = Files saved here are accessible by only your app by default.
li1-6-2-1-1-3 = When the user uninstalls your app, the system removes all your app's files from internal storage.
p1-6-2-1-3 = Internal storage is best when you want to be sure that neither the user nor other apps can access your files.
p1-6-2-1-4 = External storage:
li1-6-2-1-2-1 = It's not always available, because the user can mount the external storage as USB storage and in some cases remove it from the device.
li1-6-2-1-2-2 = It's world-readable, so files saved here may be read outside of your control.
li1-6-2-1-2-3 = When the user uninstalls your app, the system removes your app's files from here only if you save them in the directory from <code>getExternalFilesDir()</code>.
p1-6-2-1-5 = External storage is the best place for files that don't require access restrictions and for files that you want to share with other apps or allow the user to access with a computer.
tc1-6-2-1-1 = Tip: Although apps are installed onto the internal storage by default, you can specify the <code>android:installLocation</code> attribute in your manifest so your app may be installed on external storage. Users appreciate this option when the APK size is very large and they have an external storage space that's larger than the internal storage. For more information, see App Install Location.
sub_title1-6-2-2 = Obtain Permissions for External Storage
p1-6-2-2-1 = To write to the external storage, you must request the <code>WRITE_EXTERNAL_STORAGE</code> permission in your <code>manifest file</code>:
cc1-6-2-2-1-1 = Caution: Currently, all apps have the ability to read the external storage without a special permission. However, this will change in a future release. If your app needs to read the external storage (but not write to it), then you will need to declare the READ_EXTERNAL_STORAGE permission. To ensure that your app continues to work as expected, you should declare this permission now, before the change takes effect.
cc1-6-2-2-1-2 = However, if your app uses the <code>WRITE_EXTERNAL_STORAGE</code> permission, then it implicitly has permission to read the external storage as well.
p1-6-2-2-2 = You don\u2019t need any permissions to save files on the internal storage. Your application always has permission to read and write files in its internal storage directory.
sub_title1-6-2-3 = Save a File on Internal Storage
p1-6-2-3-1 = When saving a file to internal storage, you can acquire the appropriate directory as a File by calling one of two methods:
dt1-6-2-3-1 = getFilesDir() 
dd1-6-2-3-1 = Returns a File representing an internal directory for your app.
dt1-6-2-3-2 = getCacheDir()
dd1-6-2-3-2 = Returns a File representing an internal directory for your app's temporary cache files. Be sure to delete each file once it is no longer needed and implement a reasonable size limit for the amount of memory you use at any given time, such as 1MB. If the system begins running low on storage, it may delete your cache files without warning.
p1-6-2-3-2 = To create a new file in one of these directories, you can use the <code>File()</code> constructor, passing the <code>File</code> provided by one of the above methods that specifies your internal storage directory. For example:
p1-6-2-3-3 = Alternatively, you can call <code>openFileOutput()</code> to get a <code>FileOutputStream</code> that writes to a file in your internal directory. For example, here's how to write some text to a file:
p1-6-2-3-4 = Or, if you need to cache some files, you should instead use <code>createTempFile()</code>. For example, the following method extracts the file name from a URL and creates a file with that name in your app's internal cache directory:
nc1-6-2-3-1 = Note: Your app's internal storage directory is specified by your app's package name in a special location of the Android file system. Technically, another app can read your internal files if you set the file mode to be readable. However, the other app would also need to know your app package name and file names. Other apps cannot browse your internal directories and do not have read or write access unless you explicitly set the files to be readable or writable. So as long as you use <code>MODE_PRIVATE</code> for your files on the internal storage, they are never accessible to other apps.
sub_title1-6-2-4 = Save a File on External Storage
p1-6-2-4-1 = Because the external storage may be unavailable\u2014such as when the user has mounted the storage to a PC or has removed the SD card that provides the external storage\u2014you should always verify that the volume is available before accessing it. You can query the external storage state by calling <code>getExternalStorageState()</code>. If the returned state is equal to <code>MEDIA_MOUNTED</code>, then you can read and write your files. For example, the following methods are useful to determine the storage availability:
p1-6-2-4-2 = Although the external storage is modifiable by the user and other apps, there are two categories of files you might save here:
dt1-6-2-4-1 = Public files
dd1-6-2-4-1-1 = Files that should be freely available to other apps and to the user. When the user uninstalls your app, these files should remain available to the user.
dd1-6-2-4-1-2 = For example, photos captured by your app or other downloaded files.
dt1-6-2-4-2 = Private files
dd1-6-2-4-2-1 = Files that rightfully belong to your app and should be deleted when the user uninstalls your app. Although these files are technically accessible by the user and other apps because they are on the external storage, they are files that realistically don't provide value to the user outside your app. When the user uninstalls your app, the system deletes all files in your app's external private directory.
dd1-6-2-4-2-2 = For example, additional resources downloaded by your app or temporary media files.
p1-6-2-4-3 = If you want to save public files on the external storage, use the <code>getExternalStoragePublicDirectory()</code> method to get a File representing the appropriate directory on the external storage. The method takes an argument specifying the type of file you want to save so that they can be logically organized with other public files, such as <code>DIRECTORY_MUSIC</code> or <code>DIRECTORY_PICTURES</code>. For example:
p1-6-2-4-4 = If you want to save files that are private to your app, you can acquire the appropriate directory by calling <code>getExternalFilesDir()</code> and passing it a name indicating the type of directory you'd like. Each directory created this way is added to a parent directory that encapsulates all your app's external storage files, which the system deletes when the user uninstalls your app.
p1-6-2-4-5 = For example, here's a method you can use to create a directory for an individual photo album:
p1-6-2-4-6 = If none of the pre-defined sub-directory names suit your files, you can instead call <code>getExternalFilesDir()</code> and pass null. This returns the root directory for your app's private directory on the external storage.
p1-6-2-4-7 = Remember that <code>getExternalFilesDir()</code> creates a directory inside a directory that is deleted when the user uninstalls your app. If the files you're saving should remain available after the user uninstalls your app\u2014such as when your app is a camera and the user will want to keep the photos\u2014you should instead use <code>getExternalStoragePublicDirectory()</code>.
p1-6-2-4-8 = Regardless of whether you use <code>getExternalStoragePublicDirectory()</code> for files that are shared or <code>getExternalFilesDir()</code> for files that are private to your app, it's important that you use directory names provided by API constants like <code>DIRECTORY_PICTURES</code>. These directory names ensure that the files are treated properly by the system. For instance, files saved in <code>DIRECTORY_RINGTONES</code> are categorized by the system media scanner as ringtones instead of music.
sub_title1-6-2-5 = Query Free Space
p1-6-2-5-1 = If you know ahead of time how much data you're saving, you can find out whether sufficient space is available without causing an <code>IOException</code> by calling <code>getFreeSpace()</code> or <code>getTotalSpace()</code>. These methods provide the current available space and the total space in the storage volume, respectively. This information is also useful to avoid filling the storage volume above a certain threshold.
p1-6-2-5-2 = However, the system does not guarantee that you can write as many bytes as are indicated by <code>getFreeSpace()</code>. If the number returned is a few MB more than the size of the data you want to save, or if the file system is less than 90% full, then it's probably safe to proceed. Otherwise, you probably shouldn't write to storage.
nc1-6-2-5-1 = Note: You aren't required to check the amount of available space before you save your file. You can instead try writing the file right away, then catch an <code>IOException</code> if one occurs. You may need to do this if you don't know exactly how much space you need. For example, if you change the file's encoding before you save it by converting a PNG image to JPEG, you won't know the file's size beforehand.
sub_title1-6-2-6 = Delete a File
p1-6-2-6-1 = You should always delete files that you no longer need. The most straightforward way to delete a file is to have the opened file reference call <code>delete()</code> on itself.
p1-6-2-6-2 = If the file is saved on internal storage, you can also ask the <code>Context</code> to locate and delete a file by calling <code>deleteFile()</code>:
nc1-6-2-6-1-1 = Note: When the user uninstalls your app, the Android system deletes the following:
li1-6-2-6-1-1 = All files you saved on internal storage
li1-6-2-6-1-2 = All files you saved on external storage using <code>getExternalFilesDir()</code>.
nc1-6-2-6-1-2 = However, you should manually delete all cached files created with <code>getCacheDir()</code> on a regular basis and also regularly delete other files you no longer need.

#		**********************************************************************************************************
#		Saving Data in SQL Databases
#		**********************************************************************************************************

title1-6-3 = Saving Data in SQL Databases
p1-6-3-1 = Saving data to a database is ideal for repeating or structured data, such as contact information. This class assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the <code>android.database.sqlite</code> package.
sub_title1-6-3-1 = Define a Schema and Contract
p1-6-3-1-1 = One of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.
p1-6-3-1-2 = A contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.
p1-6-3-1-3 = A good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table that enumerates its columns.
nc1-6-3-1-1 = Note: By implementing the <code>BaseColumns</code> interface, your inner class can inherit a primary key field called _ID that some Android classes such as cursor adaptors will expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.
p1-6-3-1-4 = For example, this snippet defines the table name and column names for a single table:
sub_title1-6-3-2 = Create a Database Using a SQL Helper
p1-6-3-2-1 = Once you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:
p1-6-3-2-2 = Just like files that you save on the device's <code>internal storage</code>, Android stores your database in private disk space that's associated application. Your data is secure, because by default this area is not accessible to other applications.
p1-6-3-2-3 = A useful set of APIs is available in the <code>SQLiteOpenHelper</code> class. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call <code>getWritableDatabase()</code> or <code>getReadableDatabase()</code>.
nc1-6-3-2-1 = Note: Because they can be long-running, be sure that you call <code>getWritableDatabase()</code> or <code>getReadableDatabase()</code> in a background thread, such as with <code>AsyncTask</code> or <code>IntentService</code>.
p1-6-3-2-4 = To use SQLiteOpenHelper, create a subclass that overrides the <code>onCreate()</code>, <code>onUpgrade()</code> and <code>onOpen()</code> callback methods. You may also want to implement <code>onDowngrade()</code>, but it's not required.
p1-6-3-2-5 = For example, here's an implementation of SQLiteOpenHelper that uses some of the commands shown above:
p1-6-3-2-6 = To access your database, instantiate your subclass of <code>SQLiteOpenHelper</code>:
sub_title1-6-3-3 = Put Information into a Database
p1-6-3-3-1 = Insert data into the database by passing a <code>ContentValues</code> object to the <code>insert()</code> method:
p1-6-3-3-2 = The first argument for <code>insert()</code> is simply the table name. The second argument provides the name of a column in which the framework can insert NULL in the event that the <code>ContentValues</code> is empty (if you instead set this to <code>"null"</code>, then the framework will not insert a row when there are no values).
sub_title1-6-3-4 = Read Information from a Database
p1-6-3-4-1 = To read from a database, use the <code>query()</code> method, passing it your selection criteria and desired columns. The method combines elements of <code>insert()</code> and <code>update()</code>, except the column list defines the data you want to fetch, rather than the data to insert. The results of the query are returned to you in a <code>Cursor</code> object.
p1-6-3-4-2 = To look at a row in the cursor, use one of the Cursor move methods, which you must always call before you begin reading values. Generally, you should start by calling <code>moveToFirst()</code>, which places the "read position" on the first entry in the results. For each row, you can read a column's value by calling one of the Cursor get methods, such as <code>getString()</code> or <code>getLong()</code>. For each of the get methods, you must pass the index position of the column you desire, which you can get by calling <code>getColumnIndex()</code> or <code>getColumnIndexOrThrow()</code>. For example:
sub_title1-6-3-5 = Delete Information from a Database
p1-6-3-5-1 = To delete rows from a table, you need to provide selection criteria that identify the rows. The database API provides a mechanism for creating selection criteria that protects against SQL injection. The mechanism divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.
sub_title1-6-3-6 = Update a Database
p1-6-3-6-1 = When you need to modify a subset of your database values, use the <code>update()</code> method.
p1-6-3-6-2 = Updating the table combines the content values syntax of <code>insert()</code> with the where syntax of <code>delete()</code>.

#		**********************************************************************************************************
#		Interacting with Other Apps
#		**********************************************************************************************************

title1-7 = Interacting with Other Apps
p1-7-1 = An Android app typically has several activities. Each activity displays a user interface that allows the user to perform a specific task (such as view a map or take a photo). To take the user from one activity to another, your app must use an Intent to define your app's "intent" to do something. When you pass an Intent to the system with a method such as <code>startActivity()</code>, the system uses the Intent to identify and start the appropriate app component. Using intents even allows your app to start an activity that is contained in a separate app.
p1-7-2 = An Intent can be explicit in order to start a specific component (a specific Activity instance) or implicit in order to start any component that can handle the intended action (such as "capture a photo").
p1-7-3 = This class shows you how to use an Intent to perform some basic interactions with other apps, such as start another app, receive a result from that app, and make your app able to respond to intents from other apps.

#		**********************************************************************************************************
#		Sending the User to Another App
#		**********************************************************************************************************

title1-7-1 = Sending the User to Another App
p1-7-1-1 = One of Android's most important features is an app's ability to send the user to another app based on an "action" it would like to perform. For example, if your app has the address of a business that you'd like to show on a map, you don't have to build an activity in your app that shows a map. Instead, you can create a request to view the address using an Intent. The Android system then starts an app that's able to show the address on a map.
p1-7-1-2 = As explained in the first class, Building Your First App, you must use intents to navigate between activities in your own app. You generally do so with an explicit intent, which defines the exact class name of the component you want to start. However, when you want to have a separate app perform an action, such as "view a map," you must use an implicit intent.
p1-7-1-3 = This lesson shows you how to create an implicit intent for a particular action, and how to use it to start an activity that performs the action in another app.
sub_title1-7-1-1 = Build an Implicit Intent
p1-7-1-1-1 = Implicit intents do not declare the class name of the component to start, but instead declare an action to perform. The action specifies the thing you want to do, such as view, edit, send, or get something. Intents often also include data associated with the action, such as the address you want to view, or the email message you want to send. Depending on the intent you want to create, the data might be a Uri, one of several other data types, or the intent might not need data at all.
p1-7-1-1-2 = If your data is a Uri, there's a simple <code>Intent()</code> constructor you can use define the action and data.
p1-7-1-1-3 = For example, here's how to create an intent to initiate a phone call using the Uri data to specify the telephone number:
p1-7-1-1-4 = When your app invokes this intent by calling <code>startActivity()</code>, the Phone app initiates a call to the given phone number.
p1-7-1-1-5 = Here are a couple other intents and their action and Uri data pairs:
li1-7-1-1-1-1 = View a map:
li1-7-1-1-1-2 = View a web page:
p1-7-1-1-6 = Other kinds of implicit intents require "extra" data that provide different data types, such as a string. You can add one or more pieces of extra data using the various <code>putExtra()</code> methods.
p1-7-1-1-7 = By default, the system determines the appropriate MIME type required by an intent based on the Uri data that's included. If you don't include a Uri in the intent, you should usually use <code>setType()</code> to specify the type of data associated with the intent. Setting the MIME type further specifies which kinds of activities should receive the intent.
p1-7-1-1-8 = Here are some more intents that add extra data to specify the desired action:
li1-7-1-1-2-1 = Send an email with an attachment:
li1-7-1-1-2-2 = Create a calendar event:
nc1-7-1-1-1 = Note: This intent for a calendar event is supported only with API level 14 and higher.
nc1-7-1-1-2 = Note: It's important that you define your Intent to be as specific as possible. For example, if you want to display an image using the ACTION_VIEW intent, you should specify a MIME type of <code>image/*</code>. This prevents apps that can "view" other types of data (like a map app) from being triggered by the intent.
sub_title1-7-1-2 = Verify There is an App to Receive the Intent
p1-7-1-2-1 = Although the Android platform guarantees that certain intents will resolve to one of the built-in apps (such as the Phone, Email, or Calendar app), you should always include a verification step before invoking an intent.
cc1-7-1-2-1 = Caution: If you invoke an intent and there is no app available on the device that can handle the intent, your app will crash.
p1-7-1-2-2 = To verify there is an activity available that can respond to the intent, call <code>queryIntentActivities()</code> to get a list of activities capable of handling your Intent. If the returned List is not empty, you can safely use the intent. For example:
p1-7-1-2-3 = If <code>isIntentSafe</code> is <code>true</code>, then at least one app will respond to the intent. If it is <code>false</code>, then there aren't any apps to handle the intent.
nc1-7-1-2-1 = Note: You should perform this check when your activity first starts in case you need to disable the feature that uses the intent before the user attempts to use it. If you know of a specific app that can handle the intent, you can also provide a link for the user to download the app (see how to link to your product on Google Play).
sub_title1-7-1-3 = Start an Activity with the Intent
p1-7-1-3-1 = Once you have created your Intent and set the extra info, call <code>startActivity()</code> to send it to the system. If the system identifies more than one activity that can handle the intent, it displays a dialog for the user to select which app to use, as shown in figure 1. If there is only one activity that handles the intent, the system immediately starts it.
p1-7-1-3-2 = Here's a complete example that shows how to create an intent to view a map, verify that an app exists to handle the intent, then start it:
sub_title1-7-1-4 = Show an App Chooser
p1-7-1-4-1 = Notice that when you start an activity by passing your Intent to <code>startActivity()</code> and there is more than one app that responds to the intent, the user can select which app to use by default (by selecting a checkbox at the bottom of the dialog; see figure 1). This is nice when performing an action for which the user generally wants to use the same app every time, such as when opening a web page (users likely use just one web browser) or taking a photo (users likely prefer one camera).
p1-7-1-4-2 = However, if the action to be performed could be handled by multiple apps and the user might prefer a different app each time\u2014such as a "share" action, for which users might have several apps through which they might share an item\u2014you should explicitly show a chooser dialog as shown in figure 2. The chooser dialog forces the user to select which app to use for the action every time (the user cannot select a default app for the action).
p1-7-1-4-3 = To show the chooser, create an Intent using <code>createChooser()</code> and pass it to <code>startActivity()</code>. For example:
p1-7-1-4-4 = This displays a dialog with a list of apps that respond to the intent passed to the <code>createChooser()</code> method and uses the supplied text as the dialog title.

#		**********************************************************************************************************
#		Getting a Result from an Activity
#		**********************************************************************************************************

title1-7-2 = Getting a Result from an Activity
p1-7-2-1 = Starting another activity doesn't have to be one-way. You can also start another activity and receive a result back. To receive a result, call <code>startActivityForResult()</code> (instead of <code>startActivity()</code>).
p1-7-2-2 = For example, your app can start a camera app and receive the captured photo as a result. Or, you might start the People app in order for the user to select a contact and you'll receive the contact details as a result.
p1-7-2-3 = Of course, the activity that responds must be designed to return a result. When it does, it sends the result as another Intent object. Your activity receives it in the <code>onActivityResult()</code> callback.
nc1-7-2-1 = Note: You can use explicit or implicit intents when you call <code>startActivityForResult()</code>. When starting one of your own activities to receive a result, you should use an explicit intent to ensure that you receive the expected result.
sub_title1-7-2-1 = Start the Activity
p1-7-2-1-1 = There's nothing special about the Intent object you use when starting an activity for a result, but you do need to pass an additional integer argument to the <code>startActivityForResult()</code> method.
p1-7-2-1-2 = The integer argument is a "request code" that identifies your request. When you receive the result Intent, the callback provides the same request code so that your app can properly identify the result and determine how to handle it.
p1-7-2-1-3 = For example, here's how to start an activity that allows the user to pick a contact:
sub_title1-7-2-2 = Receive the Result
p1-7-2-2-1 = When the user is done with the subsequent activity and returns, the system calls your activity's <code>onActivityResult()</code> method. This method includes three arguments:
li1-7-2-2-1-1 = The request code you passed to startActivityForResult().
li1-7-2-2-1-2 = A result code specified by the second activity. This is either <code>RESULT_OK</code> if the operation was successful or <code>RESULT_CANCELED</code> if the user backed out or the operation failed for some reason.
li1-7-2-2-1-3 = An Intent that carries the result data.
p1-7-2-2-2 = For example, here's how you can handle the result for the "pick a contact" intent:
p1-7-2-2-3 = In this example, the result Intent returned by Android's Contacts or People app provides a content Uri that identifies the contact the user selected.
p1-7-2-2-4 = In order to successfully handle the result, you must understand what the format of the result Intent will be. Doing so is easy when the activity returning a result is one of your own activities. Apps included with the Android platform offer their own APIs that you can count on for specific result data. For instance, the People app (Contacts app on some older versions) always returns a result with the content URI that identifies the selected contact, and the Camera app returns a Bitmap in the "data" extra (see the class about Capturing Photos).
p1-7-2-2-5 = Bonus: Read the contact data
p1-7-2-2-6 = The code above showing how to get a result from the People app doesn't go into details about how to actually read the data from the result, because it requires more advanced discussion about content providers. However, if you're curious, here's some more code that shows how to query the result data to get the phone number from the selected contact:
nc1-7-2-2-1 = Note: Before Android 2.3 (API level 9), performing a query on the Contacts Provider (like the one shown above) requires that your app declare the <code>READ_CONTACTS</code> permission (see Security and Permissions). However, beginning with Android 2.3, the Contacts/People app grants your app a temporary permission to read from the Contacts Provider when it returns you a result. The temporary permission applies only to the specific contact requested, so you cannot query a contact other than the one specified by the intent's Uri, unless you do declare the <code>READ_CONTACTS</code> permission.

#		**********************************************************************************************************
#		Allowing Other Apps to Start Your Activity
#		**********************************************************************************************************

title1-7-3 = Allowing Other Apps to Start Your Activity
p1-7-3-1 = The previous two lessons focused on one side of the story: starting another app's activity from your app. But if your app can perform an action that might be useful to another app, your app should be prepared to respond to action requests from other apps. For instance, if you build a social app that can share messages or photos with the user's friends, it's in your best interest to support the <code>ACTION_SEND</code> intent so users can initiate a "share" action from another app and launch your app to perform the action.
p1-7-3-2 = To allow other apps to start your activity, you need to add an <code>&lt;intent-filter&gt;</code> element in your manifest file for the corresponding <code>&lt;activity&gt;</code> element.
p1-7-3-3 = When your app is installed on a device, the system identifies your intent filters and adds the information to an internal catalog of intents supported by all installed apps. When an app calls startActivity() or startActivityForResult(), with an implicit intent, the system finds which activity (or activities) can respond to the intent.
sub_title1-7-3-1 = Add an Intent Filter
p1-7-3-1-1 = In order to properly define which intents your activity can handle, each intent filter you add should be as specific as possible in terms of the type of action and data the activity accepts.
p1-7-3-1-2 = The system may send a given Intent to an activity if that activity has an intent filter fulfills the following criteria of the Intent object:
dt1-7-3-1-1 = Action
dd1-7-3-1-1-1 = A string naming the action to perform. Usually one of the platform-defined values such as ACTION_SEND or <code>ACTION_VIEW</code>.
dd1-7-3-1-1-2 = Specify this in your intent filter with the <code>&lt;action&gt;</code> element. The value you specify in this element must be the full string name for the action, instead of the API constant (see the examples below).
dt1-7-3-1-2 = Data
dd1-7-3-1-2-1 = A description of the data associated with the intent.
dd1-7-3-1-2-2 = Specify this in your intent filter with the <code>&gt;data&lt;</code> element. Using one or more attributes in this element, you can specify just the MIME type, just a URI prefix, just a URI scheme, or a combination of these and others that indicate the data type accepted.
nc1-