title3 = Building Apps with Multimedia
p3-1 = These classes teach you how to create rich multimedia apps that behave the way users expect.
title3-1 = Managing Audio Playback
p3-1-1 = If your app plays audio, it’s important that your users can control the audio in a predictable manner. To ensure a great user experience, it’s also important that your app manages the audio focus to ensure multiple apps aren’t playing audio at the same time.
p3-1-2 = After this class, you will be able to build apps that respond to hardware audio key presses, which request audio focus when playing audio, and which respond appropriately to changes in audio focus caused by the system or other applications.
sub_title3-1-1 = Lessons
dt3-1-1-1 = <b><a href="http://developer.android.com/volume-playback.html">Controlling Your App’s Volume and Playback</a></b>
dd3-1-1-1 = Learn how to ensure your users can control the volume of your app using the hardware or software volume controls and where available the play, stop, pause, skip, and previous media playback keys.
dt3-1-1-2 = <b><a href="http://developer.android.com/audio-focus.html">Managing Audio Focus</a></b>
dd3-1-1-2 = With multiple apps potentially playing audio it's important to think about how they should interact. To avoid every music app playing at the same time, Android uses audio focus to moderate audio playback. Learn how to request the audio focus, listen for a loss of audio focus, and how to respond when that happens.
dt3-1-1-3 = <b><a href="http://developer.android.com/audio-output.html">Dealing with Audio Output Hardware</a></b>
dd3-1-1-3 = Audio can be played from a number of sources. Learn how to find out where the audio is being played and how to handle a headset being disconnected during playback.
title3-1-1 = Controlling Your App’s Volume and Playback
p3-1-1-1 = A good user experience is a predictable one. If your app plays media it’s important that your users can control the volume of your app using the hardware or software volume controls of their device, bluetooth headset, or headphones.
p3-1-1-2 = Similarly, where appropriate and available, the play, stop, pause, skip, and previous media playback keys should perform their respective actions on the audio stream used by your app.
sub_title3-1-1-1 = Identify Which Audio Stream to Use
p3-1-1-1-1 = The first step to creating a predictable audio experience is understanding which audio stream your app will use.
p3-1-1-1-2 = Android maintains a separate audio stream for playing music, alarms, notifications, the incoming call ringer, system sounds, in-call volume, and DTMF tones. This is done primarily to allow users to control the volume of each stream independently.
p3-1-1-1-3 = Most of these streams are restricted to system events, so unless your app is a replacement alarm clock, you’ll almost certainly be playing your audio using the <code><a href="http://developer.android.com//reference/android/media/AudioManager.html#STREAM_MUSIC">STREAM_MUSIC</a></code> stream.
sub_title3-1-1-2 = Use Hardware Volume Keys to Control Your App’s Audio Volume
p3-1-1-2-1 = By default, pressing the volume controls modify the volume of the active audio stream. If your app isn't currently playing anything, hitting the volume keys adjusts the ringer volume.
p3-1-1-2-2 = If you've got a game or music app, then chances are good that when the user hits the volume keys they want to control the volume of the game or music, even if they’re currently between songs or there’s no music in the current game location.
p3-1-1-2-3 = You may be tempted to try and listen for volume key presses and modify the volume of your audio stream that way. Resist the urge. Android provides the handy <code><a href="http://developer.android.com//reference/android/app/Activity.html#setVolumeControlStream(int)">setVolumeControlStream()</a></code> method to direct volume key presses to the audio stream you specify.
p3-1-1-2-4 = Having identified the audio stream your application will be using, you should set it as the volume stream target. You should make this call early in your app’s lifecycle—because you only need to call it once during the activity lifecycle, you should typically call it within the <code>onCreate()</code> method (of the <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code> or <code><a href="http://developer.android.com//reference/android/app/Fragment.html">Fragment</a></code> that controls your media). This ensures that whenever your app is visible, the volume controls function as the user expects.
#pre3-1-1-2-1
p3-1-1-2-5 = From this point onwards, pressing the volume keys on the device affect the audio stream you specify (in this case “music”) whenever the target activity or fragment is visible.
sub_title3-1-1-3 = Use Hardware Playback Control Keys to Control Your App’s Audio Playback
p3-1-1-3-1 = Media playback buttons such as play, pause, stop, skip, and previous are available on some handsets and many connected or wireless headsets. Whenever a user presses one of these hardware keys, the system broadcasts an intent with the <code><a href="http://developer.android.com//reference/android/content/Intent.html#ACTION_MEDIA_BUTTON">ACTION_MEDIA_BUTTON</a></code> action.
p3-1-1-3-2 = To respond to media button clicks, you need to register a <code><a href="http://developer.android.com//reference/android/content/BroadcastReceiver.html">BroadcastReceiver</a></code> in your manifest that listens for this action broadcast as shown below.
#pre3-1-1-3-1
p3-1-1-3-3 = The receiver implementation itself needs to extract which key was pressed to cause the broadcast. The <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> includes this under the <code><a href="http://developer.android.com//reference/android/content/Intent.html#EXTRA_KEY_EVENT">EXTRA_KEY_EVENT</a></code> key, while the <code><a href="http://developer.android.com//reference/android/view/KeyEvent.html">KeyEvent</a></code> class includes a list <code>KEYCODE_MEDIA_*</code> static constants that represents each of the possible media buttons, such as <code><a href="http://developer.android.com//reference/android/view/KeyEvent.html#KEYCODE_MEDIA_PLAY_PAUSE">KEYCODE_MEDIA_PLAY_PAUSE</a></code> and <code><a href="http://developer.android.com//reference/android/view/KeyEvent.html#KEYCODE_MEDIA_NEXT">KEYCODE_MEDIA_NEXT</a></code>.
p3-1-1-3-4 = The following snippet shows how to extract the media button pressed and affects the media playback accordingly.
#pre3-1-1-3-2
p3-1-1-3-5 = Because multiple applications might want to listen for media button presses, you must also programmatically control when your app should receive media button press events.
p3-1-1-3-6 = The following code can be used within your app to register and de-register your media button event receiver using the <code><a href="http://developer.android.com//reference/android/media/AudioManager.html">AudioManager</a></code>. When registered, your broadcast receiver is the exclusive receiver of all media button broadcasts.
#pre3-1-1-3-3
p3-1-1-3-7 = Typically, apps should unregister most of their receivers whenever they become inactive or invisible (such as during the <code><a href="http://developer.android.com//reference/android/app/Activity.html#onStop()">onStop()</a></code> callback). However, it’s not that simple for media playback apps—in fact, responding to media playback buttons is most important when your application isn’t visible and therefore can’t be controlled by the on-screen UI.
p3-1-1-3-8 = A better approach is to register and unregister the media button event receiver when your application gains and loses the audio focus. This is covered in detail in the next lesson.
title3-1-2 = Managing Audio Focus
p3-1-2-1 = With multiple apps potentially playing audio it's important to think about how they should interact. To avoid every music app playing at the same time, Android uses audio focus to moderate audio playback—only apps that hold the audio focus should play audio.
p3-1-2-2 = Before your app starts playing audio it should request—and receive—the audio focus. Likewise, it should know how to listen for a loss of audio focus and respond appropriately when that happens.
sub_title3-1-2-1 = Request the Audio Focus
p3-1-2-1-1 = Before your app starts playing any audio, it should hold the audio focus for the stream it will be using. This is done with a call to <code><a href="http://developer.android.com//reference/android/media/AudioManager.html#requestAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener, int, int)">requestAudioFocus()</a></code> which returns <code><a href="http://developer.android.com//reference/android/media/AudioManager.html#AUDIOFOCUS_REQUEST_GRANTED">AUDIOFOCUS_REQUEST_GRANTED</a></code> if your request is successful.
p3-1-2-1-2 = You must specify which stream you're using and whether you expect to require transient or permanent audio focus. Request transient focus when you expect to play audio for only a short time (for example when playing navigation instructions). Request permanent audio focus when you plan to play audio for the foreseeable future (for example, when playing music).
p3-1-2-1-3 = The following snippet requests permanent audio focus on the music audio stream. You should request the audio focus immediately before you begin playback, such as when the user presses play or the background music for the next game level begins.
#pre3-1-2-1-1
p3-1-2-1-4 = Once you've finished playback be sure to call <code><a href="http://developer.android.com//reference/android/media/AudioManager.html#abandonAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener)">abandonAudioFocus()</a></code>. This notifies the system that you no longer require focus and unregisters the associated <code><a href="http://developer.android.com//reference/android/media/AudioManager.OnAudioFocusChangeListener.html">AudioManager.OnAudioFocusChangeListener</a></code>. In the case of abandoning transient focus, this allows any interupted app to continue playback.
#pre3-1-2-1-2
p3-1-2-1-5 = When requesting transient audio focus you have an additional option: whether or not you want to enable "ducking." Normally, when a well-behaved audio app loses audio focus it immediately silences its playback. By requesting a transient audio focus that allows ducking you tell other audio apps that it’s acceptable for them to keep playing, provided they lower their volume until the focus returns to them.
#pre3-1-2-1-3
p3-1-2-1-6 = Ducking is particularly suitable for apps that use the audio stream intermittently, such as for audible driving directions.
p3-1-2-1-7 = Whenever another app requests audio focus as described above, its choice between permanent and transient (with or without support for ducking) audio focus is received by the listener you registered when requesting focus.
sub_title3-1-2-2 = Handle the Loss of Audio Focus
p3-1-2-2-1 = If your app can request audio focus, it follows that it will in turn lose that focus when another app requests it. How your app responds to a loss of audio focus depends on the manner of that loss.
p3-1-2-2-2 = The <code><a href="http://developer.android.com//reference/android/media/AudioManager.OnAudioFocusChangeListener.html#onAudioFocusChange(int)">onAudioFocusChange()</a></code> callback method of the audio focus change listener you registered when requesting audio focus receives a parameter that describes the focus change event. Specifically, the possible focus loss events mirror the focus request types from the previous section—permanent loss, transient loss, and transient with ducking permitted.
p3-1-2-2-3 = Generally speaking, a transient (temporary) loss of audio focus should result in your app silencing it’s audio stream, but otherwise maintaining the same state. You should continue to monitor changes in audio focus and be prepared to resume playback where it was paused once you’ve regained the focus.
p3-1-2-2-4 = If the audio focus loss is permanent, it’s assumed that another application is now being used to listen to audio and your app should effectively end itself. In practical terms, that means stopping playback, removing media button listeners—allowing the new audio player to exclusively handle those events—and abandoning your audio focus. At that point, you would expect a user action (pressing play in your app) to be required before you resume playing audio.
p3-1-2-2-5 = In the following code snippet, we pause the playback or our media player object if the audio loss is transient and resume it when we have regained the focus. If the loss is permanent, it unregisters our media button event receiver and stops monitoring audio focus changes.
#pre3-1-2-2-1
p3-1-2-2-6 = In the case of a transient loss of audio focus where ducking is permitted, rather than pausing playback, you can "duck" instead.
sub_title3-1-2-3 = Duck!
p3-1-2-3-1 = Ducking is the process of lowering your audio stream output volume to make transient audio from another app easier to hear without totally disrupting the audio from your own application.
p3-1-2-3-2 = In the following code snippet lowers the volume on our media player object when we temporarily lose focus, then returns it to its previous level when we regain focus.
#pre3-1-2-3-1
p3-1-2-3-3 = A loss of audio focus is the most important broadcast to react to, but not the only one. The system broadcasts a number of intents to alert you to changes in user’s audio experience. The next lesson demonstrates how to monitor them to improve the user’s overall experience.
title3-1-3 = Dealing with Audio Output Hardware
p3-1-3-1 = Users have a number of alternatives when it comes to enjoying the audio from their Android devices. Most devices have a built-in speaker, headphone jacks for wired headsets, and many also feature Bluetooth connectivity and support for A2DP audio.
sub_title3-1-3-1 = Check What Hardware is Being Used
p3-1-3-1-1 = How your app behaves might be affected by which hardware its output is being routed to.
p3-1-3-1-2 = You can query the <code><a href="http://developer.android.com//reference/android/media/AudioManager.html">AudioManager</a></code> to determine if the audio is currently being routed to the device speaker, wired headset, or attached Bluetooth device as shown in the following snippet:
#pre3-1-3-1-1
sub_title3-1-3-2 = Handle Changes in the Audio Output Hardware
p3-1-3-2-1 = When a headset is unplugged, or a Bluetooth device disconnected, the audio stream automatically reroutes to the built in speaker. If you listen to your music at as high a volume as I do, that can be a noisy surprise.
p3-1-3-2-2 = Luckily the system broadcasts an <code><a href="http://developer.android.com//reference/android/media/AudioManager.html#ACTION_AUDIO_BECOMING_NOISY">ACTION_AUDIO_BECOMING_NOISY</a></code> intent when this happens. It’s good practice to register a <code><a href="http://developer.android.com//reference/android/content/BroadcastReceiver.html">BroadcastReceiver</a></code> that listens for this intent whenever you’re playing audio. In the case of music players, users typically expect the playback to be paused—while for games you may choose to significantly lower the volume.
#pre3-1-3-2-1
title3-2 = Capturing Photos
p3-2-1 = The world was a dismal and featureless place before rich media became prevalent. Remember Gopher? We don't, either. For your app to become part of your users' lives, give them a way to put their lives into it. Using the on-board cameras, your application can enable users to augment what they see around them, make unique avatars, look for zombies around the corner, or simply share their experiences.
p3-2-2 = This class gets you clicking fast with some super-easy ways of leveraging existing camera applications. In later lessons, you dive deeper and learn how to control the camera hardware directly.
sub_title3-2-1 = Lessons
dt3-2-1-1 = <b><a href="http://developer.android.com/photobasics.html">Taking Photos Simply</a></b>
dd3-2-1-1 = Leverage other applications and capture photos with just a few lines of code.
dt3-2-1-2 = <b><a href="http://developer.android.com/videobasics.html">Recording Videos Simply</a></b>
dd3-2-1-2 = Leverage other applications and record videos with just a few lines of code.
dt3-2-1-3 = <b><a href="http://developer.android.com/cameradirect.html">Controlling the Camera</a></b>
dd3-2-1-3 = Control the camera hardware directly and implement your own camera application.
title3-2-1 = Taking Photos Simply
p3-2-1-1 = This lesson explains how to capture photos using an existing camera application.
p3-2-1-2 = Suppose you are implementing a crowd-sourced weather service that makes a global weather map by blending together pictures of the sky taken by devices running your client app. Integrating photos is only a small part of your application. You want to take photos with minimal fuss, not reinvent the camera. Happily, most Android-powered devices already have at least one camera application installed. In this lesson, you learn how to make it take a picture for you.
sub_title3-2-1-1 = Request Camera Permission
p3-2-1-1-1 = If an essential function of your application is taking pictures, then restrict its visibility on Google Play to devices that have a camera. To advertise that your application depends on having a camera, put a <a href="http://developer.android.com//guide/topics/manifest/uses-feature-element.html"> <code>&lt;uses-feature&gt;</code></a> tag in your manifest file:
#pre3-2-1-1-1
p3-2-1-1-2 = If your application uses, but does not require a camera in order to function, instead set <code>android:required</code> to <code>false</code>. In doing so, Google Play will allow devices without a camera to download your application. It's then your responsibility to check for the availability of the camera at runtime by calling <code><a href="http://developer.android.com//reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String)">hasSystemFeature(PackageManager.FEATURE_CAMERA)</a></code>. If a camera is not available, you should then disable your camera features.
sub_title3-2-1-2 = Take a Photo with the Camera App
p3-2-1-2-1 = The Android way of delegating actions to other applications is to invoke an <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> that describes what you want done. This process involves three pieces: The <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> itself, a call to start the external <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>, and some code to handle the image data when focus returns to your activity.
p3-2-1-2-2 = Here's a function that invokes an intent to capture a photo.
#pre3-2-1-2-1
p3-2-1-2-3 = Notice that the <code><a href="http://developer.android.com//reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int)">startActivityForResult()</a></code> method is protected by a condition that calls <code><a href="http://developer.android.com//reference/android/content/Intent.html#resolveActivity(android.content.pm.PackageManager)">resolveActivity()</a></code>, which returns the first activity component that can handle the intent. Performing this check is important because if you call <code><a href="http://developer.android.com//reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int)">startActivityForResult()</a></code> using an intent that no app can handle, your app will crash. So as long as the result is not null, it's safe to use the intent.
sub_title3-2-1-3 = Get the Thumbnail
p3-2-1-3-1 = If the simple feat of taking a photo is not the culmination of your app's ambition, then you probably want to get the image back from the camera application and do something with it.
p3-2-1-3-2 = The Android Camera application encodes the photo in the return <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> delivered to <code><a href="http://developer.android.com//reference/android/app/Activity.html#onActivityResult(int, int, android.content.Intent)">onActivityResult()</a></code> as a small <code><a href="http://developer.android.com//reference/android/graphics/Bitmap.html">Bitmap</a></code> in the extras, under the key <code>"data"</code>. The following code retrieves this image and displays it in an <code><a href="http://developer.android.com//reference/android/widget/ImageView.html">ImageView</a></code>.
#pre3-2-1-3-1
nc3-2-1-3-1 = <strong>Note:</strong> This thumbnail image from <code>"data"</code> might be good for an icon, but not a lot more. Dealing with a full-sized image takes a bit more work.
sub_title3-2-1-4 = Save the Full-size Photo
p3-2-1-4-1 = The Android Camera application saves a full-size photo if you give it a file to save into. You must provide a fully qualified file name where the camera app should save the photo.
p3-2-1-4-2 = Generally, any photos that the user captures with the device camera should be saved on the device in the public external storage so they are accessible by all apps. The proper directory for shared photos is provided by <code><a href="http://developer.android.com//reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String)">getExternalStoragePublicDirectory()</a></code>, with the <code><a href="http://developer.android.com//reference/android/os/Environment.html#DIRECTORY_PICTURES">DIRECTORY_PICTURES</a></code> argument. Because the directory provided by this method is shared among all apps, reading and writing to it requires the <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE">READ_EXTERNAL_STORAGE</a></code> and <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#WRITE_EXTERNAL_STORAGE">WRITE_EXTERNAL_STORAGE</a></code> permissions, respectively. The write permission implicitly allows reading, so if you need to write to the external storage then you need to request only one permission:
#pre3-2-1-4-1
p3-2-1-4-3 = However, if you'd like the photos to remain private to your app only, you can instead use the directory provided by <code><a href="http://developer.android.com//reference/android/content/Context.html#getExternalFilesDir(java.lang.String)">getExternalFilesDir()</a></code>. On Android 4.3 and lower, writing to this directory also requires the <code><a href="http://developer.android.com//reference/android/Manifest.permission.html#WRITE_EXTERNAL_STORAGE">WRITE_EXTERNAL_STORAGE</a></code> permission. Beginning with Android 4.4, the permission is no longer required because the directory is not accessible by other apps, so you can declare the permission should be requested only on the lower versions of Android by adding the <a href="http://developer.android.com//guide/topics/manifest/uses-permission-element.html#maxSdk"><code>maxSdkVersion</code></a> attribute:
#pre3-2-1-4-2
nc3-2-1-4-1 = <strong>Note:</strong> Files you save in the directories provided by <code><a href="http://developer.android.com//reference/android/content/Context.html#getExternalFilesDir(java.lang.String)">getExternalFilesDir()</a></code> are deleted when the user uninstalls your app.
p3-2-1-4-4 = Once you decide the directory for the file, you need to create a collision-resistant file name. You may wish also to save the path in a member variable for later use. Here's an example solution in a method that returns a unique file name for a new photo using a date-time stamp:
#pre3-2-1-4-3
p3-2-1-4-5 = With this method available to create a file for the photo, you can now create and invoke the <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> like this:
#pre3-2-1-4-4
sub_title3-2-1-5 = Add the Photo to a Gallery
p3-2-1-5-1 = When you create a photo through an intent, you should know where your image is located, because you said where to save it in the first place. For everyone else, perhaps the easiest way to make your photo accessible is to make it accessible from the system's Media Provider.
nc3-2-1-5-1 = <strong>Note:</strong> If you saved your photo to the directory provided by <code><a href="http://developer.android.com//reference/android/content/Context.html#getExternalFilesDir(java.lang.String)">getExternalFilesDir()</a></code>, the media scanner cannot access the files because they are private to your app.
p3-2-1-5-2 = The following example method demonstrates how to invoke the system's media scanner to add your photo to the Media Provider's database, making it available in the Android Gallery application and to other apps.
#pre3-2-1-5-1
sub_title3-2-1-6 = Decode a Scaled Image
p3-2-1-6-1 = Managing multiple full-sized images can be tricky with limited memory. If you find your application running out of memory after displaying just a few images, you can dramatically reduce the amount of dynamic heap used by expanding the JPEG into a memory array that's already scaled to match the size of the destination view. The following example method demonstrates this technique.
#pre3-2-1-6-1
title3-2-2 = Recording Videos Simply
p3-2-2-1 = This lesson explains how to capture video using existing camera applications.
p3-2-2-2 = Your application has a job to do, and integrating videos is only a small part of it. You want to take videos with minimal fuss, and not reinvent the camcorder. Happily, most Android-powered devices already have a camera application that records video. In this lesson, you make it do this for you.
sub_title3-2-2-1 = Request Camera Permission
p3-2-2-1-1 = To advertise that your application depends on having a camera, put a <code>&lt;uses-feature&gt;</code> tag in the manifest file:
#pre3-2-2-1-1
p3-2-2-1-2 = If your application uses, but does not require a camera in order to function, set <code>android:required</code> to <code>false</code>. In doing so, Google Play will allow devices without a camera to download your application. It's then your responsibility to check for the availability of the camera at runtime by calling <code><a href="http://developer.android.com//reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String)">hasSystemFeature(PackageManager.FEATURE_CAMERA)</a></code>. If a camera is not available, you should then disable your camera features.
sub_title3-2-2-2 = Record a Video with a Camera App
p3-2-2-2-1 = The Android way of delegating actions to other applications is to invoke an <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> that describes what you want done. This process involves three pieces: The <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> itself, a call to start the external <code><a href="http://developer.android.com//reference/android/app/Activity.html">Activity</a></code>, and some code to handle the video when focus returns to your activity.
p3-2-2-2-2 = Here's a function that invokes an intent to capture video.
#pre3-2-2-2-1
p3-2-2-2-3 = Notice that the <code><a href="http://developer.android.com//reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int)">startActivityForResult()</a></code> method is protected by a condition that calls <code><a href="http://developer.android.com//reference/android/content/Intent.html#resolveActivity(android.content.pm.PackageManager)">resolveActivity()</a></code>, which returns the first activity component that can handle the intent. Performing this check is important because if you call <code><a href="http://developer.android.com//reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int)">startActivityForResult()</a></code> using an intent that no app can handle, your app will crash. So as long as the result is not null, it's safe to use the intent.
sub_title3-2-2-3 = View the Video
p3-2-2-3-1 = The Android Camera application returns the video in the <code><a href="http://developer.android.com//reference/android/content/Intent.html">Intent</a></code> delivered to <code><a href="http://developer.android.com//reference/android/app/Activity.html#onActivityResult(int, int, android.content.Intent)">onActivityResult()</a></code> as a <code><a href="http://developer.android.com//reference/android/net/Uri.html">Uri</a></code> pointing to the video location in storage. The following code retrieves this video and displays it in a <code><a href="http://developer.android.com//reference/android/widget/VideoView.html">VideoView</a></code>.
#pre3-2-2-3-1
title3-2-3 = Controlling the Camera
p3-2-3-1 = In this lesson, we discuss how to control the camera hardware directly using the framework APIs.
p3-2-3-2 = Directly controlling a device camera requires a lot more code than requesting pictures or videos from existing camera applications. However, if you want to build a specialized camera application or something fully integrated in your app UI, this lesson shows you how.
sub_title3-2-3-1 = Open the Camera Object
p3-2-3-1-1 = Getting an instance of the <code><a href="http://developer.android.com//reference/android/hardware/Camera.html">Camera</a></code> object is the first step in the process of directly controlling the camera. As Android's own Camera application does, the recommended way to access the camera is to open <code><a href="http://developer.android.com//reference/android/hardware/Camera.html">Camera</a></code> on a separate thread that's launched from <code><a href="http://developer.android.com//reference/android/app/Activity.html#onCreate(android.os.Bundle)">onCreate()</a></code>. This approach is a good idea since it can take a while and might bog down the UI thread. In a more basic implementation, opening the camera can be deferred to the <code><a href="http://developer.android.com//reference/android/app/Activity.html#onResume()">onResume()</a></code> method to facilitate code reuse and keep the flow of control simple.
p3-2-3-1-2 = Calling <code><a href="http://developer.android.com//reference/android/hardware/Camera.html#open()">Camera.open()</a></code> throws an exception if the camera is already in use by another application, so we wrap it in a <code>try</code> block.
#pre3-2-3-1-1
p3-2-3-1-3 = Since API level 9, the camera framework supports multiple cameras. If you use the legacy API and call <code><a href="http://developer.android.com//reference/android/hardware/Camera.html#open()">open()</a></code> without an argument, you get the first rear-facing camera.
sub_title3-2-3-2 = Create the Camera Preview
p3-2-3-2-1 = Taking a picture usually requires that your users see a preview of their subject before clicking the shutter. To do so, you can use a <code><a href="http://developer.android.com//reference/android/view/SurfaceView.html">SurfaceView</a></code> to draw previews of what the camera sensor is picking up.
lead3-2-3-2-1 = Preview Class
p3-2-3-2-2 = To get started with displaying a preview, you need preview class. The preview requires an implementation of the <code>android.view.SurfaceHolder.Callback</code> interface, which is used to pass image data from the camera hardware to the application.
#pre3-2-3-2-1
p3-2-3-2-3 = The preview class must be passed to the <code><a href="http://developer.android.com//reference/android/hardware/Camera.html">Camera</a></code> object before the live image preview can be started, as shown in the next section.
lead3-2-3-2-2 = Set and Start the Preview
p3-2-3-2-4 = A camera instance and its related preview must be created in a specific order, with the camera object being first. In the snippet below, the process of initializing the camera is encapsulated so that <code><a href="http://developer.android.com//reference/android/hardware/Camera.html#startPreview()">Camera.startPreview()</a></code> is called by the <code>setCamera()</code> method, whenever the user does something to change the camera. The preview must also be restarted in the preview class <code>surfaceChanged()</code> callback method.
#pre3-2-3-2-2
sub_title3-2-3-3 = Modify Camera Settings
p3-2-3-3-1 = Camera settings change the way that the camera takes pictures, from the zoom level to exposure compensation. This example changes only the preview size; see the source code of the Camera application for many more.
#pre3-2-3-3-1
sub_title3-2-3-4 = Set the Preview Orientation
p3-2-3-4-1 = Most camera applications lock the display into landscape mode because that is the natural orientation of the camera sensor. This setting does not prevent you from taking portrait-mode photos, because the orientation of the device is recorded in the EXIF header. The <code><a href="http://developer.android.com//reference/android/hardware/Camera.html#setDisplayOrientation(int)">setCameraDisplayOrientation()</a></code> method lets you change how the preview is displayed without affecting how the image is recorded. However, in Android prior to API level 14, you must stop your preview before changing the orientation and then restart it.
sub_title3-2-3-5 = Take a Picture
p3-2-3-5-1 = Use the <code><a href="http://developer.android.com//reference/android/hardware/Camera.html#takePicture(android.hardware.Camera.ShutterCallback, android.hardware.Camera.PictureCallback, android.hardware.Camera.PictureCallback)">Camera.takePicture()</a></code> method to take a picture once the preview is started. You can create <code><a href="http://developer.android.com//reference/android/hardware/Camera.PictureCallback.html">Camera.PictureCallback</a></code> and <code><a href="http://developer.android.com//reference/android/hardware/Camera.ShutterCallback.html">Camera.ShutterCallback</a></code> objects and pass them into <code><a href="http://developer.android.com//reference/android/hardware/Camera.html#takePicture(android.hardware.Camera.ShutterCallback, android.hardware.Camera.PictureCallback, android.hardware.Camera.PictureCallback)">Camera.takePicture()</a></code>.
p3-2-3-5-2 = If you want to grab images continously, you can create a <code><a href="http://developer.android.com//reference/android/hardware/Camera.PreviewCallback.html">Camera.PreviewCallback</a></code> that implements <code><a href="http://developer.android.com//reference/android/hardware/Camera.PreviewCallback.html#onPreviewFrame(byte[], android.hardware.Camera)">onPreviewFrame()</a></code>. For something in between, you can capture only selected preview frames, or set up a delayed action to call <code><a href="http://developer.android.com//reference/android/hardware/Camera.html#takePicture(android.hardware.Camera.ShutterCallback, android.hardware.Camera.PictureCallback, android.hardware.Camera.PictureCallback)">takePicture()</a></code>.
sub_title3-2-3-6 = Restart the Preview
p3-2-3-6-1 = After a picture is taken, you must restart the preview before the user can take another picture. In this example, the restart is done by overloading the shutter button.
#pre3-2-3-6-1
sub_title3-2-3-7 = Stop the Preview and Release the Camera
p3-2-3-7-1 = Once your application is done using the camera, it's time to clean up. In particular, you must release the <code><a href="http://developer.android.com//reference/android/hardware/Camera.html">Camera</a></code> object, or you risk crashing other applications, including new instances of your own application.
p3-2-3-7-2 = When should you stop the preview and release the camera? Well, having your preview surface destroyed is a pretty good hint that it’s time to stop the preview and release the camera, as shown in these methods from the <code>Preview</code> class.
#pre3-2-3-7-1
p3-2-3-7-3 = Earlier in the lesson, this procedure was also part of the <code>setCamera()</code> method, so initializing a camera always begins with stopping the preview.
title3-3 = Printing Content
p3-3-1 = Android users frequently view content solely on their devices, but there are times when showing someone a screen is not an adequate way to share information. Being able to print information from your Android application gives users a way to see a larger version of the content from your app or share it with another person who is not using your application. Printing also allows them to create a snapshot of information that does not depend on having a device, sufficient battery power, or a wireless network connection.
p3-3-2 = In Android 4.4 (API level 19) and higher, the framework provides services for printing images and documents directly from Android applications. This training describes how to enable printing in your application, including printing images, HTML pages and creating custom documents for printing.
sub_title3-3-1 = Lessons
dt3-3-1-1 = <strong><a href="http://developer.android.com/photos.html">Printing a Photo</a></strong>
dd3-3-1-1 = This lesson shows you how to print an image.
dt3-3-1-2 = <strong><a href="http://developer.android.com/html-docs.html">Printing an HTML Document</a></strong>
dd3-3-1-2 = This lesson shows you how to print an HTML document.
dt3-3-1-3 = <strong><a href="http://developer.android.com/custom-docs.html">Printing a Custom Document</a></strong>
dd3-3-1-3 = This lesson shows you how you connect to the Android print manager, create a print adapter and build content for printing.
title3-3-1 = Printing Photos
p3-3-1-1 = Taking and sharing photos is one of the most popular uses for mobile devices. If your application takes photos, displays them, or allows users to share images, you should consider enabling printing of those images in your application. The <a href="http://developer.android.com//tools/support-library/index.html">Android Support Library</a> provides a convenient function for enabling image printing using a minimal amount of code and simple set of print layout options.
p3-3-1-2 = This lesson shows you how to print an image using the v4 support library <code><a href="http://developer.android.com//reference/android/support/v4/print/PrintHelper.html">PrintHelper</a></code> class.
sub_title3-3-1-1 = Print an Image
p3-3-1-1-1 = The Android Support Library <code><a href="http://developer.android.com//reference/android/support/v4/print/PrintHelper.html">PrintHelper</a></code> class provides a simple way to print of images. The class has a single layout option, <code><a href="http://developer.android.com//reference/android/support/v4/print/PrintHelper.html#setScaleMode(int)">setScaleMode()</a></code>, which allows you to print with one of two options:
#ul
li3-3-1-1-1 = <code><a href="http://developer.android.com//reference/android/support/v4/print/PrintHelper.html#SCALE_MODE_FIT">SCALE_MODE_FIT</a></code> - This option sizes the image so that the whole image is shown within the printable area of the page.
li3-3-1-1-2 = <code><a href="http://developer.android.com//reference/android/support/v4/print/PrintHelper.html#SCALE_MODE_FILL">SCALE_MODE_FILL</a></code> - This option scales the image so that it fills the entire printable area of the page. Choosing this setting means that some portion of the top and bottom, or left and right edges of the image is not printed. This option is the default value if you do not set a scale mode.
p3-3-1-1-2 = Both scaling options for <code><a href="http://developer.android.com//reference/android/support/v4/print/PrintHelper.html#setScaleMode(int)">setScaleMode()</a></code> keep the existing aspect ratio of the image intact. The following code example shows how to create an instance of the <code><a href="http://developer.android.com//reference/android/support/v4/print/PrintHelper.html">PrintHelper</a></code> class, set the scaling option, and start the printing process:
#pre3-3-1-1-1
p3-3-1-1-3 = This method can be called as the action for a menu item. Note that menu items for actions that are not always supported (such as printing) should be placed in the overflow menu. For more information, see the <a href="http://developer.android.com//design/patterns/actionbar.html">Action Bar</a> design guide.
p3-3-1-1-4 = After the <code><a href="http://developer.android.com//reference/android/support/v4/print/PrintHelper.html#printBitmap(java.lang.String, android.graphics.Bitmap)">printBitmap()</a></code> method is called, no further action from your application is required. The Android print user interface appears, allowing the user to select a printer and printing options. The user can then print the image or cancel the action. If the user chooses to print the image, a print job is created and a printing notification appears in the system bar.
p3-3-1-1-5 = If you want to include additional content in your printouts beyond just an image, you must construct a print document. For information on creating documents for printing, see the <a href="http://developer.android.com/html-docs.html">Printing an HTML Document</a> or <a href="http://developer.android.com/custom-docs.html">Printing a Custom Document</a> lessons.
title3-3-2 = Printing HTML Documents
p3-3-2-1 = Printing out content beyond a simple photo on Android requires composing text and graphics in a print document. The Android framework provides a way to use HTML to compose a document and print it with a minimum of code.
p3-3-2-2 = In Android 4.4 (API level 19), the <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> class has been updated to enable printing HTML content. The class allows you to load a local HTML resource or download a page from the web, create a print job and hand it off to Android's print services.
p3-3-2-3 = This lesson shows you how to quickly build an HTML document containing text and graphics and use <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> to print it.
sub_title3-3-2-1 = Load an HTML Document
p3-3-2-1-1 = Printing an HTML document with <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> involves loading an HTML resource or building an HTML document as a string. This section describes how to build an HTML string and load it into a <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> for printing.
p3-3-2-1-2 = This view object is typically used as part of an activity layout. However, if your application is not using a <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code>, you can create an instance of the class specifically for printing purposes. The main steps for creating this custom print view are:
#ol
li3-3-2-1-1 = Create a <code><a href="http://developer.android.com//reference/android/webkit/WebViewClient.html">WebViewClient</a></code> that starts a print job after the HTML resource is loaded.
li3-3-2-1-2 = Load the HTML resource into the <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> object.
p3-3-2-1-3 = The following code sample demonstrates how to create a simple <code><a href="http://developer.android.com//reference/android/webkit/WebViewClient.html">WebViewClient</a></code> and load an HTML document created on the fly:
#pre3-3-2-1-1
nc3-3-2-1-1 = <strong>Note:</strong> Make sure your call for generating a print job happens in the <code><a href="http://developer.android.com//reference/android/webkit/WebViewClient.html#onPageFinished(android.webkit.WebView, java.lang.String)">onPageFinished()</a></code> method of the <code><a href="http://developer.android.com//reference/android/webkit/WebViewClient.html">WebViewClient</a></code> you created in the previous section. If you don't wait until page loading is finished, the print output may be incomplete or blank, or may fail completely.
nc3-3-2-1-2 = <strong>Note:</strong> The example code above holds an instance of the <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> object so that is it not garbage collected before the print job is created. Make sure you do the same in your own implementation, otherwise the print process may fail.
p3-3-2-1-4 = If you want to include graphics in the page, place the graphic files in the <code>assets/</code> directory of your project and specify a base URL in the first parameter of the <code><a href="http://developer.android.com//reference/android/webkit/WebView.html#loadDataWithBaseURL(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)">loadDataWithBaseURL()</a></code> method, as shown in the following code example:
#pre3-3-2-1-2
p3-3-2-1-5 = You can also load a web page for printing by replacing the <code><a href="http://developer.android.com//reference/android/webkit/WebView.html#loadDataWithBaseURL(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)">loadDataWithBaseURL()</a></code> method with <code><a href="http://developer.android.com//reference/android/webkit/WebView.html#loadUrl(java.lang.String)">loadUrl()</a></code> as shown below.
#pre3-3-2-1-3
p3-3-2-1-6 = When using <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> for creating print documents, you should be aware of the following limitations:
#ul
li3-3-2-1-3 = You cannot add headers or footers, including page numbers, to the document.
li3-3-2-1-4 = The printing options for the HTML document do not include the ability to print page ranges, for example: Printing page 2 to 4 of a 10 page HTML document is not supported.
li3-3-2-1-5 = An instance of <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> can only process one print job at a time.
li3-3-2-1-6 = An HTML document containing CSS print attributes, such as landscape properties, is not supported.
li3-3-2-1-7 = You cannot use JavaScript in a HTML document to trigger printing.
nc3-3-2-1-3 = <strong>Note:</strong> The content of a <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> object that is included in a layout can also be printed once it has loaded a document.
p3-3-2-1-7 = If you want to create a more customized print output and have complete control of the content draw on the printed page, jump to the next lesson: <a href="http://developer.android.com/custom-docs.html">Printing a Custom Document</a> lesson.
sub_title3-3-2-2 = Create a Print Job
p3-3-2-2-1 = After creating a <code><a href="http://developer.android.com//reference/android/webkit/WebView.html">WebView</a></code> and loading your HTML content, your application is almost done with its part of the printing process. The next steps are accessing the <code><a href="http://developer.android.com//reference/android/print/PrintManager.html">PrintManager</a></code>, creating a print adapter, and finally, creating a print job. The following example illustrates how to perform these steps:
#pre3-3-2-2-1
p3-3-2-2-2 = This example saves an instance of the <code><a href="http://developer.android.com//reference/android/print/PrintJob.html">PrintJob</a></code> object for use by the application, which is not required. Your application may use this object to track the progress of the print job as it's being processed. This approach is useful when you want to monitor the status of the print job in you application for completion, failure, or user cancellation. Creating an in-app notification is not required, because the print framework automatically creates a system notification for the print job.
title3-3-3 = Printing Custom Documents
p3-3-3-1 = For some applications, such as drawing apps, page layout apps and other apps that focus on graphic output, creating beautiful printed pages is a key feature. In this case, it is not enough to print an image or an HTML document. The print output for these types of applications requires precise control of everything that goes into a page, including fonts, text flow, page breaks, headers, footers, and graphic elements.
p3-3-3-2 = Creating print output that is completely customized for your application requires more programming investment than the previously discussed approaches. You must build components that communicate with the print framework, adjust to printer settings, draw page elements and manage printing on multiple pages.
p3-3-3-3 = This lesson shows you how you connect with the print manager, create a print adapter and build content for printing.
sub_title3-3-3-1 = Connect to the Print Manager
p3-3-3-1-1 = When your application manages the printing process directly, the first step after receiving a print request from your user is to connect to the Android print framework and obtain an instance of the <code><a href="http://developer.android.com//reference/android/print/PrintManager.html">PrintManager</a></code> class. This class allows you to initialize a print job and begin the printing lifecycle. The following code example shows how to get the print manager and start the printing process.
#pre3-3-3-1-1
p3-3-3-1-2 = The example code above demonstrates how to name a print job and set an instance of the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html">PrintDocumentAdapter</a></code> class which handles the steps of the printing lifecycle. The implementation of the print adapter class is discussed in the next section.
nc3-3-3-1-1 = <strong>Note:</strong> The last parameter in the <code><a href="http://developer.android.com//reference/android/print/PrintManager.html#print(java.lang.String, android.print.PrintDocumentAdapter, android.print.PrintAttributes)">print()</a></code> method takes a <code><a href="http://developer.android.com//reference/android/print/PrintAttributes.html">PrintAttributes</a></code> object. You can use this parameter to provide hints to the printing framework and pre-set options based on the previous printing cycle, thereby improving the user experience. You may also use this parameter to set options that are more appropriate to the content being printed, such as setting the orientation to landscape when printing a photo that is in that orientation.
sub_title3-3-3-2 = Create a Print Adapter
p3-3-3-2-1 = A print adapter interacts with the Android print framework and handles the steps of the printing process. This process requires users to select printers and print options before creating a document for printing. These selections can influence the final output as the user chooses printers with different output capabilities, different page sizes, or different page orientations. As these selections are made, the print framework asks your adapter to lay out and generate a print document, in preparation for final output. Once a user taps the print button, the framework takes the final print document and passes it to a print provider for output. During the printing process, users can choose to cancel the print action, so your print adapter must also listen for and react to a cancellation requests.
p3-3-3-2-2 = The <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html">PrintDocumentAdapter</a></code> abstract class is designed to handle the printing lifecycle, which has four main callback methods. You must implement these methods in your print adapter in order to interact properly with the print framework:
#ul
li3-3-3-2-1 = <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onStart()">onStart()</a></code> - Called once at the beginning of the print process. If your application has any one-time preparation tasks to perform, such as getting a snapshot of the data to be printed, execute them here. Implementing this method in your adapter is not required.
li3-3-3-2-2 = <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onLayout(android.print.PrintAttributes, android.print.PrintAttributes, android.os.CancellationSignal, android.print.PrintDocumentAdapter.LayoutResultCallback, android.os.Bundle)">onLayout()</a></code> - Called each time a user changes a print setting which impacts the output, such as a different page size, or page orientation, giving your application an opportunity to compute the layout of the pages to be printed. At the minimum, this method must return how many pages are expected in the printed document.
li3-3-3-2-3 = <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onWrite(android.print.PageRange[], android.os.ParcelFileDescriptor, android.os.CancellationSignal, android.print.PrintDocumentAdapter.WriteResultCallback)">onWrite()</a></code> - Called to render printed pages into a file to be printed. This method may be called one or more times after each <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onLayout(android.print.PrintAttributes, android.print.PrintAttributes, android.os.CancellationSignal, android.print.PrintDocumentAdapter.LayoutResultCallback, android.os.Bundle)">onLayout()</a></code> call.
li3-3-3-2-4 = <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onFinish()">onFinish()</a></code> - Called once at the end of the print process. If your application has any one-time tear-down tasks to perform, execute them here. Implementing this method in your adapter is not required.
p3-3-3-2-3 = The following sections describe how to implement the layout and write methods, which are critical to the functioning of a print adapter.
nc3-3-3-2-1 = <strong>Note:</strong> These adapter methods are called on the main thread of your application. If you expect the execution of these methods in your implementation to take a significant amount of time, implement them to execute within a separate thread. For example, you can encapsulate the layout or print document writing work in separate <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code> objects.
lead3-3-3-2-1 = Compute print document info
p3-3-3-2-4 = Within an implementation of the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html">PrintDocumentAdapter</a></code> class, your application must be able to specify the type of document it is creating and calculate the total number of pages for print job, given information about the printed page size. The implementation of the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onLayout(android.print.PrintAttributes, android.print.PrintAttributes, android.os.CancellationSignal, android.print.PrintDocumentAdapter.LayoutResultCallback, android.os.Bundle)">onLayout()</a></code> method in the adapter makes these calculations and provides information about the expected output of the print job in a <code><a href="http://developer.android.com//reference/android/print/PrintDocumentInfo.html">PrintDocumentInfo</a></code> class, including the number of pages and content type. The following code example shows a basic implementation of the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onLayout(android.print.PrintAttributes, android.print.PrintAttributes, android.os.CancellationSignal, android.print.PrintDocumentAdapter.LayoutResultCallback, android.os.Bundle)">onLayout()</a></code> method for a <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html">PrintDocumentAdapter</a></code>:
#pre3-3-3-2-1
p3-3-3-2-5 = The execution of <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onLayout(android.print.PrintAttributes, android.print.PrintAttributes, android.os.CancellationSignal, android.print.PrintDocumentAdapter.LayoutResultCallback, android.os.Bundle)">onLayout()</a></code> method can have three outcomes: completion, cancellation, or failure in the case where calculation of the layout cannot be completed. You must indicate one of these results by calling the appropriate method of the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.LayoutResultCallback.html">PrintDocumentAdapter.LayoutResultCallback</a></code> object.
nc3-3-3-2-2 = <strong>Note:</strong> The boolean parameter of the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.LayoutResultCallback.html#onLayoutFinished(android.print.PrintDocumentInfo, boolean)">onLayoutFinished()</a></code> method indicates whether or not the layout content has actually changed since the last request. Setting this parameter properly allows the print framework to avoid unnecessarily calling the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onWrite(android.print.PageRange[], android.os.ParcelFileDescriptor, android.os.CancellationSignal, android.print.PrintDocumentAdapter.WriteResultCallback)">onWrite()</a></code> method, essentially caching the previously written print document and improving performance.
p3-3-3-2-6 = The main work of <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onLayout(android.print.PrintAttributes, android.print.PrintAttributes, android.os.CancellationSignal, android.print.PrintDocumentAdapter.LayoutResultCallback, android.os.Bundle)">onLayout()</a></code> is calculating the number of pages that are expected as output given the attributes of the printer. How you calculate this number is highly dependent on how your application lays out pages for printing. The following code example shows an implementation where the number of pages is determined by the print orientation:
#pre3-3-3-2-2
lead3-3-3-2-2 = Write a print document file
p3-3-3-2-7 = When it is time to write print output to a file, the Android print framework calls the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onWrite(android.print.PageRange[], android.os.ParcelFileDescriptor, android.os.CancellationSignal, android.print.PrintDocumentAdapter.WriteResultCallback)">onWrite()</a></code> method of your application's <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html">PrintDocumentAdapter</a></code> class. The method's parameters specify which pages should be written and the output file to be used. Your implementation of this method must then render each requested page of content to a multi-page PDF document file. When this process is complete, you call the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.WriteResultCallback.html#onWriteFinished(android.print.PageRange[])">onWriteFinished()</a></code> method of the callback object.
nc3-3-3-2-3 = <strong>Note:</strong> The Android print framework may call the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onWrite(android.print.PageRange[], android.os.ParcelFileDescriptor, android.os.CancellationSignal, android.print.PrintDocumentAdapter.WriteResultCallback)">onWrite()</a></code> method one or more times for every call to <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onLayout(android.print.PrintAttributes, android.print.PrintAttributes, android.os.CancellationSignal, android.print.PrintDocumentAdapter.LayoutResultCallback, android.os.Bundle)">onLayout()</a></code>. For this reason, it is important to set the boolean parameter of <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.LayoutResultCallback.html#onLayoutFinished(android.print.PrintDocumentInfo, boolean)">onLayoutFinished()</a></code> method to <code>false</code> when the print content layout has not changed, to avoid unnecessary re-writes of the print document.
nc3-3-3-2-4 = <strong>Note:</strong> The boolean parameter of the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.LayoutResultCallback.html#onLayoutFinished(android.print.PrintDocumentInfo, boolean)">onLayoutFinished()</a></code> method indicates whether or not the layout content has actually changed since the last request. Setting this parameter properly allows the print framework to avoid unnecessarily calling the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onLayout(android.print.PrintAttributes, android.print.PrintAttributes, android.os.CancellationSignal, android.print.PrintDocumentAdapter.LayoutResultCallback, android.os.Bundle)">onLayout()</a></code> method, essentially caching the previously written print document and improving performance.
p3-3-3-2-8 = The following sample demonstrates the basic mechanics of this process using the <code><a href="http://developer.android.com//reference/android/print/pdf/PrintedPdfDocument.html">PrintedPdfDocument</a></code> class to create a PDF file:
#pre3-3-3-2-3
p3-3-3-2-9 = This sample delegates rendering of PDF page content to <code>drawPage()</code> method, which is discussed in the next section.
p3-3-3-2-10 = As with layout, execution of <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.html#onWrite(android.print.PageRange[], android.os.ParcelFileDescriptor, android.os.CancellationSignal, android.print.PrintDocumentAdapter.WriteResultCallback)">onWrite()</a></code> method can have three outcomes: completion, cancellation, or failure in the case where the the content cannot be written. You must indicate one of these results by calling the appropriate method of the <code><a href="http://developer.android.com//reference/android/print/PrintDocumentAdapter.WriteResultCallback.html">PrintDocumentAdapter.WriteResultCallback</a></code> object.
nc3-3-3-2-5 = <strong>Note:</strong> Rendering a document for printing can be a resource-intensive operation. In order to avoid blocking the main user interface thread of your application, you should consider performing the page rendering and writing operations on a separate thread, for example in an <code><a href="http://developer.android.com//reference/android/os/AsyncTask.html">AsyncTask</a></code>. For more information about working with execution threads like asynchronous tasks, see <a href="http://developer.android.com//guide/components/processes-and-threads.html">Processes and Threads</a>.
sub_title3-3-3-3 = Drawing PDF Page Content
p3-3-3-3-1 = When your application prints, your application must generate a PDF document and pass it to the Android print framework for printing. You can use any PDF generation library for this purpose. This lesson shows how to use the <code><a href="http://developer.android.com//reference/android/print/pdf/PrintedPdfDocument.html">PrintedPdfDocument</a></code> class to generate PDF pages from your content.
p3-3-3-3-2 = The <code><a href="http://developer.android.com//reference/android/print/pdf/PrintedPdfDocument.html">PrintedPdfDocument</a></code> class uses a <code><a href="http://developer.android.com//reference/android/graphics/Canvas.html">Canvas</a></code> object to draw elements on an PDF page, similar to drawing on an activity layout. You can draw elements on the printed page using the <code><a href="http://developer.android.com//reference/android/graphics/Canvas.html">Canvas</a></code> draw methods. The following example code demonstrates how to draw some simple elements on a PDF document page using these methods:
#pre3-3-3-3-1
p3-3-3-3-3 = When using <code><a href="http://developer.android.com//reference/android/graphics/Canvas.html">Canvas</a></code> to draw on a PDF page, elements are specified in points, which is 1/72 of an inch. Make sure you use this unit of measure for specifying the size of elements on the page. For positioning of drawn elements, the coordinate system starts at 0,0 for the top left corner of the page.
tc3-3-3-3-1 = <strong>Tip:</strong> While the <code><a href="http://developer.android.com//reference/android/graphics/Canvas.html">Canvas</a></code> object allows you to place print elements on the edge of a PDF document, many printers are not able to print to the edge of a physical piece of paper. Make sure that you account for the unprintable edges of the page when you build a print document with this class.
