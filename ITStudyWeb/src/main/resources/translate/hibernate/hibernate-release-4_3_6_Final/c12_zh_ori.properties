
#		**********************************************************************************************************
#		Chapter 12. Read-only entities
#		**********************************************************************************************************

title12 = 第十二章. 只读实体
ic12-1 = Hibernate对于只读实体的处理方式可能与你在其他地方见过的处理方式有所不同。对其错误的使用可能导致意料之外的结果。
p12-1 = 当一个实体是只读的时候：
li12-1-1 = Hibernate不会脏检查实体的简单属性或者单向的关联关系；
li12-1-2 = Hibernate不会更新简单属性或者可更新的单端关联关系。
li12-1-3 = 当只读实体的简单属性或者单端关联关系发生改变，Hibernate不会更新它的版本；
p12-2 = 在一些情况下，Hibernate对待只读实体和非只读实体是一样的：
li12-2-1 = Hibernate会按照实体映射文件来对关联进行级联操作。
li12-2-2 = 当实体中集合的改变影响了实体时，Hibernate会更新版本；
li12-2-3 = 一个只读实体是可以被删除的。
p12-3 = 即使一个实体不是只读的，它的集合关联还是会被只读实体所影响。
p12-4 = 可以通过查看<a href="#c12-2">Section 12.2, \u201CRead-only affect on property type\u201D</a>来学习更多只读实体不同的属性和关联类型的影响。
p12-5 = 可以通过查看<a href="#c12-1">Section 12.1, \u201CMaking persistent entities read-only\u201D</a>来学习如何是实体只读。
p12-6 = Hibernate会对只读实体进行一些优化：
li12-3-1 = 通过不检查简单属性和单向关联来缩短执行时间。
li12-3-2 = 通过删除数据库快照来节省内存。

#		**********************************************************************************************************
#		12.1. Making persistent entities read-only
#		**********************************************************************************************************

title12-1 = 12.1. 使实体只读
p12-1-1 = 只有持久化实体才能设为只读。如果想将瞬态实体或者脱离实体设为动态，一定要先将实体变为持久化状态。
p12-1-2 = Hibernate提供了以下集中方法是的持久化实体只读：
li12-1-1-1 = 你可以使用<code>immutable</code>来映射一个实体；当一个不可变的实体持久化时，Hibernate会自动将其设为只读。查看<a href="#c12-1-1">Section 12.1.1, \u201CEntities of immutable classes\u201D</a>获取更多信息。
li12-1-1-2 = 你可以将其设为默认，那么在实体加载进session是Hibernate已经自动将其设为只读。查看<a href="#c12-1-2">Section 12.1.2, \u201CLoading persistent entities as read-only\u201D</a>获得更多信息。
li12-1-1-3 = 你可以将HQL查询或条件查询设为只读，那么当执行查询时对应实体会自动变为只读；查看<a href="#c12-1-3">Section 12.1.3, \u201CLoading read-only entities from an HQL query/criteria\u201D</a>获取更多信息。
li12-1-1-4 = 你可以将已经在session中的实体设为只读；查看<a href="#c12-1-4">Section 12.1.4, \u201CMaking a persistent entity read-only\u201D</a>获取更多信息。

#		**********************************************************************************************************
#		12.1.1. Entities of immutable classes
#		**********************************************************************************************************

title12-1-1 = 12.1.1. 不可变实体类
p12-1-1-1 = 当一个不可变类的实体持久化时，Hibernate自动将其设为只读。
p12-1-1-2 = 不可变类的实体可以如同可变类一样创建和删除。
p12-1-1-3 = Hibernate对待不可变类的持久化实体与对待可变类的只读持久化实体相同。唯一的区别自傲与Hibernate不允许改变不可变类实体，如果那样就不是只读的了。

#		**********************************************************************************************************
#		12.1.2. Loading persistent entities as read-only
#		**********************************************************************************************************

title12-1-2 = 12.1.2. 加载持久化数据位只读
nc12-1-2-1 = 不可变类的实体在加载时被自动设为只读。
p12-1-2-1 = 要想使得Hibernate在载入可变类的实体时自动将它们变为只读的，需要：
p12-1-2-2 = 要想改回默认情况，即Hibernate在加载可变实体时不将它们设为只读的，需要：
p12-1-2-3 = 你可以这样来决定当前的设定：
p12-1-2-4 = 如果<code>Session.isDefaultReadOnly()</code>方法返回true，那么在加载实体时会自动变为只读。
li12-1-2-1-1 = <code>Session.load()</code>
li12-1-2-1-2 = <code>Session.get()</code>
li12-1-2-1-3 = <code>Session.merge()</code>
li12-1-2-1-4 = 执行，回滚或者遍历HQL查询或者条件查询；想要定制特殊的HQL查询或者条件查询，查看<a href="#c12-1-3">Section 12.1.3, \u201CLoading read-only entities from an HQL query/criteria\u201D</a>
p12-1-2-5 = 改变这个默认行为对以下情况无效：
li12-1-2-2-1 = 在改变默认值时持久化对象已经在session中
li12-1-2-2-2 = 持久化对象通过调用<code>Session.refresh()</code>方法刷新过；一个被刷新过的持久化对象只有当它刷新前是只读的情况下，它才是只读的。
li12-1-2-2-3 = 当应用程序通过调用<code>Session.persist()</code>, <code>Session.save()</code>, 和 <code>Session.update()</code> <code>Session.saveOrUpdate()</code>方法插入持久化对象

#		**********************************************************************************************************
#		12.1.3. Loading read-only entities from an HQL query/criteria
#		**********************************************************************************************************

title12-1-3 = 12.1.3. 使用Hql查询或者条件查询加载只读实体
nc12-1-3-1 = 不可变实体类在加载时自动设为只读。
p12-1-3-1 = 如果当HQL查询或者条件查询执行时<code>Session.isDefaultReadOnly()</code>方法返回false，那么实体和可变类的代理通过查询加载时不会设为只读。
p12-1-3-2 = 你可以复写Hibernate的默认行为，使得HQL查询或者条件查询在加载实体和代理时自动设为只读。
p12-1-3-3 = 使用HQL查询，调用：
p12-1-3-4 = <code>Query.setReadOnly( true )</code>方法必须在<code>Query.list()</code>, <code>Query.uniqueResult()</code>, <code>Query.scroll()</code>, 或者 <code>Query.iterate()</code>之前调用。
p12-1-3-5 = 使用HQL条件查询，调用：
p12-1-3-6 = <code>Criteria.setReadOnly( true )</code>必须在<code>Criteria.list()</code>, <code>Criteria.uniqueResult()</code>, 或者 <code>Criteria.scroll()</code>之前调用。
p12-1-3-7 = 如果在HQL查询或者条件查询返回之前实体和代理已经存在在session中，那么不会产生效果。
p12-1-3-8 = 查询范湖IDE未初始化的持久化数组是无效的。之后，当集合初始化之后，如果<code>Session.isDefaultReadOnly()</code>返回true，那么session载入的实体将会是只读的。
p12-1-3-9 = 当一个单个查询载入所有的实体，并且初始化所有的代理和集合，而且应用程序要求这些都必须是只读的时候，使用<code>Query.setReadOnly( true )</code> 或 <code>Criteria.setReadOnly( true )</code>是一个好的选择。
p12-1-3-10 = 当不可能通过一次查询字啊如并初始化所有的实体时，你可一尝试改变session的默认行为，使得它在载入实体时将实体变为只读。那么你就可以显示的在存储session之前初始化代理和对象。
p12-1-3-11 = 如果<code>Session.isDefaultReadOnly()</code>方法返回true，那么你可以使用<code>Query.setReadOnly( false )</code> 和 <code>Criteria.setReadOnly( false )</code>来复写这个session的设定，使得其在加载实体时不将它们设为只读。

#		**********************************************************************************************************
#		12.1.4. Making a persistent entity read-only
#		**********************************************************************************************************

title12-1-4 = 12.1.4. 把一个持久化实体变为只读
nc12-1-4-1 = 不变类的持久化实体会自动设为只读。
p12-1-4-1 = 想要将一个持久化实体或者代理设为只读，调用：
p12-1-4-2 = 想要将一个只读的实体或者可变类的代理不再只读，调用：
ic12-1-4-1 = 当一个只读实体或者代理变得不再只读时，Hibernate会假设只读实体的当前状态与数据库呈现的是一致的。如果这个假设是错误的，那么之前所有刷新过的变化或者当它还是只读状态时的操作，都将被忽略。
p12-1-4-3 = 如果想要舍弃为刷新的变化，并且使得持久化对象状态与数据库中一致，调用：
p12-1-4-4 = 如果想要刷新之前的操作，或者To flush changes made before or while the entity was read-only and make the database representation consistent with the current state of the persistent entity:

#		**********************************************************************************************************
#		12.2. Read-only affect on property type
#		**********************************************************************************************************

title12-2 = 12.2. 只读对属性类型的影响
p12-2-1 = 下面这张表总结了只读实体对不同的属性类型的影响。
p12-2-2 = <strong>Table 12.1. Affect of read-only entity on property types</strong>
th12-2-1-1 = 属性/关联 类型
th12-2-1-2 = 是否在数据库刷新?
td12-2-1-1 = 简单类型 (<a href="#c12-2-1">Section 12.2.1, \u201CSimple properties\u201D</a>) 
td12-2-1-2 = 否*
td12-2-1-3 = <p>单向一对一</p><p>单向多对一</p><p>(<a href="#c12-2-2-1">Section 12.2.2.1, \u201CUnidirectional one-to-one and many-to-one\u201D</a>)</p>
td12-2-1-4 = <p>否*</p><p>no*</p>
td12-2-1-5 = <p>单向一对多</p><p>单向多对多</p><p>(<a href="#c12-2-2-2">Section 12.2.2.2, \u201CUnidirectional one-to-many and many-to-many\u201D</a>)</p>
td12-2-1-6 = <p>是</p><p>是</p>
td12-2-1-7 =  <p>双向一对一</p><p>(<a href="#c12-2-3-1">Section&nbsp;12.2.3.1, \u201CBidirectional one-to-one\u201D</a>)</p>
td12-2-1-8 = 只有当拥有实体不是只读时*
td12-2-1-9 = <p>双向一对多/多对一</p><p>逆集合</p><p>非逆集合</p><p>(<a href="#c12-2-3-2">Section&nbsp;12.2.3.2, \u201CBidirectional one-to-many/many-to-one\u201D</a>)</p>
td12-2-1-10 = <p></p><p>只有当被添加/被删除的实体不是只读时*</p><p>是</p>
td12-2-1-11 = <p>双向多对多</p><p>(<a href="#c12-2-3-3">Section&nbsp;12.2.3.3, \u201CBidirectional many-to-many\u201D</a>)</p>
td12-2-1-12 = 是
p12-2-3 = * 当一个实体的属性/关系是只读的和当它们不是只读的行为是不同的。

#		**********************************************************************************************************
#		12.2.1. Simple properties
#		**********************************************************************************************************

title12-2-1 = 12.2.1. 简单属性
p12-2-1-1 = 当一个持久化对象不可修改时，Hibernate不会对简单属性进行脏数据检查。
p12-2-1-2 = Hibernate 也不会把对简单属性所做的修改同步到数据库。如果版本是自动生成的，改变任何简单属性，Hibernate都不会增加版本。 
#		**********************************************************************************************************
#		12.2.2. Unidirectional associations
#		**********************************************************************************************************

title12-2-2 = 12.2.2. 单向关联

#		**********************************************************************************************************
#		12.2.2.1. Unidirectional one-to-one and many-to-one
#		**********************************************************************************************************

title12-2-2-1 = 12.2.2.1. 单向一对一和多对一
p12-2-2-1-1 = 当实体只读时，Hibernate 会以相同的方式处理单向一对一和多对一。 
p12-2-2-1-2 = 我们使用术语“单向单端关联”来描述通常的单向一对一和多对一关联。
p12-2-2-1-3 = 当实体是只读时，Hibernate不对单向单节点关联进行脏检查。
p12-2-2-1-4 = 如果你修改一个只读实体的应用从单向单端关联到null，或者指向一个不同的实体，那么这个修改将不会被保存到数据库。
nc12-2-2-1-1 = 如果一个实体是不可变类，那么当实体第一次被创建时，必须指定他的单向单端关联。因为这个实体会自动变为只读的,这些引用就不可以被修改。
p12-2-2-1-5 = 如果使用自动版本号，Hibernate不会因为本地对单向单端关联的修改而增加版本号。
p12-2-2-1-6 = 在下面的例子中， Contract和 Plan是单向的多对一关联。 Contract 级联 save 和 update操作。
p12-2-2-1-7 = 下面演示了修改一个只读实体的多对一关联为null，对该实体在数据库中的表示是没有影响的。
p12-2-2-1-8 = 下面演示了尽管对只读实体的多对一关联的修改对实体在数据库中的表示没有产生任何影响。但是在刷新时还是会级联保存和更新本地对关联所做的修改。

#		**********************************************************************************************************
#		12.2.2.2. Unidirectional one-to-many and many-to-many
#		**********************************************************************************************************

title12-2-2-2 = 12.2.2.2. 单向的一对多和多对多
p12-2-2-2-1 = 不管关系拥有实体是不是只读的，Hibernate都会以相同的方式处理单向一对多和多对多。
p12-2-2-2-2 = Hibernate 会对单向一对多和多对多进行脏检查；
p12-2-2-2-3 = 集合可以包含只读实体，同样也可以包含非只读实体。
p12-2-2-2-4 = 可以向集合中添加或者删除实体，这些修改将会被保存到数据库。
p12-2-2-2-5 = 如果版本号是自动生成的。当这个实体变脏时Hibernate会因为对集合的修改而增加版本号。

#		**********************************************************************************************************
#		12.2.3. Bidirectional associations
#		**********************************************************************************************************

title12-2-3 = 12.2.3. 双向关联

#		**********************************************************************************************************
#		12.2.3.1. Bidirectional one-to-one
#		**********************************************************************************************************

title12-2-3-1 = 12.2.3.1. 双向一对一
p12-2-3-1-1 = 如果只读实体拥有双向的一对一关联：
li12-2-3-1-1-1 = Hibernate不需要对关联进行脏检查。 
li12-2-3-1-1-2 = 如修改一个关联的引用为null，或者指向另外的一个实体，这样的修改将不会保存到数据库。
li12-2-3-1-1-3 = 如果版本号是自动生成的，Hibernate不会因为本地对关联所做的修改来增加版本号。
nc12-2-3-1-1 = 如果一个实体类是不可修改的，并且他有一个双向的一对一关联，那么当实体第一次被创建时必须要指定他的应用，因为实体会自动标示为只读的，这些引用就不可以被修改。
p12-2-3-1-2 = 当拥有者不是只读时，不管关联的另一端是不是只读实体，Hibernate都会以相同的方式处理关联。

#		**********************************************************************************************************
#		12.2.3.2. Bidirectional one-to-many/many-to-one
#		**********************************************************************************************************

title12-2-3-2 = 12.2.3.2. 双向的 一对多/多对一
p12-2-3-2-1 = 在以下情况下一个只读实体对双向的一对多和多对一是没有影响的：
li12-2-3-2-1-1 = 只读实体在一的一端并且使用inverse反转集合;
li12-2-3-2-1-2 = 只读实体在一的一端并且使用了非反转集合；
li12-2-3-2-1-3 = 在一的一端使用包含了只读实体的非反转集合。
p12-2-3-2-2 = 当一的一端使用翻转集合时：
li12-2-3-2-2-1 = 一个只读实体只有在被创建时才可以添加到集合中；
li12-2-3-2-2-2 = 一个只读实体只可以通过孤儿删除和显示删除的方式才能够从集合中移除。

#		**********************************************************************************************************
#		12.2.3.3. Bidirectional many-to-many
#		**********************************************************************************************************

title12-2-3-3 = 12.2.3.3. 双向多对多
p12-2-3-3-1 = 不管关系拥有者实体是不是只读的，Hibernate都会以相同的方式处理双向多对多关联。
p12-2-3-3-2 = Hibernate 对双向多对多关联进行脏检查。
p12-2-3-3-3 = 关联的任意一端的集合都可以包含只读实体，同样也可以包含非只读实体。 
p12-2-3-3-4 = 实体可以从关联两端的集合中被添加和移除，所做的修改会被保存到数据库中。
p12-2-3-3-5 = 如果版本号是自动生成的，并且脏实体拥有各自的集合，那么Hibernate将会因为本地的对两端集合的修改而增加版本号。















