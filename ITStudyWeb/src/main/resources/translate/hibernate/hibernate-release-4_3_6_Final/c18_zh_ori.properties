
#		**********************************************************************************************************
#		Chapter 18. Native SQL
#		**********************************************************************************************************

title18 = 第十八章. 本地SQL
p18-1 = 你也可以使用你的数据库的本地SQL语言来查询数据。当你需要使用数据库的某些特性，如查询提示或者Oracle中的<code>CONNECT</code>关键字时，这是非常有用的。这就能够扫清你把原来直接使用SQL/JDBC的程序迁移到基于Hibernate应用的道路上的障碍。
p18-2 = Hibernate 允许你使用手写的SQL, 包括存储过程，来完成所有的create, update, delete, 和 load 操作。

#		**********************************************************************************************************
#		18.1. Using a SQLQuery
#		**********************************************************************************************************

title18-1 = 18.1. 使用SQLQuery
p18-1-1 = 对原生SQL查询执行的控制是通过 <code>SQLQuery</code> 接口进行的,通过执行<code>Session.createSQLQuery()</code>来获取这个接口。 接下来讲解如何使用这个API进行查询。 

#		**********************************************************************************************************
#		18.1.1. Scalar queries
#		**********************************************************************************************************

title18-1-1 = 18.1.1. 标量查询
p18-1-1-1 = 最基本的SQL查询就是获得一个标量(值)的列表。
p18-1-1-2 = 他将返回一个由object数组(Object[])组成的list，数组每个元素都是cats表的一个字段值。Hibernate通过 ResultSetMetadata 来判定返回的标量值的实际顺序和类型。
p18-1-1-3 = 如果要避免过度的使用 ResultSetMetadata, 或者只是为了更加明确的指明返回值，可以使用<code>addScalar()</code>:
p18-1-1-4 = 这个查询指定了:
li18-1-1-1-1 = SQL 查询字符串
li18-1-1-1-2 = 返回的列和类型
p18-1-1-5 = 它仍然会返回Object数组，但是此时不在使用<code>ResultSetMetadata</code>，而是明确的将ID, NAME 和 BIRTHDATE列分别按照Long, String 和 Short类型从resultset中取出。同时也指明了就算query是使用*来查询的，可能获得超过列出的这三个字段，也仅仅会返回这三个字段。
p18-1-1-6 = 也可以忽略全部的或者部分的表两只的类型。
p18-1-1-7 = 这本质上和前面的查询时相同的，但是同时使用了 <code>ResultSetMetaData</code>来确定NAME 和 BIRTHDATE的类型,而ID的类型已经明确指出了。
p18-1-1-8 = 关于从ResultSetMetaData返回的java.sql.Types是如何映射到Hibernate类型的，是由方言决定的。假若某个指定的类型没有被映射，或者不是你所预期的类型，你可以通过Dialect的 <code>registerHibernateType</code> 调用自行定义。

#		**********************************************************************************************************
#		18.1.2. Entity queries
#		**********************************************************************************************************

title18-1-2 = 18.1.2. 实体查询
p18-1-2-1 = 上面的查询都是返回标量值的, 也就是从resultset中返回 "裸" 数据。下面展示如何通过<code>addEntity()</code>让原生查询返回实体对象。
p18-1-2-2 = 这个查询指定:
li18-1-2-1-1 = SQL查询字符串
li18-1-2-1-2 = 要返回的实体
p18-1-2-3 = 假设Cat类被映射为拥有ID, NAME 和 BIRTHDATE 三个字段的类，以上的两个查询都返回一个List，每个元素都是Cat实体。
p18-1-2-4 = 如果实体在映射时有一个<code>many-to-one</code> 的关联指向另外一个实体，在查询时必须返回那个实体，否则会导致发生"column not found"的数据库错误。这些附加的字段可以使用* 标注来自动返回，但是我们还是希望明确指明，看下面这个具有指向Dog的<code>many-to-one</code> 的例子: 
p18-1-2-5 = 这样<code>cat.getDog()</code> 就能正常使用了。

#		**********************************************************************************************************
#		18.1.3. Handling associations and collections
#		**********************************************************************************************************

title18-1-3 = 18.1.3. 处理关联和集合类
p18-1-3-1 = 通过提前抓取将Dog链接获得，而避免初始化proxy带来的额外开销也是可能的。这是通过 <code>addJoin()</code>方法进行的，这个方法可以让你讲关联或集合链接进来。
p18-1-3-2 = 上面这个例子中，返回的Cat对象，其dog属性被完全初始化了，不在需要数据库的额外操作。注意，我们加了一个别名("cat"),以便指明join的目标属性路径。通过同样的提前链接也可以作用于集合类，例如，如果 <code>Cat</code> 有一个指向 <code>Dog</code> 的一对多关联。
p18-1-3-3 = 到此为止，若不对SQL查询进行增强，这已经是在Hibernate中使用原生SQL查询所能做到的最大可能了。当返回多个同样类型的实体或者的别名/字段不够时就会出现问题。

#		**********************************************************************************************************
#		18.1.4. Returning multiple entities
#		**********************************************************************************************************

title18-1-4 = 18.1.4. 返回多个实体
p18-1-4-1 = 到此为止, 结果集字段名被假定和映射文件中指定的的字段名是一致的。假若SQL查询链接了多个表，同一个字段名可能子啊多个表中出现多次，这就会造成问题。
p18-1-4-2 = 下面的查询中需要使用字段别名注射(这个例子本身很大可能会失败):
p18-1-4-3 = 这个查询的本意是希望每行返回两个Cat实例，一个是cat另一个是mother。但是因为他们的字段名被映射为相同的，而且某些数据库中，返回的字段别名是"c.ID", "c.NAME", 这样的形式，而他们和在映射文件中的名字("ID" 和 "NAME")不匹配。
p18-1-4-4 = 下面的形式不容易出现字段名重复:
p18-1-4-5 = 这个查询指定了:
li18-1-4-1-1 = SQL查询语句, 其中包含占位符来让Hibernate注射字段别名。
li18-1-4-1-2 = 查询返回的实体
p18-1-4-6 = 上面使用<code>cat.*</code> 和 <code>mother.*</code> 标记是作为 "所有属性"的简写形式出现的。当然你也可以明确的罗列出字段名，但是在这个例子中我们让Hibernate来为每个属性注射SQL字段别名。字段别名的占位符是属性名加上表别名的前缀。在下面的例子中，我们从另外一个表(cat_log)中通过映射元数据中的指定获取Cat和他的mother。我们也可以在Where子句中使用属性的别名。

#		**********************************************************************************************************
#		18.1.4.1. Alias and property references
#		**********************************************************************************************************

title18-1-4-1 = 18.1.4.1. 别名和属性引用
p18-1-4-1-1 = 在大多数情况下，都需要上面的属性注射，但在使用更加复杂的映射，比如复合属性、通过标示符构造继承树，以及集合类等待情况下，也有一些特别的别名，来允许Hibernate注射合适的别名。
p18-1-4-1-2 = 下表列出了使用别名注射参数的不同可能性。注意下面结果中的别名只是示例，使用时每个别名需要唯一并且不同的名字。
p18-1-4-1-3 = <strong>Table 18.1. 别名注射</strong>
th18-1-4-1-1-1 = 描述
th18-1-4-1-1-2 = 语法
th18-1-4-1-1-3 = 示例
td18-1-4-1-1-1 = 简单属性
td18-1-4-1-1-2 = '{'[aliasname].[propertyname]'}'
td18-1-4-1-1-3 = A_NAME as '{'item.name'}'
td18-1-4-1-1-4 = 复合属性
td18-1-4-1-1-5 = '{'[aliasname].[componentname].[propertyname]'}'
td18-1-4-1-1-6 = CURRENCY as '{'item.amount.currency'}', VALUE as '{'item.amount.value'}'
td18-1-4-1-1-7 = 实体辨别器
td18-1-4-1-1-8 = '{'[aliasname].class'}'
td18-1-4-1-1-9 = DISC as '{'item.class'}'
td18-1-4-1-1-10 = 实体所有属性
td18-1-4-1-1-11 = '{'[aliasname].*'}'
td18-1-4-1-1-12 = '{'item.*'}'
td18-1-4-1-1-13 = 集合键
td18-1-4-1-1-14 = '{'[aliasname].key'}'
td18-1-4-1-1-15 = ORGID as '{'coll.key'}'
td18-1-4-1-1-16 = 集合id
td18-1-4-1-1-17 = '{'[aliasname].id'}'
td18-1-4-1-1-18 = EMPID as '{'coll.id'}'
td18-1-4-1-1-19= 集合元素
td18-1-4-1-1-20 = '{'[aliasname].element'}'
td18-1-4-1-1-21 = XID as '{'coll.element'}'
td18-1-4-1-1-22 = 集合元素的属性
td18-1-4-1-1-23 = '{'[aliasname].element.[propertyname]'}'
td18-1-4-1-1-24 = NAME as '{'coll.element.name'}'
td18-1-4-1-1-25 = 集合元素的所有属性
td18-1-4-1-1-26 = '{'[aliasname].element.*'}'
td18-1-4-1-1-27 = '{'coll.element.*'}'
td18-1-4-1-1-28 = 集合的所有属性
td18-1-4-1-1-29 = '{'[aliasname].*'}'
td18-1-4-1-1-30 = '{'coll.*'}'

#		**********************************************************************************************************
#		18.1.5. Returning non-managed entities
#		**********************************************************************************************************

title18-1-5 = 18.1.5. 返回非受管实体
p18-1-5-1 = 可以对原生SQL查询使用ResultTransformer。这会返回不受Hibernate管理的实体。
p18-1-5-2 = 这个查询指定:
li18-1-5-1-1 = SQL查询字符串
li18-1-5-1-2 = 结果转换器
p18-1-5-3 = 上面的查询将会返回CatDTO的列表，它将被实例化并且将NAME 和 BIRTHNAME 的值注入对应的属性或者字段。

#		**********************************************************************************************************
#		18.1.6. Handling inheritance
#		**********************************************************************************************************

title18-1-6 = 18.1.6. 处理继承
p18-1-6-1 = 原生的SQL查询假若其查询结果实体是继承树中的一部分，它必须包含基类和所有子类的所有属性。

#		**********************************************************************************************************
#		18.1.7. Parameters
#		**********************************************************************************************************

title18-1-7 = 18.1.7. 参数
p18-1-7-1 = 原生查询支持位置参数和命名参数:

#		**********************************************************************************************************
#		18.2. Named SQL queries
#		**********************************************************************************************************

title18-2 = 18.2. 命名SQL查询
p18-2-1 = 可以在映射文档中定义命名查询，然后就可以像调用一个HQL命名查询一样直接调用，参考e <a href="#c11-4-1-7">Section 11.4.1.7, \u201C外置命名查询\u201D</a>)。这样的话，就不需要调用<code>addEntity()</code>方法。
p18-2-2 = <code>&lt;return-join&gt;</code> 元素用于连接关联， <code>&lt;load-collection&gt;</code> 元素用于将查询定义为预先初始化各个集合。
p18-2-3 = 一个命名查询可能是返回标量值。你必须使用<code>&lt;return-scalar&gt;</code> 元素来指定字段的别名和Hibernate类型:
p18-2-4 = 你可以把结果集映射的信息放在外部的<code>&lt;resultset&gt;</code>元素中国，这样就可以在多个命名查询，或者通过<code>setResultSetMapping()</code> API来访问。
p18-2-5 = 另外，你可以在Java代码中直接使用hbm文件中的结果集定义信息。
p18-2-6 = 到目前为止，我们只研究了使用Hibernate映射文件来外部化SQl查询。使用注解也可以达到同样的效果，被称为命名本地查询。你可以把<code>@NamedNativeQuery</code> (<code>@NamedNativeQueries</code>) 结合 <code>@SqlResultSetMapping</code> (<code>@SqlResultSetMappings</code>)一起使用。 向 <code>@NamedQuery</code>, <code>@NamedNativeQuery</code> 和 <code>@SqlResultSetMapping</code> 可以定义在类级别，但是他们的作用范围是整个应用。
p18-2-7 = <a href="#example-named-native-query-annotation-with-result-set-mapping">Example 18.7, \u201C使用 @NamedNativeQuery 和 @SqlResultSetMapping进行命名查询\u201D</a> 演示了怎样在<code>@NamedNativeQuery</code>中定义resultSetMapping 参数。它代表了定义的 <code>@SqlResultSetMapping</code>的名称。 结果集映射表明了通过本地查询返回的实体。实体的每个字段都绑定了一个SQL别名(或者列名)。所有实体的字段，包括子类的字段和关联实体的外键列都需要在本地SQL中指出。字段定义是可选的，他们映射到的列好和在类中定义的属性有相同的名称。在示例2的实体中，返回Night 和 Area，并且每个声明的属性都和列名关联，实际上列名通过查询得到。
p18-2-8 = 在<a href="#example-implicit-result-set-mapping">Example 18.8, \u201C隐式结果集映射\u201D</a> 结果集映射时隐式的。我们只结果集映射的实体类。那些属性/列的映射是通过使用实体映射值来完成，在这个例子中，model 属性被绑定到the model_txt 列。
p18-2-9 = 最后, 如果相关实体的关联包含一个符合主键， 那么应该为每个外键列使用<code>@FieldResult</code>元素。<code>@FieldResult</code> 名称由关联的属性名加上“.”加上主键对应的属性或者字段名组成。可以参考<a href="#example-field-result-annotation-with-associations">Example 18.9, \u201C在 @FieldResult中使用“.”符号指明关联\u201D</a>。
tc18-2-1 = 如果你使用默认的映射来检索实体，你可以指定<code>resultClass</code>属性来替代 <code>resultSetMapping</code>属性:
p18-2-10 = 在你的一些本地查询中, 你可能会返回标量值，例如 在报表查询时。你可以通过<code>@ColumnResult</code>在 <code>@SqlResultsetMapping</code>中映射他们。你也可以混合使用，在同一个本地查询中返回实体和标量值 (尽管通常不这样做)。
p18-2-11 = 介绍另一个本地查询的小提示： <code>org.hibernate.callable</code> 是true还是false取决于这个查询是不是一个存储过程。

#		**********************************************************************************************************
#		18.2.1. Using return-property to explicitly specify column/alias names
#		**********************************************************************************************************

title18-2-1 = 18.2.1. 使用return-property来明确地指定字段/别名
p18-2-1-1 = 使用<code>&lt;return-property&gt;</code>你可以明确的告诉Hibernate使用哪些字段别名,这取代了使用'{''}'-语法来让Hibernate注入它自己的别名。比如：
p18-2-1-2 = 对于多列<code>&lt;return-property&gt;</code>同样可行。它解决了使用'{''}'-语法不能细粒度控制多个字段的限制。
p18-2-1-3 = 注意在这个例子中,我们使用了<code>&lt;return-property&gt;</code>结合'{''}'的注入语法.。允许用户来选择如何引用字段以及属性。
p18-2-1-4 = 如果你映射一个识别器(discriminator),你必须使用<code>&lt;return-discriminator&gt;</code>来指定识别器字段。

#		**********************************************************************************************************
#		18.2.2. Using stored procedures for querying
#		**********************************************************************************************************

title18-2-2 = 18.2.2. 使用存储过程查询
p18-2-2-1 = Hibernate支持使用存储过程和方法来查询。在一下的说明中，这两者一般都适用。T存储过程/函数必须返回一个结果集，作为Hibernate能够使用的第一个外部参数。下面是一个Oracle9和更高版本的存储过程例子：
p18-2-2-2 = 在Hibernate里要要使用这个查询，你需要通过命名查询来映射它。
p18-2-2-3 = 存储过程只返回标量和实体。不支持<code>&lt;return-join&gt;</code>和<code>&lt;load-collection&gt;</code>。

#		**********************************************************************************************************
#		18.2.2.1. Rules/limitations for using stored procedures
#		**********************************************************************************************************

title18-2-2-1 = 18.2.2.1. 使用存储过程的规则和限制
p18-2-2-1-1 = 想要在Hibernate下使用存储过程，你必须遵守一些过程/方法的原则。如果语句不复合哪些规则，那么它们将不能在Hibernate上运行。如果你无论如何也要运行它们，你必须通过<code>session.connection()</code>来执行它们。不同的数据库有不同的规则，因为不同数据库提供商有不同的存储过程语法/语义。
p18-2-2-1-2 = 存储过程查询不能通过<code>setFirstResult()/setMaxResults()</code>来分页。
p18-2-2-1-3 = 推荐使用标准的SQL92来调用：<code>'{' ? = call functionName(<parameters>) '}'</code> 或者 <code>'{' ? = call procedureName(<parameters>'}'</code>。原声调用语义不被支持。
p18-2-2-1-4 = Oracle的规则如下：
li18-2-2-1-1-1 = 一个方法必须返回一个结果集。存储过程的第一个参数必须是一个OUT，它返回一个结果集。这是通过Oracle 9或10的SYS_REFCURSOR类型来完成的。在Oracle中你需要定义一个<code>SYS_REFCURSOR</code>类型，参见Oracle的手册。
p18-2-2-1-5 = Sybase或者MS SQL server的规则如下：
li8-2-2-1-2-1 = 存储过程必须翻译一个结果集。注意由于哪些数据库支持返回多个结果集和更新数量，Hibernate将会遍历结果集，并将结果集的第一个结果作为返回值。其他的都将被丢弃。
li8-2-2-1-2-2 = 如果你在存储过程中启用<code>SET NOCOUNT ON</code>，那会提高执行的效率，但这不是必须的。

#		**********************************************************************************************************
#		18.3. Custom SQL for create, update and delete
#		**********************************************************************************************************

title18-3 = 18.3. 定制SQL 来create, update 和delete
p18-3-1 = Hibernate可以使用自定义的SQL来尽心插入，更新和删除操作。SQL可以在语句级别或者单个列级别被覆写。在这个章节将讲述语句级别的覆写。有关列级别的，查看<a href="#c5-6">Section 5.6, \u201CColumn transformers: read and write expressions\u201D</a>。例子<a href="#example-custom-crdu-via-annotations">Example 18.11, \u201CCustom CRUD via annotations\u201D</a>展示了如何使用注解自定义SQL操作。
p18-3-2 = <code>@SQLInsert</code>, <code>@SQLUpdate</code>, <code>@SQLDelete</code>, <code>@SQLDeleteAll</code>分别重载了INSERT, UPDATE, DELETE和 DELETE所有语句。这些操作同样可以在Hibernate映射文件中使用 <code>&lt;sql-insert&gt;</code>, <code>&lt;sql-update&gt;</code> 和 <code>&lt;sql-delete&gt;</code>节点替代。可以查看例子<a href="#example-custom-crdu-via-xml">Example 18.12, \u201CCustom CRUD XML\u201D</a>。
p18-3-3 = 如果先要支持存储过程，确保callable属性设为true。使用注解与使用xml一样。
p18-3-4 = 为了检查执行是否正确，Hibernate允许你定义以下三种策略之一：
li8-3-1-1 = none: 不会进行检查：当出现问题是存储过程将会执行失败
li8-3-1-2 = count: 根据行数的变化来检查更新是否成功
li8-3-1-3 = param: 与COUNT模式相近，但是它使用了一个输出参数而不是独立的机制
p18-3-5 = 要想定义结果检查模式，使用检查参数，使用注解和使用xml方式一样。
p18-3-6 = 想要重写相关的语句，使用注解和使用xml完全相同。查看<a href="#example-overriding-sql-collections-annotations">Example 18.13, \u201COverriding SQL statements for collections using annotations\u201D</a>获取更多信息。
tc18-3-1 = 参数的位置顺序是非常重要的，他们必须和Hibernate所期待的顺序相同。你能够通过设定日志调试级别为<code>org.hiberante.persister.entity</code>，来查看Hibernate所期待的顺序。在这个级别下， Hibernate将会打印出create,update和delete实体的静态SQL。（如果想看到预计的顺序。记得不要将定制SQL包含在映射文件里， 因为他们会重载Hibernate生成的静态SQL。）
p18-3-7 = 可以使用<code>@org.hibernate.annotations.Table</code>来为次表重写SQL语句，也可以使用sqlInsert，sqlUpdate和sqlDelete属性。
p18-3-8 = 上面的例子也展示了可以为指定的表（主表或从表）提供指令：这个指令将用来生成DDL。
tc18-3-2 = SQL在你的数据库中直接执行，所以你可以使用你喜欢的任何方言。但如果你使用数据库特定的语法， 这当然会降低你映射的可移植性。
p18-3-9 = 最后，在大多数情况下(最好这么做)，存储过程需要返回插入/更新/删除的行数，因为Hibernate对语句的成功执行有些运行时的检查。Hibernate常会把进行CUD操作的语句的第一个参数注册为一个数值型输出参数。

#		**********************************************************************************************************
#		18.4. Custom SQL for loading
#		**********************************************************************************************************

title18-4 = 18.4. 定制SQL来loading
p18-4-1 = 你也可以声明自己的SLQ（或者HQL）查询来加载实体。就如同插入，跟新和删除一样，这个操作可以在单独列级别完成（查看<a href="#c5-6">Section 5.6, \u201CColumn transformers: read and write expressions\u201D</a>获取更多信息），也可以在语句级别完成。这是一个语句级别实现的例子：
p18-4-2 = 这只是一个前面讨论过的命名查询声明，你可以在类映射里引用这个命名查询：
p18-4-3 = 这也可用于存储过程。
p18-4-4 = 你甚至可以定一个用于集合装载的查询：
p18-4-5 =你甚至还可以定义一个实体装载器，它通过连接抓取装载一个集合：
p18-4-6 = <code>&lt;loader&gt;</code>可用注解的<code>Loader</code>替代，查看<a href="#example-custom-crdu-via-annotations">Example 18.11, \u201CCustom CRUD via annotations\u201D</a>例子。

