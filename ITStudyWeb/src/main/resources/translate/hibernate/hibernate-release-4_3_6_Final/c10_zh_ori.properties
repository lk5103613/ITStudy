
#		**********************************************************************************************************
#		Chapter 10. Inheritance mapping
#		**********************************************************************************************************

title10 = 第十章. 继承映射

#		**********************************************************************************************************
#		10.1. The three strategies
#		**********************************************************************************************************

title10-1 = 10.1. 三种策略
p10-1-1 = Hibernate 支持三种基本的继承映射策略:
li10-1-1-1 = 每个分层结构一张表
li10-1-1-2 = 每个子类一张表
li10-1-1-3 = 每个具体类一张表
p10-1-2 = 另外, Hibernate还支持第四种稍有不同的多态映射策略:
li10-1-2-1 = 隐式多态
p10-1-3 = 对于相同继承结构的不同分支可以采取不同的映射策略。 然后你可以使用隐式的多态来实现跨越真个层次的多态, 但是在相同的根<code>&lt;class&gt;</code>元素下，Hibernate不支持混合使用<code>&lt;subclass&gt;</code>, <code>&lt;joined-subclass&gt;</code> 和 <code>&lt;union-subclass&gt;</code>映射。但是可以混合使用“每个类分层结构一张表”和“每个子类一张表”这两种映射策略，这是通过结合元素<code>&lt;subclass&gt;</code> 和 <code>&lt;join&gt;</code> 实现的 (参考下面的示例)。
p10-1-4 = 在不同的映射文件中可以在根hibernate-mapping下直接定义<code>subclass</code>, <code>union-subclass</code>, 和 <code>joined-subclass</code>。 这就是说，你可以通过仅加入一个新的映射文件来扩展类层次。你必须在subclass 映射中指定extends属性, 并给出一个之前映射过的超类的名字。在以前，这一功能对映射文件的顺序有严格的要求。从Hibernate3开始，使用extends关键字的时候，对映射文件的顺序不在有要求，但在每个映射文件里，超类必须在子类之前定义。

#		**********************************************************************************************************
#		10.1.1. Table per class hierarchy
#		**********************************************************************************************************

title10-1-1 = 10.1.1. 每个类分层结构一张表
p10-1-1-1 = 假设我们有一个接口<code>Payment</code> 和它的实现类<code>CreditCardPayment</code>, <code>CashPayment</code>, 和 <code>ChequePayment</code>。“每个类分层结构一张表”的映射代码如下所示：
p10-1-1-2 = 这种策略只需要一张表。他有一个很大的限制；要求那些有子类定义的字段，例如 <code>CCTYPE</code>, 不能有NOT NULL 约束。

#		**********************************************************************************************************
#		10.1.2. Table per subclass
#		**********************************************************************************************************

title10-1-2 = 10.1.2. 每个子类一张表
p10-1-2-1 = “每个子类一张表”的映射策略，代码如下所示：
p10-1-2-2 = 需要四张表。三张子表通过主键关联到超类表，所以关系模型实际上是一对一关联。

#		**********************************************************************************************************
#		10.1.3. Table per subclass: using a discriminator
#		**********************************************************************************************************

title10-1-3 = 10.1.3. 每个子类一张表: 使用鉴别器
p10-1-3-1 = 对于这种策略，Hibernate的实现不需要鉴别器字段。其他的对象/关系映射工具使用了一种不同于Hibernate的实现方法，该方法要求在超类表中有一个类型辨别字段。Hibernate采用的方法更难实现，但是从关系的角度来说，它更正确。如果你愿意使用带有辨别字段的“每一个子类一张表”的策略，你可以结合使用<code>&lt;subclass&gt;</code> 和 <code>&lt;join&gt;</code>, 如下所示:
p10-1-3-2 = 可选的声明<code>fetch="select"</code>使用来告诉Hibernate在查询超类时，不要使用外部链接来抓取子类ChequePayment数据。

#		**********************************************************************************************************
#		10.1.4. Mixing table per class hierarchy with table per subclass
#		**********************************************************************************************************

title10-1-4 = 10.1.4. 混合使用“每个类分层结构一张表”和“每个子类一张表”
p10-1-4-1 = 你甚至可以采用如下方法混合使用“每个类分层结构一张表”和“每个子类一张表”这两种策略：
p10-1-4-2 = 对上述任何一中映射策略而言，指向根类Payment的关联是使用<code>&lt;many-to-one&gt;</code>进行映射的。

#		**********************************************************************************************************
#		10.1.5. Table per concrete class
#		**********************************************************************************************************

title10-1-5 = 10.1.5. 每个具体类一张表
p10-1-5-1 = 对于每个具体类一张表的映射策略，可以采用两种方法。第一种方法是使用<code>&lt;union-subclass&gt;</code>。
p10-1-5-2 = 这里涉及三张与子类相关的表。每张表对应类的所有属性包括从父类继承的属性。
p10-1-5-3 = 这种方式的限制在于，如果一个属性在超类中做了映射，其字段名必须与所有子类表中定义的相同。不允许在联合子类的继承层次中使用表示生成器策略， 实际上，主键的种子不得不为同一继承层次中的全部联合子类共享。
p10-1-5-4 = 如果你的父类是抽象类，请使用<code>abstract="true"</code>。如果不是抽象的，需要一张额外的表(在上面的例子中默认是PAYMENT), 来保存超类的实例。

#		**********************************************************************************************************
#		10.1.6. Table per concrete class using implicit polymorphism
#		**********************************************************************************************************

title10-1-6 = 10.1.6. 每个使用隐式多态的具体类一张表
p10-1-6-1 = 另一种方式是采用隐式多态:
p10-1-6-2 = 注意，我们并没有明确的提到接口Payment，另外就是Payment的每个属性在子类中都进行了映射。如果你想避免重复，可以考虑使用XML实体(例如，位于DOCTYPE声明内的 [ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ] 和映射中的%allproperties; ).
p10-1-6-3 = 这种方式的缺陷在于，Hibernate在执行多态查询时无法生成带UNION的SQL语句。
p10-1-6-4 = 对于这种映射策略而言，通常使用<code>&lt;any&gt;</code>来映射到 Payment的多态关联。

#		**********************************************************************************************************
#		10.1.7. Mixing implicit polymorphism with other inheritance mappings
#		**********************************************************************************************************

title10-1-7 = 10.1.7. 隐式多态和其他继承映射混合使用
p10-1-7-1 = 每个子类都在各自独立的元素 <code>&lt;class&gt;</code> 中映射, 并且因为 Payment 仅仅是一个接口), 每个子类可以很容易成为另一个集成体系中的一部分。你仍然可以对接口Payment使用多态查询。
p10-1-7-2 = 另外，我们还是没有明确的提到Payment。如果我们针对接口Payment 执行查询, 例如from Payment, Hibernate会自动返回<code>CreditCardPayment</code>的实例 (和他的子类, 因为他们也实现了Payment接口), CashPayment 和 ChequePayment,但是不返回 NonelectronicTransaction的实例。

#		**********************************************************************************************************
#		10.2. Limitations
#		**********************************************************************************************************

title10-2 = 10.2. 限制
p10-2-1 = 对于“每个具体类映射一张表”的映射策略而言，隐式多态的方式有一定的局限性。而<code>&lt;union-subclass&gt;</code> 的限制并没有那么严格。
p10-2-2 = 下面表格中列出了在Hibernate中“每个具体类一张表”的策略和隐式多态的限制。
p10-2-3 = <strong>Table 10.1. Features of inheritance mapping继承映射特性</strong>
th10-2-1-1 = 继承策略
th10-2-1-2 = 多态多对一
th10-2-1-3 = 多态一对一
th10-2-1-4 = 多态一对多
th10-2-1-5 = 多态多对多
th10-2-1-6 = 多态 load()/get()
th10-2-1-7 = 多态查询
th10-2-1-8 = 多态链接
th10-2-1-9 = 外连接读取

td10-2-1-1 = 每个类分层结构一张表
td10-2-1-2 = &lt;many-to-one&gt;
td10-2-1-3 = &lt;one-to-one&gt;
td10-2-1-4 = &lt;one-to-many&gt;
td10-2-1-5 = &lt;many-to-many&gt;
td10-2-1-6 = s.get(Payment.class, id)
td10-2-1-7 = from Payment p
td10-2-1-8 = from Order o join o.payment p
td10-2-1-9 = 支持

td10-2-1-10 = 每个子类一张表
td10-2-1-11 = &lt;many-to-one&gt;
td10-2-1-12 = &lt;one-to-one&gt;
td10-2-1-13 = &lt;one-to-many&gt;
td10-2-1-14 = &lt;many-to-many&gt;
td10-2-1-15 = s.get(Payment.class, id)
td10-2-1-16 = from Payment p
td10-2-1-17 = from Order o join o.payment p
td10-2-1-18 = 支持

td10-2-1-19 = 每个具体类一张表 (联合子类)
td10-2-1-20 = &lt;many-to-one&gt;
td10-2-1-21 = &lt;one-to-one&gt;
td10-2-1-22 = &lt;one-to-many&gt;<br/>(仅对 inverse="true" 的情况)
td10-2-1-23 = &lt;many-to-many&gt;
td10-2-1-24 = s.get(Payment.class, id)
td10-2-1-25 = from Payment p
td10-2-1-26 = from Order o join o.payment p
td10-2-1-27 = 支持

td10-2-1-28 = 每个具体类一张表 (隐式多态)
td10-2-1-29 = &lt;any&gt;
td10-2-1-30 = 不支持
td10-2-1-31 = 不支持
td10-2-1-32 = &lt;many-to-many&gt;
td10-2-1-33 = s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()
td10-2-1-34 = from Payment p
td10-2-1-35 = 不支持
td10-2-1-36 = 不支持












