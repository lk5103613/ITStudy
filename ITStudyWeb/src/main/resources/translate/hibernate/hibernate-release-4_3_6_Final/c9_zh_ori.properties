
#		**********************************************************************************************************
#		Chapter 9. Component Mapping
#		**********************************************************************************************************

title9 = 第九章. 组件映射
p9-1 = 组件(Component)这个概念在Hibernate中几处不同的地方为了不同的目的被重复使用。

#		**********************************************************************************************************
#		9.1. Dependent objects
#		**********************************************************************************************************

title9-1 = 9.1. 依赖对象
p9-1-1 = 组件是一个被包含的对象，它在持久化时被当做值类型而不是实体引用。组件这个概念指的是面向对象的合成概念，并不是系统架构层次上的组件的概念。比如，你可以这样实例化一个<code>person</code>类：
p9-1-2 = 现在在持久化的过程中，<code>Name</code>可以作为<code>Person</code>的一个组件。<code>Name</code>为它要进行持久化的字段定义了访问器方法，但是不需要定义任何接口或申明标示字段。
p9-1-3 = 下面是Hibernate的映射文件：
p9-1-4 = <code>Person</code>表中应该有一下列：<code>pid</code>, <code>birthday</code>, <code>initial</code>, <code>first</code> 和 <code>last</code>。
p9-1-5 = 如同值类型一样，组件不支持共享引用。换句话说，两个<code>person</code>可以有相同的名称，但是两个<code>person</code>对象包含的是两个完全独立的对象，只不过这两个对象的值相同。组件的值可以为空，其定义如下。 每当Hibernate重新加载一个包含组件的对象,如果该组件的所有字段为空，Hibernate将假定整个组件为空。 在大多数情况下,这样假定应该是没有问题的。
p9-1-6 = 组件的属性可以是任何一种Hibernate类型（集合, 多对一关联关系, 其他组件 等）。组件嵌套使用不应该被视作独特的应用。Hibernate更倾向于支持一个精致的对象模型。
p9-1-7 = <code>&lt;component&gt;</code>元素允许有<code>&lt;parent&gt;</code>子元素，用来表明component类中的一个属性是指向包含它的实体的引用。

#		**********************************************************************************************************
#		9.2. Collections of dependent objects
#		**********************************************************************************************************

title9-2 = 9.2. 集合中出现的依赖对象
p9-2-1 = 支持组建的集合 (e.g. 一个元素是Name的数组)。使用<code>&lt;composite-element&gt;</code>标签代替<code>&lt;element&gt;</code>标签来定义你的组建集合：
ic9-2-1 = 如果你定义的Set包含组合元素，正确的是钱 <code>equals()</code> 和 <code>hashCode()</code> 方法非常的重要。
p9-2-2 = 组合元素里可以包含组合元素但是不能包含集合。如果你的组件元素包含组件，那么必须使用 <code>&lt;nested-composite-element&gt;</code> 标签。这是一个相当特殊的案例，在一个组件的集合里，那些组件本身又可以包含其他的组件。这个时候就应该考虑一下使用one-to-many 关联是否会更恰当。尝试对这个组合元素重新建模为一个实体,但是需要注意，虽然Java模型 和重新建模前是一样的，关系模型和持久化语义有些细微的变化。
p9-2-3 = 如果你使用 <code>&lt;set&gt;</code>标签，一个组合元素的映射不支持可以为空的属性。在组合元素表中没有单独的主键列，当删除对象时，Hibernate必须使用每一个字段的值来确定一条记录，如果有null的话，这样做就不可能了。你必须做出选择，要么在组合元素中使用不能为空的属性，或者选择使用 <code>&lt;list&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;bag&gt;</code> 或者 <code>&lt;idbag&gt;</code>。
p9-2-4 = 组合元素有个特别的用法是他可以包含一个<code>&lt;many-to-one&gt;</code> 元素。类似这样的映射允许你讲一个many-to-many 关联表映射为组合元素的集合。接下来的例子是Order 到 Item的多对多的关联,关联属性是 purchaseDate, price 和 quantity:
p9-2-5 = 在双向关联的另一端你不能够引用这些 purchase。组件是值类型并且不允许共享引用。某个特定的 Purchase可以放在Order的集合中,但是它不能同时被Item引用。
p9-2-6 = 三重(或者四重, etc) 关联是可能的:
p9-2-7 = 组件元素可以出现在查询语句中，和关联中的实体使用相同的语法。

#		**********************************************************************************************************
#		9.3. Components as Map indices
#		**********************************************************************************************************

title9-3 = 9.3. Components as Map indices
p9-3-1 = <code>&lt;composite-map-key&gt;</code> 元素允许你把一个组件类映射为map的key，前提是你必须正确的在这个组件类中覆写了<code>hashCode()</code> 和 <code>equals()</code>方法。

#		**********************************************************************************************************
#		9.4. Components as composite identifiers
#		**********************************************************************************************************

title9-4 = 9.4. 组件作为联合标示符
p9-4-1 = 可以使用一个组件作为一个实体的标示符。你的组件类必须满足一下要求：
li9-4-1-1 = 必须实现<code>java.io.Serializable</code>。
li9-4-1-2 = 必须覆写<code>equals()</code> 和 <code>hashCode()</code>方法，始终和组件关键字在数据库中的概念保持一致。
nc9-4-1 = 在Hibernate中,尽管第二个要求不是强制的，但是最好这样做。
p9-4-2 = 不可以使用<code>IdentifierGenerator</code> 来生成组合关键字。应用程序必须分配它自己的标示符。
p9-4-3 = 使用 <code>&lt;composite-id&gt;</code> 标签, 内嵌 <code>&lt;key-property&gt;</code> 元素, 代替通常的<code>&lt;id&gt;</code> 标签。例如，OrderLine 类有一个主键，这个主键依赖于Order的(联合)主键。
p9-4-4 = 任何指向OrderLine 标的外键都有事复合的。在映射文件中，必须为其他类也这样声明。例如，一个指向OrderLine的关联可以这样映射：
tc9-4-1 = <code>column</code> 元素是column属性的替代写法。使用 column 元素可以有更多的配置选项。当使用<code>hbm2ddl</code>时这是非常有用的。
p9-4-5 = OrderLine的<code>many-to-many</code> 关联也使用组合外键。
p9-4-6 = 在Order中,OrderLine的集合则是这样:
p9-4-7 = <code>&lt;one-to-many&gt;</code> 严肃不声明任何的列。
p9-4-8 = 如果<code>OrderLine</code> 本身拥有一个集合, 他也具有组合外键。

#		**********************************************************************************************************
#		9.5. Dynamic components
#		**********************************************************************************************************

title9-5 = 9.5. 动态组件
p9-5-1 = 你甚至可以映射Map类型的属性:
p9-5-2 = 从<code>&lt;dynamic-component&gt;</code> 映射的予以上来讲，他和<code>&lt;component&gt;</code>是相同的。这种映射类型的有点在于通过修改该映射文件，就可以具有在部署时检测真是属性的能力。利用一个DOM解析器，也可以在程序运行时操作映射文件。更好的是，你可以通过Configuration对象来访问或者修改Hibernate的运行时元模型。

#		**********************************************************************************************************
#		Chapter 9. Component Mapping
#		**********************************************************************************************************

title9 = 第九章. 组件映射
p9-1 = 组件(Component)这个概念在Hibernate中几处不同的地方为了不同的目的被重复使用。

#		**********************************************************************************************************
#		9.1. Dependent objects
#		**********************************************************************************************************

title9-1 = 9.1. 依赖对象
p9-1-1 = 组件是一个被包含的对象，它在持久化时被当做值类型而不是实体引用。组件这个概念指的是面向对象的合成概念，并不是系统架构层次上的组件的概念。比如，你可以这样实例化一个<code>person</code>类：
p9-1-2 = 现在在持久化的过程中，<code>Name</code>可以作为<code>Person</code>的一个组件。<code>Name</code>为它要进行持久化的字段定义了访问器方法，但是不需要定义任何接口或申明标示字段。
p9-1-3 = 下面是Hibernate的映射文件：
p9-1-4 = <code>Person</code>表中应该有一下列：<code>pid</code>, <code>birthday</code>, <code>initial</code>, <code>first</code> 和 <code>last</code>。
p9-1-5 = 如同值类型一样，组件不支持共享引用。换句话说，两个<code>person</code>可以有相同的名称，但是两个<code>person</code>对象包含的是两个完全独立的对象，只不过这两个对象的值相同。组件的值可以为空，其定义如下。 每当Hibernate重新加载一个包含组件的对象,如果该组件的所有字段为空，Hibernate将假定整个组件为空。 在大多数情况下,这样假定应该是没有问题的。
p9-1-6 = 组件的属性可以是任何一种Hibernate类型（集合, 多对一关联关系, 其他组件 等）。组件嵌套使用不应该被视作独特的应用。Hibernate更倾向于支持一个精致的对象模型。
p9-1-7 = <code>&lt;component&gt;</code>元素允许有<code>&lt;parent&gt;</code>子元素，用来表明component类中的一个属性是指向包含它的实体的引用。

#		**********************************************************************************************************
#		9.2. Collections of dependent objects
#		**********************************************************************************************************

title9-2 = 9.2. 集合中出现的依赖对象
p9-2-1 = 支持组建的集合 (e.g. 一个元素是Name的数组)。使用<code>&lt;composite-element&gt;</code>标签代替<code>&lt;element&gt;</code>标签来定义你的组建集合：
ic9-2-1 = 如果你定义的Set包含组合元素，正确的是钱 <code>equals()</code> 和 <code>hashCode()</code> 方法非常的重要。
p9-2-2 = 组合元素里可以包含组合元素但是不能包含集合。如果你的组件元素包含组件，那么必须使用 <code>&lt;nested-composite-element&gt;</code> 标签。这是一个相当特殊的案例，在一个组件的集合里，那些组件本身又可以包含其他的组件。这个时候就应该考虑一下使用one-to-many 关联是否会更恰当。尝试对这个组合元素重新建模为一个实体,但是需要注意，虽然Java模型 和重新建模前是一样的，关系模型和持久化语义有些细微的变化。
p9-2-3 = 如果你使用 <code>&lt;set&gt;</code>标签，一个组合元素的映射不支持可以为空的属性。在组合元素表中没有单独的主键列，当删除对象时，Hibernate必须使用每一个字段的值来确定一条记录，如果有null的话，这样做就不可能了。你必须做出选择，要么在组合元素中使用不能为空的属性，或者选择使用 <code>&lt;list&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;bag&gt;</code> 或者 <code>&lt;idbag&gt;</code>。
p9-2-4 = 组合元素有个特别的用法是他可以包含一个<code>&lt;many-to-one&gt;</code> 元素。类似这样的映射允许你讲一个many-to-many 关联表映射为组合元素的集合。接下来的例子是Order 到 Item的多对多的关联,关联属性是 purchaseDate, price 和 quantity:
p9-2-5 = 在双向关联的另一端你不能够引用这些 purchase。组件是值类型并且不允许共享引用。某个特定的 Purchase可以放在Order的集合中,但是它不能同时被Item引用。
p9-2-6 = 三重(或者四重, etc) 关联是可能的:
p9-2-7 = 组件元素可以出现在查询语句中，和关联中的实体使用相同的语法。

#		**********************************************************************************************************
#		9.3. Components as Map indices
#		**********************************************************************************************************

title9-3 = 9.3. Components as Map indices
p9-3-1 = <code>&lt;composite-map-key&gt;</code> 元素允许你把一个组件类映射为map的key，前提是你必须正确的在这个组件类中覆写了<code>hashCode()</code> 和 <code>equals()</code>方法。

#		**********************************************************************************************************
#		9.4. Components as composite identifiers
#		**********************************************************************************************************

title9-4 = 9.4. 组件作为联合标示符
p9-4-1 = 可以使用一个组件作为一个实体的标示符。你的组件类必须满足一下要求：
li9-4-1-1 = 必须实现<code>java.io.Serializable</code>。
li9-4-1-2 = 必须覆写<code>equals()</code> 和 <code>hashCode()</code>方法，始终和组件关键字在数据库中的概念保持一致。
nc9-4-1 = 在Hibernate中,尽管第二个要求不是强制的，但是最好这样做。
p9-4-2 = 不可以使用<code>IdentifierGenerator</code> 来生成组合关键字。应用程序必须分配它自己的标示符。
p9-4-3 = 使用 <code>&lt;composite-id&gt;</code> 标签, 内嵌 <code>&lt;key-property&gt;</code> 元素, 代替通常的<code>&lt;id&gt;</code> 标签。例如，OrderLine 类有一个主键，这个主键依赖于Order的(联合)主键。
p9-4-4 = 任何指向OrderLine 标的外键都有事复合的。在映射文件中，必须为其他类也这样声明。例如，一个指向OrderLine的关联可以这样映射：
tc9-4-1 = <code>column</code> 元素是column属性的替代写法。使用 column 元素可以有更多的配置选项。当使用<code>hbm2ddl</code>时这是非常有用的。
p9-4-5 = OrderLine的<code>many-to-many</code> 关联也使用组合外键。
p9-4-6 = 在Order中,OrderLine的集合则是这样:
p9-4-7 = <code>&lt;one-to-many&gt;</code> 严肃不声明任何的列。
p9-4-8 = 如果<code>OrderLine</code> 本身拥有一个集合, 他也具有组合外键。

#		**********************************************************************************************************
#		9.5. Dynamic components
#		**********************************************************************************************************

title9-5 = 9.5. 动态组件
p9-5-1 = 你甚至可以映射Map类型的属性:
p9-5-2 = 从<code>&lt;dynamic-component&gt;</code> 映射的予以上来讲，他和<code>&lt;component&gt;</code>是相同的。这种映射类型的有点在于通过修改该映射文件，就可以具有在部署时检测真是属性的能力。利用一个DOM解析器，也可以在程序运行时操作映射文件。更好的是，你可以通过Configuration对象来访问或者修改Hibernate的运行时元模型。
