
#		**********************************************************************************************************
#		Chapter 23. Example: Parent/Child
#		**********************************************************************************************************

title23 = 第二十三章. 示例: 父/子
p23-1 = 刚刚接触Hibernate的人大多数是从父子关系的建模入手的。父子关系的建模有两种方式。对于新用户来讲，最方便的方式是把Parent和Child都建模成实体，并创建从<code>Parent</code>指向<code>Child</code>的 <code>&lt;one-to-many&gt;</code>关联。另外一种方式是将Child声明为一个 a <code>&lt;composite-element&gt;</code>组件。事实上在Hibernate中one-to-many关联的默认语义远远没有 composite element贴近parent/child关系的语义。下面我们会阐述如何使用带有级联的双向一对多关联去建立有效、优美的parent/child关系。

#		**********************************************************************************************************
#		23.1. A note about collections
#		**********************************************************************************************************

title23-1 = 23.1. 关于集合需要注意的一点
p23-1-1 = Hibernate collections 被当做其所属实体而不是被包含实体的一个逻辑部分。这非常重要，它主要体现为以下几点：
li23-1-1-1 = 当你删除或增collection中的对象的时候，collection所属的版本值会递增。
li23-1-1-2 = 如果一个从collection中移除的对象是一个值类型的实例 (例如 composite element),对象的持久化状态将会终止并且在数据库中对应的记录会被删除。同样的，向collection中增加一个值类型的实例将会使之立即被持久化。
li23-1-1-3 = 另一方面, 如果从一对多或者多对多关联的collection中移除一个实体，在缺省情况下这个对象并不会被删除。这个行为是完全合乎逻辑的，改变一个实体的内部状态不应该使与它关联的实体消失掉，同样的，向collection增加一个实体不会使之被持久化。
p23-1-2 = 实际上，向collection中增加一个实体的缺省动作只是在两个实体之间创建一个链接而已，同样的删除一个实体的时候也只是删除链接。这种处理方式对所有的情况都是合适的。然而对于父子关系则是完全不合适的，在这种关系中，子对象的生存绑定于父对象的生存周期。

#		**********************************************************************************************************
#		23.2. Bidirectional one-to-many
#		**********************************************************************************************************

title23-2 = 23.2. 双向的 one-to-many
p23-2-1 = 假设我们要实现一个简单的从Parent到Child的 <code>&lt;one-to-many&gt;</code> 关联。
p23-2-2 = 如果我们运行以下代码:
p23-2-3 = Hibernate将会产生两条SQL语句:
li23-2-1-1 = 一条<code>INSERT</code> 语句，从c创建一条记录
li23-2-1-2 = 一条 <code>UPDATE</code>语句，创建从p到c的链接
p23-2-4 = 这样做不仅效率低，而且违反了列<code>parent_id</code> 非空的限制。我们可以通过在集合类映射上指定<code>not-null="true"</code>来解决违反非空约束的问题：
p23-2-5 = 然而, 这并非是推荐的解决方法。
p23-2-6 = 这种现象的根本原因是从p到c的链接 (外键<code>parent_id</code>) 没有被当做child对象状态的一部分，因而没有在<code>INSERT</code>语句中被创建. 因此解决的办法就是把这个链接添加到Child的映射中。
p23-2-7 = 我们也需要为Child添加 <code>parent</code> 属性。
p23-2-8 = 现在实体 <code>Child</code> 在管理链接的状态，为了使collection不更新链接，我们使用<code>inverse</code>属性：
p23-2-9 = 下面的代码用于添加一个新的Child:
p23-2-10 = 现在只会有一条 SQL INSERT 语句会被执行。
p23-2-11 = 你也可以为 <code>Parent</code>天剑一个 <code>addChild()</code>方法。
p23-2-12 = 现在，添加<code>Child</code>的代码就是这样:

#		**********************************************************************************************************
#		23.3. Cascading life cycle
#		**********************************************************************************************************

title23-3 = 23.3. 级联生命周期
p23-3-1 = 显示的调用<code>save()</code>仍然很麻烦，我们可以用级联来解决这个问题。
p23-3-2 = 这样上面的代码可以简化为:
p23-3-3 = 同样的, 保存或者删除Parent对象的时候并不需要遍历其子对象。下面的代码会删除对象p以及其索引子对象对应的数据记录。
p23-3-4 = 然而, 这段代码:
p23-3-5 = 不会从数据库中删除c，这种情况下，它只会删除与p之间的链接并且会违反 NOT NULL 约束。你需要显示的调用<code>delete()</code> 来删除Child。
p23-3-6 = 在我们的例子中, 如果没有父对象，子对象就不应该存在，如果将子对象从collection中移除，实际上我们是想删除它。要实现这种要求，就必须使用 <code>cascade="all-delete-orphan"</code>。
p23-3-7 = 即使在collection一方的映射中指定 <code>inverse="true"</code>,级联仍然是通过遍历collection中的元素来处理的。如果你想要通过级联进行子对象的插入、删除、更新操作，就必须把它加到collection中，只调用<code>setParent()</code>是不够的。

#		**********************************************************************************************************
#		23.4. Cascades and unsaved-value
#		**********************************************************************************************************

title23-4 = 23.4. 级联和未保存的值
p23-4-1 = 假设我们从Session中装入了一个Parent对象,用户界面对其进行了修改，然后希望在一个新的Session里面调用<code>update()</code>来保存这些修改。对象Parent包含了子对象的集合，由于打开了级联更新，Hibernate需要知道哪些Child对象是新实例化的，哪些代表数据库中已经存在的记录。 我们假设Parent和Child对象的标示属性都是自动生成的，类型为Long。Hibernate 会使用标示符属性的值，和 version/timestamp 属性的值，来判断哪些子对象是新的。(参考 <a href="#c11-7">Section 11.7, \u201C自动状态检测\u201D</a>。)在Hibernate中, 不在需要显示的指定unsaved-value.
p23-4-2 = 下面的代码将会更新parent和child对象，并插入<code>newChild</code>对象:
p23-4-3 = 这对于自动生成标示符的情况是非常好的, 但是自动分配的标识和复合标识怎么办呢？这就有点麻烦了, 因为 Hibernate不能够区分新实例化的对象和前一个Session装入的对象。在这种情况下，Hibernate会使用timestamp和version属性，或者查询第二级缓存，或者最坏的情况，查询数据库，来确认是否存在此行。

#		**********************************************************************************************************
#		23.5. Conclusion
#		**********************************************************************************************************

title23-5 = 23.5. 结论
p23-5-1 = 上面有不少内容有一些迷惑，然而在实践中他们都工作的很好。大部分的Hibernate应用程序会经常用到父子对象模式。
p23-5-2 = 我们在第一段中提到一个解决方案。上面的这些问题都不会出现在<code>&lt;composite-element&gt;</code> 映射中,它准确的表达了父子关系的语义。很不幸复合元素还有两个重大的限制：复合元素不能拥有collections,并且除了用于唯一的父对象外，他们不能再作为其他任何实体的子对象。 


















