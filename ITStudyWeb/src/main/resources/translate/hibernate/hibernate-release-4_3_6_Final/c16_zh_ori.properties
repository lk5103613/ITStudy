
#		**********************************************************************************************************
#		Chapter 16. HQL: The Hibernate Query Language
#		**********************************************************************************************************

title16 = 第十六章. HQL: Hibernate查询语言
p16-1 = Hibernate 使用了一种非常强大的查询语言(HQL),它从外观上和SQL相似。然而,和SQL相比，HQL是完全面向对象的并且能够理解继承、多态、和关联之类的概念。

#		**********************************************************************************************************
#		16.1. Case Sensitivity
#		**********************************************************************************************************

title16-1 = 16.1. 大小写敏感
p16-1-1 = 除了Java类和属性的名称之外，查询语句不区分大小写。因此<code>SeLeCT</code>和 <code>sELEct</code> 和 <code>SELECT</code>是一样的,但是，<code>org.hibernate.eg.FOO</code> 不等价于<code>org.hibernate.eg.Foo</code>, 并且 <code>foo.barSet</code> 也不等价于 <code>foo.BARSET</code>。
p16-1-2 = 本手册使用小写的HQL关键字。有些用户可能觉得大写的关键字使查询语句的可读性更强，但是这种习惯在嵌入Java代码的查询语句中并不适合。

#		**********************************************************************************************************
#		16.2. The from clause
#		**********************************************************************************************************

title16-2 = 16.2. From子句
p16-2-1 = Hibernate中最简单的查询语句格式如下:
p16-2-2 = 它返回所有eg.Cat类的实例。通常我们不需要使用类的权限定名，因为默认是<code>auto-import</code>的。例如:
p16-2-3 = 可以包含多个类，其查询结果是产生一个笛卡尔积或者产生跨表的链接。
p16-2-4 = 实际上在查询语句中别名以小写字母开头是很好的习惯，因为这样做复合Java变量的命名标准(比如 <code>domesticCat</code>)。

#		**********************************************************************************************************
#		16.3. Associations and joins
#		**********************************************************************************************************

title16-3 = 16.3. 关联与链接
p16-3-1 = 使用关键字Join时，可以为相关联的实体甚至是对一个集合中的全部元素制定一个别名。例如:
p16-3-2 = 被支持的链接类型借鉴了ANSI SQL:
li16-3-1-1 = 内连接
li16-3-1-2 = 左外连接
li16-3-1-3 = 右外连接
li16-3-1-4 = 全链接(并不常用)
p16-3-3 = <code>inner join</code>, <code>left outer join</code> 和 <code>right outer join</code>语句可以简写。
p16-3-4 = 通过使用HQL width关键字你可以指定额外的join条件。
p16-3-5 = 一个"fetch" 链接允许仅仅使用一个选择语句就将相关联的对象或一组值的集合随着他们的父对象的初始化而被初始化，这种方法在使用到集合的情况下尤其有用。它有效的代替了映射文件中的外连接与延迟声明。参考 <a href="#c20-1">Section 20.1, \u201C抓取策略\u201D</a>。
p16-3-6 = 一个fetch链接通常不需要指定别名,因为关联的实体不能再Where子句(或者其他任何子句)中使用。关联的实体也不会在查询结果中直接被返回。但是，他们可以通过父对象关联。只有在递归的链接抓取更深层次的集合时，你在需要指定别名：
p16-3-7 = fetch构造函数不能在使用<code>iterate()</code>调用的查询语句中(尽管可以使用 <code>scroll()</code>)。Fetch也不能与<code>setMaxResults()</code> 或者 <code>setFirstResult()</code>一起使用,因为这些操作是基于结果集的，而预先抓取集合类时可能包含重复的数据，也就是说无法预知精确的行数。 Fetch也不能够与独立的width条件一起使用。通过子啊一次查询中fetch多个集合可以制造出笛卡尔积，因此请多加注意。对于bag映射来说，同时join fetch 多个集合角色可能在某些情况下给出并非预期的结果，也请小心。最后，要注意使用 full join fetch 和 right join fetch 是没有意义的。
p16-3-8 = 如果你使用属性级别的延迟抓取(通过重新别写字节码实现), 可以使用fetch all properties来强制Hibernate立即取得那些原本需要延迟加载的属性。

#		**********************************************************************************************************
#		16.4. Forms of join syntax
#		**********************************************************************************************************

title16-4 = 16.4. join语法形式
p16-4-1 = HQL 支持两种关联join的形式: <code>implicit(隐式)</code> 和 <code>explicit(显示)</code>。
p16-4-2 = 前面给出的查询都是使用显示的形式，就是在From子句中明确的给出了join关键字。这是推荐的方式。
p16-4-3 = <code>隐式</code>的格式不适用join关键字。但是使用“.”来关联。隐式的join可以出现子啊HQL的任何子句中。在最终的SQL语句中，隐式的join会议innerjoin的方式出现。

#		**********************************************************************************************************
#		16.5. Referring to identifier property
#		**********************************************************************************************************

title16-5 = 16.5. 引用标示符属性
p16-5-1 = 有两种方式来引用实体的标示符属性：
li16-5-1-1 = 假设实体没有定义一个非标示符的id属性，那么这种特殊的属性(小写的) id就可以被用于引用实体的标示符属性。
li16-5-1-2 = 如果实体定义了一个标示符属性，你可以使用该属性的名字。
p16-5-2 = 对复合标示符属性的引用也遵守相同的命名规则。如果实体有一个非标示符的id属性，那么组合标示符属性只可以通过定义的名字引用。否则id属性就可以被用于引用标示符属性。 
ic16-5-1 = 请注意, 从3.2.2版本开始, 发生了很大的变化。在前面的版本中，不管他实际的名称，id属性使用指向标示符属性。这就要非标示符的id属性永远不能出现在HQL查询中。

#		**********************************************************************************************************
#		16.6. The select clause
#		**********************************************************************************************************

title16-6 = 16.6. select子句
p16-6-1 = <code>select</code> 子句将那些对象与属性返回到结果集中，考虑一下情况：
p16-6-2 = 将会查询其他Cats的配偶。你可以把这个查询简单的表示为：
p16-6-3 = 查询语句可以返回任何类型的属性，也包括组件类型的属性：
p16-6-4 = 查询语句可以返回多个对象和/或属性，查询结果存放在 <code>Object[]</code>队列中:
p16-6-5 = 或者存放在一个<code>List</code>中:
p16-6-6 = 或者假设<code>Family</code>有一个合适的构造函数，也可以直接返回一个世纪的类型安全的Java对象：
p16-6-7 = 你可以使用as关键字给被选择了的表达式指定别名：
p16-6-8 = 在与select new map语句一起使用时最有用:
p16-6-9 = 该查询返回一个Map对象，内容是别名与被选择的值组成的映射。

#		**********************************************************************************************************
#		16.7. Aggregate functions
#		**********************************************************************************************************

title16-7 = 16.7. 聚集函数
p16-7-1 = HQL 查询甚至可以返回作用于属性之上的聚合函数的计算结果：
p16-7-2 = 支持的函数有:
li16-7-1-1 = avg(...), sum(...), min(...), max(...)
li16-7-1-2 = count(*)
li16-7-1-3 = count(...), count(distinct ...), count(all...)
p16-7-3 = 你可以在select子句中使用算术运算符，接连以及经过验证的SQL函数：
p16-7-4 = <code>distinct</code> 和 <code>all</code> 关键字也可以使用，他们在SQL中有相同的语义。

#		**********************************************************************************************************
#		16.8. Polymorphic queries
#		**********************************************************************************************************

title16-8 = 16.8. 多态查询
p16-8-1 = 一个如下的查询语句:
p16-8-2 = 不仅仅返回 <code>Cat</code>的实例, 同时也返回<code>DomesticCat</code>子类的实例。Hibernate 查询可以在From子句中指定任何Java类和接口。查询会返回继承了该类的实例或者返回声明了该接口的所有持久化类的实例。下面的查询语句返回所有的被持久化对象：
p16-8-3 = <code>Named</code> 接口可能被许多持久化类实现:
p16-8-4 = 最后两个查询将需要多个<code>SQL SELECT</code>。这表明orderby子句没有对整个结果集进行正确的排序，也就是换锁你不能对这样的查询使用<code>Query.scroll()</code>方法。

#		**********************************************************************************************************
#		16.9. The where clause
#		**********************************************************************************************************

title16-9 = 16.9. Where子句
p16-9-1 = Where子句允许你将返回的实例列表的范围缩小。如果内有指定别名，你可以使用属性名来直接饮用属性：
p16-9-2 = 如果有别名,则使用有前缀的属性名:
p16-9-3 = 返回名为'Fritz'的Cat。
p16-9-4 = 下面的查询:
p16-9-5 = 将返回所有满足下面条件的Foo类的实例：存在如下的bar的一个实例，其date属性等于 Foo的startDate属性。复合路径表达式使得where子句非常的强大，考虑如下情况：
p16-9-6 = 该查询将被翻译成为一个含有表连接（内连接）的SQL查询。例如:
p16-9-7 = 在SQL中，你为达此目的将需要进行一个四表连接的查询。
p16-9-8 =  = 运算符不仅可以被用来比较属性的值，也可以用来比较实例：
p16-9-9 = 特殊属性（小写）id可以用来表示一个对象的唯一的标识符。参考 <a href="#c16-5">Section 16.5, \u201C引用标示符属性\u201D</a> 。
p16-9-10 = 第二个查询是有效的。此时不需要进行表连接。
p16-9-11 = 同样也可以使用复合标识符。比如Person类有一个复合标识符，它由 <code>country</code>属性与<code>medicareNumber</code>属性组成。
p16-9-12 = 同样的,第二个查询也不需要进行表连接。
p16-9-13 = 参考<a href="#c16-5">Section 16.5, \u201C引用标示符属性\u201D</a> 获取更多关于引用标示符的信息)
p16-9-14 = 特殊属性class在进行多态持久化的情况下被用来存取一个实例的鉴别值。 一个嵌入到where子句中的Java类的名字将被转换为该类的鉴别值。
p16-9-15 = 你也可以声明一个属性的类型是组件或者复合用户类型以及由组件构成的属性等等. 参考 <a href="#c16-17">Section 16.17, \u201C组件\u201D</a> 获取更多信息。
p16-9-16 = 一个“任意”类型有两个特殊的属性id和class, 来允许我们按照下面的方式表达一个连接 ( <code>AuditLog.item</code> 是一个属性，被映射为 <code>&lt;any&gt;</code>):
p16-9-17 = 在上面的查询中<code>log.item.class</code> 和 <code>payment.class</code>指向完全不同的数据库中的列。

#		**********************************************************************************************************
#		16.10. Expressions
#		**********************************************************************************************************

title16-10 = 16.10. 表达式
p16-10-1 = Where子句中允许使用的表达式包括：
li16-10-1-1 = 数学运算符: +, -, *, /
li16-10-1-2 = 二进制比较运算符: =, >=, <=, <>, !=, like
li16-10-1-3 = 逻辑运算符： <code>and</code>, <code>or</code>, <code>not</code>
li16-10-1-4 = 表明分组的括号( )
li16-10-1-5 = in, not in, between, is null, is not null, is empty, is not empty, member of 和 not member of
li16-10-1-6 = "简单的" case, case ... when ... then ... else ... end, 和 "搜索" case, case when ... then ... else ... end
li16-10-1-7 = 字符串链接 ...||... 或者 concat(...,...)
li16-10-1-8 = current_date(), current_time(), and current_timestamp()
li16-10-1-9 = second(...), minute(...), hour(...), day(...), month(...), and year(...)
li16-10-1-10 = EJB-QL 3.0中定义的任何函数: substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()
li16-10-1-11 = coalesce() 和 nullif()
li16-10-1-12 = str() 把数字或者时间转换为可读的字符串
li16-10-1-13 = cast(... as ...), 第二个参数是Hibernate类型的名字，以及extract(... from ...) if ANSI cast() 和 extract() 被底层数据库支持。
li16-10-1-14 = HQL index() 函数, 作用于join的有序集合的别名。
li16-10-1-15 = HQL 函数，把集合作为参数： size(), minelement(), maxelement(), minindex(), maxindex(), 还有特别的 elements() 并且可以与数量词加以限定：some, all, exists, any, in。
li16-10-1-16 = 任何数据库支持的SQL标量函数，如 sign(), trunc(), rtrim(), and sin()
li16-10-1-17 = JDBC风格的参数传入 ?
li16-10-1-18 = 命名参数 :name, :start_date, and :x1
li16-10-1-19 = SQL 直接常量 'foo', 69, 6.66E+2, '1970-01-01 10:00:01.0'
li16-10-1-20 = Java public static final 常量 eg.Color.TABBY
p16-10-2 = <code>in</code> 和 <code>between</code> 可以按照如下方式使用:
p16-10-3 = 而且否定的格式也可以如下书写：
p16-10-4 = 同样, 子句is null与is not null可以被用来测试空值(null).
p16-10-5 = 在Hibernate配置文件中声明HQL“查询替代（query substitutions）”之后， 布尔表达式（Booleans）可以在其他表达式中轻松的使用:
p16-10-6 = 系统将该HQL转换为SQL语句时，该设置表明将用字符 1 和 0 来 取代关键字true 和 false:
p16-10-7 = 你可以用特殊属性size, 或是特殊函数<code>size()</code>测试一个集合的大小。
p16-10-8 = 对于有序集合, 你可以使用minindex 与 maxindex函数来引用到最小与最大的索引序数。 同理，你可以使用<code>minelement</code> 和 <code>maxelement</code> 函数来引用到一个基本数据类型的集合中最小与最大的元素。例如:
p16-10-9 = 在传递一个集合的索引集或者是元素集(elements与indices 函数) 或者传递一个子查询的结果的时候，可以使用SQL函数<code>any</code>, <code>some</code>, <code>all</code>, <code>exists</code>：
p16-10-10 = 注意这些构造 - <code>size</code>, <code>elements</code>, <code>indices</code>, <code>minindex</code>, <code>maxindex</code>, <code>minelement</code>, <code>maxelement</code> -只可以在Hibernate的Where子句中使用。
p16-10-11 = 索引集合的元素(arrays, lists, 和 maps)指定在Where子句中通过索引引用：
p16-10-12 = 在[]中的表达式甚至可以是一个算数表达式：
p16-10-13 = 对一个一对多的关联或者是值的集合中的元素，HQL 也提供了内置的 <code>index()</code> 函数。
p16-10-14 = 如果底层数据库支持标量的SQL函数，它们也可以被使用：
p16-10-15 = 如果你还不能对所有的这些深信不疑，想想下面的查询。如果使用SQL，语句长度会增长多少，可读性会下降多少：
p16-10-16 = 提示: 会像如下的语句

#		**********************************************************************************************************
#		16.11. The order by clause
#		**********************************************************************************************************

title16-11 = 16.11. order by子句
p16-11-1 = 查询返回的列表(list)可以按照一个返回的类或组件（components)中的任何属性（property）进行排序：
p16-11-2 = 可选的<code>asc</code>或<code>desc</code>关键字指明了按照升序或降序进行排序。
p16-11-3 = 可选的<code>nulls first</code>或者<code>nulls last</code>指明了在排序时空值的优先级。

#		**********************************************************************************************************
#		16.12. The group by clause
#		**********************************************************************************************************

title16-12 = 16.12. group by子句
p16-12-1 = 一个返回聚集值(aggregate values)的查询可以按照一个返回的类或组件（components)中的任何属性（property）进行分组：
p16-12-2 = <code>having</code>子句在这里也允许使用。
p16-12-3 = 如果底层的数据库支持的话(例如不能在MySQL中使用)，SQL的一般函数与聚集函数也可以出现 在<code>having</code>与<code>order by</code>子句中。
p16-12-4 = 注意<code>group by</code>子句与<code>order by</code>子句中都不能包含算术表达式（arithmetic expressions）。也要注意Hibernate目前不会扩展group的实体,因此你不能写group by cat,除非cat的所有属性都不是聚集的(non-aggregated)。你必须明确的列出所有的非聚集属性。

#		**********************************************************************************************************
#		16.13. Subqueries
#		**********************************************************************************************************

title16-13 = 16.13. 子查询
p16-13-1 = 对于支持子查询的数据库来说，Hibernate支持在查询中使用子查询。一个子查询必须被圆括号包裹起来（经常是SQL聚集函数的圆括号）。甚至相互关联的子查询（引用到外部查询中的别名的子查询）也是允许的。
p16-13-2 = 注意HQL查询的子查询只会在<code>select</code>或者<code>where</code>语句中使用。
p16-13-3 = 注意子查询也可以在行值构造语法中使用。查看<a href="#c16-18">Section 16.18, \u201CRow value constructor syntax\u201D</a>获取更多信息。

#		**********************************************************************************************************
#		16.14. HQL examples
#		**********************************************************************************************************

title16-14 = 16.14. HQL例子
p16-14-1 = Hibernate查询可以变得十分强大和复杂。实际上，查询语句的强大正式Hibernate主要优势之一。下面例子中的查询与最近项目中使用的十分相似。请注意，大多数查询你可能写的比例子中要简单的多。
p16-14-2 = 下面这个查询返回订单id，项目数量，给定的最小值和总价值，返回值按照总价排序。为了决定价格，查询使用了当前目录。作为转换结果的SQL查询，使用了<code>ORDER</code>, <code>ORDER_LINE</code>, <code>PRODUCT</code>, <code>CATALOG</code> 和<code>PRICE</code> 库表。
p16-14-3 = 多么糟糕！实际上，在现实生活中，我并不喜欢子查询，所以我的查询更可能看起来这样：
p16-14-4 = 下面一个查询计算每一种状态下的支付的数目，除去所有处于<code>AWAITING_APPROVAL</code>状态的支付，因为在该状态下 当前的用户作出了状态的最新改变。该查询被转换成含有两个内连接以及一个相关联的子选择的SQL查询，该查询使用了表 PAYMENT, PAYMENT_STATUS 以及 PAYMENT_STATUS_CHANGE。 
p16-14-5 = 如果我把<code>statusChanges</code>实例集映射为一个列表（list）而不是一个集合（set）, 书写查询语句将更加简单.
p16-14-6 = 下面一个查询使用了MS SQL Server的 <code>isNull()</code>函数用以返回当前用户所属组织的组织帐号及组织未支付的账。它被转换成一个对表<code>ACCOUNT</code>, <code>PAYMENT</code>, <code>PAYMENT_STATUS</code>, <code>ACCOUNT_TYPE</code>, <code>ORGANIZATION</code> 以及 ORG_USER进行的三个内连接， 一个外连接和一个子选择的SQL查询。
p16-14-7 = 对于一些数据库，我们需要弃用（相关的）子选择。

#		**********************************************************************************************************
#		16.15. Bulk update and delete
#		**********************************************************************************************************

title16-15 = 16.15. 批量更新和删除
p16-15-1 = HQL现在支持<code>update</code>, <code>delete</code> and <code>insert ... select ...</code>语句。查看<a href="#c15-4">Section 15.4, \u201CDML-style operations\u201D</a>获取更多信息。

#		**********************************************************************************************************
#		16.16. Tips & Tricks
#		**********************************************************************************************************

title16-16 = 16.16. 提示和技巧
p16-16-1 = 你可以统计查询结果的数目而不必实际的返回他们：
p16-16-2 = 若想根据一个集合的大小来进行排序，可以使用如下的语句：
p16-16-3 = I如果你的数据库支持子选择，你可以在你的查询的where子句中为选择的大小（selection size）指定一个条件:
p16-16-4 = 如果你的数据库不支持子选择语句，使用下面的查询：
p16-16-5 = 因为内连接（inner join）的原因，这个解决方案不能返回含有零个信息的User 类的实例, 所以这种情况下使用下面的格式将是有帮助的:
p16-16-6 = JavaBean的属性可以被绑定到一个命名查询（named query）的参数上：
p16-16-7 = 通过将接口Query与一个过滤器（filter）一起使用，集合（Collections）是可以分页的：
p16-16-8 = 通过使用查询过滤器（query filter）可以将集合（Collection）的原素分组或排序:
p16-16-9 = 不用通过初始化，你就可以知道一个集合（Collection）的大小：

#		**********************************************************************************************************
#		16.17. Components
#		**********************************************************************************************************

title16-17 = 16.17. 组件
p16-17-1 = 在HQL查询中，组件与使用简单值类型一样使用。它们可以出现在一下<code>select</code>语句中：
p16-17-2 = 在这里<code>Person</code>的名称是一个组件。组件也可以使用在<code>where</code>查询中：
p16-17-3 = 组件也可以使用在<code>order by</code>语句中：
p16-17-4 = 其他组件的一般使用方法请看 <a href="#c16-18">Section 16.18, \u201CRow value constructor syntax\u201D</a>。

#		**********************************************************************************************************
#		16.18. Row value constructor syntax
#		**********************************************************************************************************

title16-18 = 16.18. 行值构造语法
p16-18-1 = HQL支持使用ANSI SQL的行值构造语法，有时也被称为AS元祖语法，虽然底层的数据库可能不支持这种定义。这里，我们大致讲一下多值比较，特别是与组件相关的内容。现在一个<code>Person</code>实体定义了一个<code>name</code>组件：
p16-18-2 = 这样做是可行的，但是显得过于繁琐。你可以使用行值构造语法是这个变得更加简单：
p16-18-3 = 也可以通过使用<code>select</code>查询特定的类型：
p16-18-4 = 子查询中需要比较多个值时，使用行值构造语法也是十分有好处的：
p16-18-5 = 在使用这个语法前需要考虑一件事，那就是查询将会按照组件元数据的子属性排序。













