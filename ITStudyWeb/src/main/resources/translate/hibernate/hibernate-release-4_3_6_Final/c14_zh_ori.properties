
#		**********************************************************************************************************
#		Chapter 14. Interceptors and events
#		**********************************************************************************************************

title14 = 第十四章. 拦截器与事件
p14-1 = 应用程序能够回应Hibernate内部的事件是十分有用的。这样就可以实现某些通用的功能，并可以对Hibernate进行功能性的扩展。

#		**********************************************************************************************************
#		14.1. Interceptors
#		**********************************************************************************************************

title14-1 = 14.1. 拦截器
p14-1-1 = <code>Interceptor</code>接口提供了从session回调应用程序的机制，允许应用程序在持久化对象保存，更新，删除或者加载的时候，检查并（或）修改它们的属性。一种可能的使用场景是用来追踪授权信息。比如，下面的这个拦截器，会在一个实现了 Auditable接口的对象被创建时自动地设置createTimestamp属性，并在实现了 Auditable接口的对象被更新时，同步更新<code>lastUpdateTimestamp</code>属性。
p14-1-2 = 你既可以直接实现拦截器，也可以继承<code>EmptyInterceptor</code>。
p14-1-3 = 有两种类型的拦截器：<code>Session-scoped</code> 和 <code>SessionFactory-scoped</code>。
p14-1-4 = <code>Session-scoped</code>在session打开时被指定。
p14-1-5 = <code>SessionFactory-scoped</code>拦截器要通过<code>Configuration</code>注册，而这必须在创建<code>SessionFactory</code>之前。在这种情况下，给出的拦截器会被这个SessionFactory所打开的所有session使用；除非session打开时明确指明了使用的拦截器。SessionFactory范围内的拦截器，必须是线程安全的，因为多个session可能并发使用这个拦截器，要因此小心不要保存与session相关的状态。

#		**********************************************************************************************************
#		14.2. Event system
#		**********************************************************************************************************

title14-2 = 14.2. 事件系统
p14-2-1 = 如果需要持久层相应特定的事件，你可以使用Hibernate事件框架。时间系统可以用作拦截器，也可以替代它。
p14-2-2 = 愈多Session接口的方法都有对应的事件。所有的事件类型都被定义在了枚举<code>org.hibernate.event.spi.EventType</code>中。当请求来自其中一个方法时，Hibernate session会生成一个对应的事件并将它传给配置好的事件监听器中。系统预设的监听器实现的处理过程就是被监听的方法要做的（被监听的方法所做的其实仅仅是激活监听器，“实际”的工作是由监听器完成的）。不过，你可以自由地选择实现 一个自己定制的监听器（比如，实现并注册用来处理处理LoadEvent的LoadEventListener接口），来负责处理所有的调用Session的<code>load()</code>方法的请求。
nc14-2-1 = 查看Hibernate开发者指导来获取更多信息。
p14-2-3 = 监听器应该被认为是无状态的；它们在请求之间共享，并且不应该有任何状态作为成员变量。
p14-2-4 = 用户自定义的监听器应该实现处理事件的适当接口，或者继承一个基类（甚至是从Hibernate自带的默认事件监听器类继承，为了方便你这样做，这些类都被声明成non-final的了）。这是一个自定义加载事件监听器的例子：

#		**********************************************************************************************************
#		14.3. Hibernate declarative security
#		**********************************************************************************************************

title14-3 = 14.3. Hibernate 安全声明
p14-3-1 = 通常，Hibernate应用程序声明安全机制由会话外观层管理。现在，Hibernate3允许某些特定的行为由JACC进行许可管理，由JAAS进行授权管理。 本功能是一个建立在事件框架之上的可选的功能。
p14-3-2 =首先，你必须要配置适当的事件监听器（event listener），来激活使用JAAS管理授权的功能。查看<strong>Hibernate Developer Guide</strong>获取更多细节。下面是一个有关于用<code>org.hibernate.integrator.spi.Integrator</code>实现这个功能的例子。
p14-3-3 =你同样需要决定如何配置你的JACC provider。一个选择是告诉Hibernate什么权限绑定到什么角色上，这可以在<code>hibernate.cfg.xml</code>文件中实现。



























