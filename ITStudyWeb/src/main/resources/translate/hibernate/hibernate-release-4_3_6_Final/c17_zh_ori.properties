
#		**********************************************************************************************************
#		Chapter 17. Criteria Queries
#		**********************************************************************************************************

title17 = 第十七章. 条件查询
p17-1 = 具有一个直观的，可扩展的条件查询API是Hibernate的特色。

#		**********************************************************************************************************
#		17.1. Creating a Criteria instance
#		**********************************************************************************************************

title17-1 = 17.1. 创建条件实例
p17-1-1 = <code>org.hibernate.Criteria</code>接口表示特定持久类的一个查询。Session是一个<code>Criteria</code>实例的工厂。

#		**********************************************************************************************************
#		17.2. Narrowing the result set
#		**********************************************************************************************************

title17-2 = 17.2. 限制结果集内容
p17-2-1 = 一个单独的查询条件是一个<code>org.hibernate.criterion.Criterion</code>接口的实例。<code>org.hibernate.criterion.Restrictions</code>类定义了一些获取特定内建类<code>Criterion</code>的方法。
p17-2-2 = 约束可以按照逻辑分组。
p17-2-3 = Hibernate提供了许多内建的<code>criterion</code>类（Restrictions子类）。其中最有用的是允许你直接使用SQL。
p17-2-4 = <code>alias</code>占位符应当被替换为被查询实体的列别名。
p17-2-5 = 你也可以从Property实例获取criterion。你可以通过调用<code>Property.forName()</code>方法创建一个Property类：

#		**********************************************************************************************************
#		17.3. Ordering the results
#		**********************************************************************************************************

title17-3 = 17.3. 结果集排序
p17-3-1 = 你可以通过调用<code>org.hibernate.criterion.Order</code>方法对结果进行排序。

#		**********************************************************************************************************
#		17.4. Associations
#		**********************************************************************************************************

title17-4 = 17.4. 关联
p17-4-1 = 你可以使用<code>createCriteria()</code>非常容易的在互相关联的实体间建立约束：
p17-4-2 = 注意第二个<code>createCriteria()</code>返回一个新的<code>Criteria</code>实例，该实例引用<code>kittens</code>集合中的元素。
p17-4-3 = 接下来，替换形态在某些情况下也是很有用的：
p17-4-4 = (<code>createAlias()</code>方法不会创建一个<code>Criteria</code>的新实例。)
p17-4-5 = Cat实例所保存的之前两次查询所返回的kittens集合是没有被条件预过滤的。如果你希望只获得符合条件的kittens，你必须使用<code>ResultTransformer</code>。
p17-4-6 = 另外你可以使用left outer join来对结果集进行操作：
p17-4-7 = 这段代码将会返回名字以good开头的有同伴的猫，和所有没有同伴的猫的集合。当在数据库中返回较大/较复杂结果集之前需要排序或者筛选操作时，这一特性是十分有用的。
p17-4-8 = 如果没有这个特新，那么首先，我们需要在一个查询中加载所有没有同伴的猫。Without this feature, first all of the cats without a mate would need to be loaded in one query.
p17-4-9 = 接下类，我们需要查询名字以good开头的有同伴的猫，并按照同伴的年龄排序。
p17-4-10 = 最后，我们需要在内存中手动对集合进行连接操作。

#		**********************************************************************************************************
#		17.5. Dynamic association fetching
#		**********************************************************************************************************

title17-5 = 17.5. 动态关联抓取
p17-5-1 = 你可以使用<code>setFetchMode()</code>在运行时定义动态关联抓取的语义。
p17-5-2 = 这个查询可以通过外连接抓取<code>mate</code>和<code>kittens</code>。查看<a href="#c20-1">Section 20.1, \u201CFetching strategies\u201D</a>获取更多信息。

#		**********************************************************************************************************
#		17.6. Components
#		**********************************************************************************************************

title17-6 = 17.6. 组件
p17-6-1 = 想要对内嵌组件的属性进行限制，那么在创建<code>Restriction</code>之前需要将组件的属性名放在对应的属性名之前作为前缀。条件查询对象应该被主实体创建，并且不能在组件中创建。比如，Cat拥有一个组件fullName，其中包括<code>firstName</code> 和 <code>lastName</code>：
p17-6-2 = 注意：在查询集合的组件时这并不适用，查看<a href="#c17-7">Section 17.7, \u201CCollections\u201D</a>获取更多信息。

#		**********************************************************************************************************
#		17.7. Collections
#		**********************************************************************************************************

title17-7 = 17.7. 集合
p17-7-1 = 当在条件中使用集合时，有两种截然不同的情况。其中一种情况是如果集合中包含实体(例如. <code>&lt;one-to-many/&gt;</code> 或者 <code>&lt;many-to-many/&gt;</code>)又或者组件 (<code>&lt;composite-element/&gt;</code> ),第二种情况是如果集合中包含标量值时，(<code>&lt;element/&gt;</code>)。在第一种情况下，参照上面章节中<a href="#c17-4">Section 17.4, \u201C关联\u201D</a>限制kittens集合中给出的语法。基本上，我们针对集合属性创建了一个Criteria对象并且限制实体和组件属性使用这个实例。
p17-7-2 = 对于查询包含基本数据类型值的集合，我们也针对这个集合创建了 <code>Criteria</code> 对象, 但是我们使用特殊的“elements”属性来引用这些值。对于一个索引集合，也可以使用"indices"属性来引用这些索引属性。

#		**********************************************************************************************************
#		17.8. Example queries
#		**********************************************************************************************************

title17-8 = 17.8. 查询示例
p17-8-1 = 可以参照<code>org.hibernate.criterion.Example</code>类中给出的示例来创建条件查询。
p17-8-2 = 忽略版本属性, 标示符和关联。默认情况下不包含值为null的属性。
p17-8-3 = 你可以调整<code>Example</code> 示例。
p17-8-4 = 你甚至可以使用示例，在被关联的对象上使用条件查询。

#		**********************************************************************************************************
#		17.9. Projections, aggregation and grouping
#		**********************************************************************************************************

title17-9 = 17.9. 投影, 聚合 和分组
p17-9-1 = <code>org.hibernate.criterion.Projections</code> 类是Projection的实例工厂。通过调用<code>setProjection()</code>应用投影到一个查询。
p17-9-2 = 在一个条件查询中没必要显示的使用 "group by" 。某些投影类型就是被定义为 分组投影，他们也出现在SQL的group by子句中。
p17-9-3 = 你可以选择把一个别名值派给一个投影，这样可以是投影值被约束或排序所引用。下面是两种不同的实现方式：
p17-9-4 = <code>alias()</code> 和 <code>as()</code>方法渐变的将一个投影实例包装到另外一个别名的<code>Projection</code>示例中。 简而言之，当你添加一个投影到一个投影列表中时，你可以为它指定一个别名：
p17-9-5 = 你也可以使用<code>Property.forName()</code>来表示投影：

#		**********************************************************************************************************
#		17.10. Detached queries and subqueries
#		**********************************************************************************************************

title17-10 = 17.10. 离线查询和子查询
p17-10-1 = <code>DetachedCriteria</code> 类使你在一个session范围之外创建一个查询，并且可以使用任意的Session来执行它。
p17-10-2 = <code>DetachedCriteria</code>也可以用来表示子查询。包含子查询的Criterion 实例可以通过<code>Subqueries</code> 或者 <code>Property</code>获得。
p17-10-3 = 相关联的子查询也是有可能的:
p17-10-4 = 基于子查询的多列限制示例:

#		**********************************************************************************************************
#		17.11. Queries by natural identifier
#		**********************************************************************************************************

title17-11 = 17.11. 根据自然标示符查询
p17-11-1 = 对于大多数查询，包括条件查询，因为查询缓存的失效发生的太频繁。查询缓存不是十分高效的。然而，有一种特别的查询，可以通过不变的自然键优化缓存的失效算法。在某些应用中，这种类型的查询比较常见。条件查询API对这种用提提供了特别约束。
p17-11-2 = 首先,你应该对你的Entity使用 <code>&lt;natural-id&gt;</code> 来映射自然间，然后打开二级缓存。
p17-11-3 = 注意，此功能对具有mutable的自然键的Entity并不适用。
p17-11-4 = 一旦打开Hibernate缓存,就可以使用<code>Restrictions.naturalId()</code> 来使用更加高效的缓存算法。




