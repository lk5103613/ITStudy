
#		**********************************************************************************************************
#		Chapter 6. Types
#		**********************************************************************************************************

title6 = 第六章. 类型
p6-1 = 作为一个对象关系映射解决方案， Hibernate需要处理Java和HDBC表示的应用程序数据。例如，一个在线的目录应用程序，很可能会有一个Product对象，而这个对象会包含一些属性，例如sku,name,等，对于一些特殊的属性， Hibernate 必须能够从数据库中读取他们的值，并且能够把这些值写回数据库。这种“编排”是Hibernate type的功能， 它实现了 org.hibernate.type.Type 接口。另外，一个Hibernate类型描述了Java类型的各个方面，比如“怎样检查是否相等？”或者“怎样克隆值？”。
ic6-1 = Hibernate类型不是Java类型也不是一个SQL数据类型；它提供了关于两者的信息。<br/>当你遇到了type术语，对于Hibernate来讲需要注意的是，它可能指向的是Java类型，SQL/JDBC类型或者Hibernate类型。
p6-2 = Hibernate将类型分为两组：值类型(参考 <a href="#c6-1">Section 6.1, \u201C值类型\u201D</a>) 和实体类型 (参考<a href="#c6-2">Section 6.2, \u201C实体类型\u201D</a>)。

#		**********************************************************************************************************
#		6.1. Value types
#		**********************************************************************************************************

title6-1 = 6.1. 值类型
p6-1-1 = 值类型的主要特征是事实上他们不需要定义自身的生命周期。通常会说他们被某些定义了他们生命周期的东西所拥有 (特别是一个实体，稍后我们将会看到)。值类型可以更深入的细分为3个子类型：基本类型(参考 Section 6.1.1, \u201C基本值类型\u201D), 组合类型 (参考 <a href="#c6-1-2">Section 6.1.2, \u201C组合类型\u201D</a>) 和集合类型 (参考<a href="#c6-1-3">Section 6.1.3, \u201C集合类型\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1. Basic value types
#		**********************************************************************************************************

title6-1-1 = 6.1.1. 基本值类型
p6-1-1-1 = 基本值类型的标准是，它们在数据库中映射单个列,非Java聚合类型。 Hibernate内置了一些基本类型，这些将会在下面的Java类型章节中提到。这些主要是遵循JDBC规范中推荐的自然映射。我们将在后面介绍怎样覆写这些映射，怎样提供和使用其他可替代的类型映射。

#		**********************************************************************************************************
#		6.1.1.1. java.lang.String
#		**********************************************************************************************************

title6-1-1-1 = 6.1.1.1. java.lang.String
dd6-1-1-1-1-1 = 字符串到JDBC VARCHAR 类型的映射。 如果没有指定Hibernate类型，这个是String类型的标准映射。<br/><br/>在类型注册表中注册string 和 <code>java.lang.String</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型映射\u201D</a>)。
dd6-1-1-1-1-2 = 字符串到JDBC CLOB 类型的映射。<br/><br/>在注册表中注册为materialized_clob (参考 <a href="c6-5">Section 6.5, \u201C类型注册\u201D</a>)。
dd6-1-1-1-1-3 = 字符串到JDBC LONGVARCHAR 类型的映射<br/><br/>在注册表中注册为text(参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.2. java.lang.Character (or char primitive)
#		**********************************************************************************************************

title6-1-1-2 = 6.1.1.2. java.lang.Character (或者原始的char)
dd6-1-1-2-1-1 = char 或者 <code>java.lang.Character</code>到 JDBC CHAR<br/>的映射。<br/>在注册表中注册为char 和 java.lang.Character(参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.3. java.lang.Boolean (or boolean primitive)
#		**********************************************************************************************************

title6-1-1-3 = 6.1.1.3. java.lang.Boolean (或原始的boolean)
dd6-1-1-3-1-1 = boolean 到JDBC BIT 类型的映射<br/><br/>在注册表中注册为boolean 和 <code>java.lang.Boolean</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。 
dd6-1-1-3-1-2 = boolean 到JDBC INTEGER 类型的映射，<code>0 = false</code>, <code>1 = true</code><br/><br/>注册表中注册为numeric_boolean (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。
dd6-1-1-3-1-3 = boolean 到JDBC CHAR 类型的映射<code>('N' | 'n') = false</code>, <code>( 'Y' | 'y' ) = true</code><br/><br/>注册表中注册为<code>yes_no</code>(参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。
dd6-1-1-3-1-4 = boolean 到JDBC CHAR 类型的映射<code>('F' | 'f') = false</code>, <code>( 'T' | 't' ) = true</code><br/><br/>注册表中注册为<code>true_false</code>(参考 <a href="#c6-5">Section 6.5, \u201C注册类型\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.4. java.lang.Byte (或者原始的byte)
#		**********************************************************************************************************

title6-1-1-4 = 6.1.1.4. java.lang.Byte (或者原始的byte)
dd6-1-1-4-1-1 = byte 或者 java.lang.Byte 到JDBC TINYINT的映射<br/><br/>注册表中注册为 byte 和 <code>java.lang.Byte</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.5. java.lang.Short (或者原始的short)
#		**********************************************************************************************************

title6-1-1-5 = 6.1.1.5. java.lang.Short (或者原始的short)
dd6-1-1-5-1-1 = short 或者 <code>java.lang.Short</code> 到JDBC SMALLINT的映射。<br/><br/>注册表中注册为short 和 <code>java.lang.Short</code> (参考<a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.6. java.lang.Integer (或者原始int)
#		**********************************************************************************************************

title6-1-1-6 = 6.1.1.6. java.lang.Integer (或者原始int)
dd6-1-1-6-1-1 = int 或者 java.lang.Integer到JDBC INTEGER的映射<br/><br/>注册表中注册为int 和 <code>java.lang.Integerin</code>类型(参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.7. java.lang.Long (or long primitive)
#		**********************************************************************************************************

title6-1-1-7 = 6.1.1.7. java.lang.Long (或者原始的long)
dd6-1-1-7-1-1 = long 或者 java.lang.Long到JDBC BIGINT的映射<br/><br/>注册表中注册为long 和 <code>java.lang.Long</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.8. java.lang.Float (or float primitive)
#		**********************************************************************************************************

title6-1-1-8 = 6.1.1.8. java.lang.Float (或者原始的float)
dd6-1-1-8-1-1 = float 或 java.lang.Float到JDBC FLOAT的映射<br/><br/>注册表中注册为float 和 <code>java.lang.Float</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.9. java.lang.Double (or double primitive)
#		**********************************************************************************************************

title6-1-1-9 = 6.1.1.9. java.lang.Double (或者原始的double)
dd6-1-1-9-1-1 = double 或 <code>java.lang.Double</code> 到JDBC DOUBLE的映射<br/><br/>注册表中注册为double和<code>java.lang.Double</code>(参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.10. java.math.BigInteger
#		**********************************************************************************************************

title6-1-1-10 = 6.1.1.10. java.math.BigInteger
dd6-1-1-10-1-1 = <code>java.math.BigInteger</code>到JDBC NUMERIC的映射<br/><br/>注册表中注册为<code>big_integer</code> 和 <code>java.math.BigInteger</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.11. java.math.BigDecimal
#		**********************************************************************************************************

title6-1-1-11 = 6.1.1.11. java.math.BigDecimal
dd6-1-1-11-1-1 = java.math.BigDecimal 到JDBC NUMERIC的映射<br/><br/>注册表中注册为 <code>big_decimal</code> 和 <code>java.math.BigDecimal</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.12. java.util.Date or java.sql.Timestamp
#		**********************************************************************************************************

title6-1-1-12 = 6.1.1.12. java.util.Date or java.sql.Timestamp
dd6-1-1-12-1-1 = <code>java.sql.Timestamp</code> 到JDBC TIMESTAMP的映射<br/><br/>注册表中注册为timestamp, <code>java.sql.Timestamp</code> 和 <code>java.util.Date</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.13. java.sql.Time
#		**********************************************************************************************************

title6-1-1-13 = 6.1.1.13. java.sql.Time
dd6-1-1-13-1-1 = <code>java.sql.Time</code> 到JDBC TIME的映射<br/><br/>注册表中注册为time 和 <code>java.sql.Time</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.14. java.sql.Date
#		**********************************************************************************************************

title6-1-1-14 = 6.1.1.14. java.sql.Date
dd6-1-1-14-1-1 = <code>java.sql.Date</code> 到 JDBC DATE的映射<br/><br/>注册表中注册为date 和 <code>java.sql.Date</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.15. java.util.Calendar
#		**********************************************************************************************************

title6-1-1-15 = 6.1.1.15. java.util.Calendar
dd6-1-1-15-1-1 = <code>java.util.Calendar</code> 到JDBC TIMESTAMP的映射<br/><br/>注册表中注册为 calendar, <code>java.util.Calendar</code> 和 <code>java.util.GregorianCalendar</code>(参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。
dd6-1-1-15-1-2 = <code>java.util.Calendar</code> 到 JDBC DATE的映射<br/><br/>注册表中注册为calendar_date (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.16. java.util.Currency
#		**********************************************************************************************************

title6-1-1-16 = 6.1.1.16. java.util.Currency
dd6-1-1-16-1-1 = <code>java.util.Currency</code> 到JDBC VARCHAR (使用 Currency 码)<br/><br/>注册表中注册为currency 和 <code>java.util.Currency</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.17. java.util.Locale
#		**********************************************************************************************************

title6-1-1-17 = 6.1.1.17. java.util.Locale
dd6-1-1-17-1-1 = <code>java.util.Locale</code> 到JDBC VARCHAR (使用Locale 码)的映射<br/><br/>注册表中注册为locale 和 java.util.Locale (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.18. java.util.TimeZone
#		**********************************************************************************************************

title6-1-1-18 = 6.1.1.18. java.util.TimeZone
dd6-1-1-18-1-1 = <code>java.util.TimeZone</code> 到JDBC VARCHAR (使用TimeZone ID)的映射<br/><br/>注册表中注册为timezone 和 <code>java.util.TimeZone</code>(see <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.19. java.net.URL
#		**********************************************************************************************************

title6-1-1-19 = 6.1.1.19. java.net.URL
dd6-1-1-19-1-1 =  <code>java.net.URL</code> 到 JDBC VARCHAR (使用外部格式)<br/><br/>注册表中注册为url 和 <code>java.net.URL</code>(参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.20. java.lang.Class
#		**********************************************************************************************************

title6-1-1-20 = 6.1.1.20. java.lang.Class
dd6-1-1-20-1-1 = <code>java.lang.Class</code> 到JDBC VARCHAR (使用Class 名)的映射<br/><br/>注册表中注册为class 和 <code>java.lang.Class</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.21. java.sql.Blob
#		**********************************************************************************************************

title6-1-1-21 = 6.1.1.21. java.sql.Blob
dd6-1-1-21-1-1 = <code>java.sql.Blob</code> 到 JDBC BLOB的映射<br/><br/>注册表中注册为 blob 和 <code>java.sql.Blob</code>(参考 <a href="#c6-5">Section 6.5, \u201C类型映射\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.22. java.sql.Clob
#		**********************************************************************************************************

title6-1-1-22 = 6.1.1.22. java.sql.Clob 
dd6-1-1-22-1-1 = <code>java.sql.Clob</code> 到 JDBC CLOB的映射<br/><br/>注册表中注册为clob 和 <code>java.sql.Clob</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.23. byte[]
#		**********************************************************************************************************

title6-1-1-23 = 6.1.1.23. byte[]
dd6-1-1-23-1-1 = 原始byte[] 到JDBC VARBINARY的映射<br/><br/>注册表中注册为 binary 和 byte[](参考<a href="#c6-5">Section 6.5, \u201C类型注册Type registry\u201D</a>)。
dd6-1-1-23-1-2 = 原始byte[] 到 JDBC BLOB的映射<br/><br/>注册表中注册为 materialized_blob (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。 
dd6-1-1-23-1-3 = 原始byte[] 到 JDBC LONGVARBINARY的映射<br/><br/>注册表中注册为image (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.24. Byte[]
#		**********************************************************************************************************

title6-1-1-24 = 6.1.1.24. Byte[]
dd6-1-1-24-1-1 = java.lang.Byte[]到JDBC VARBINARY的映射<br/><br/>注册表中注册为wrapper-binary, Byte[]和 java.lang.Byte[](参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.25. char[]
#		**********************************************************************************************************

title6-1-1-25 = 6.1.1.25. char[]
dd6-1-1-25-1-1 = char[] 到 JDBC VARCHAR的映射<br/><br/>注册表中注册为characters 和 char[] (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.26. Character[]
#		**********************************************************************************************************

title6-1-1-26 = 6.1.1.26. Character[]
dd6-1-1-26-1-1 = java.lang.Character[] 到 JDBC VARCHAR的映射<br/><br/>注册表中注册为 wrapper-characters, Character[] 和 java.lang.Character[] (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.27. java.util.UUID
#		**********************************************************************************************************

title6-1-1-27 = 6.1.1.27. java.util.UUID
dd6-1-1-27-1-1 = <code>java.util.UUID</code> 到JDBC BINARY的映射<br/><br/>注册表中注册为 uuid-binary 和 <code>java.util.UUID</code> (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。
dd6-1-1-27-1-2 = <code>java.util.UUID</code> 到 JDBC CHAR 的映射(尽管 VARCHAR 的现有模式也不错)<br/><br/>注册表中注册为uuid-char (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。
dd6-1-1-27-1-3 = <code>java.util.UUID</code> 到PostgreSQL UUID 数据类型的映射 (通过 Types#OTHER ，取决于PostgreSQL JDBC 驱动如何定义它)。<br/><br/>注册表中注册为pg-uuid (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。

#		**********************************************************************************************************
#		6.1.1.28. java.io.Serializable
#		**********************************************************************************************************

title6-1-1-28 = 6.1.1.28. java.io.Serializable
dd6-1-1-28-1-1 = <code>java.lang.Serializable</code>的实现到JDBC VARBINARY的映射<br/><br/>不像其他的值类型，这种类型是多实例的。它使用<code>java.io.Serializable</code>注册一次。此外他也可以使用实现了 <code>java.io.Serializable</code> 的特定的类名来注册。

#		**********************************************************************************************************
#		6.1.2. Composite types
#		**********************************************************************************************************

title6-1-2 = 6.1.2. 复合类型
nc6-1-2-1 = 在Java持久化API中也称作嵌入类型, 然而Hibernate习惯上把它称为组件。只需要注意在Hibernate的讨论范围内这些术语有同样的语义。
p6-1-2-1 = 组件代表者把值聚合成一个Java类型。例如，你可能有一个<code>Address</code> 类，包含了街道，城市，国家等信息。或者一个Name类包含了某个人名字的一部分。在很多情况下，一个组件和实体非常的类似。一般来说他们都是为应用程序写的特殊的类。他们都可以应用别的应用程序的特定的类，同样的也可以应用集合和一些简单的JDK类型。在之前的讨论中，实际上唯一的区别在于组件不能拥有自己的生命周期并且没有定义标示符。

#		**********************************************************************************************************
#		6.1.3. Collection types
#		**********************************************************************************************************

title6-1-3 = 6.1.3. Collection types
ic6-1-3-1 = 理解集合是至关重要的, 而不是他的内容。集合的内容可以是基本类型，组件或者实体类型(尽管不是集合), 但是集合本身是被拥有者。
p6-1-3-1 = 在<a href="#c7">Chapter 7, Collection mapping</a>中有集合的内容。

#		**********************************************************************************************************
#		6.2. Entity types
#		**********************************************************************************************************

title6-2 = 6.2. 实体类型
p6-2-1 = 定义实体的详细内容在 <a href="#c4">Chapter 4, 持久化类</a>中。出于这次讨论的目的,我们可以说实体(通常对于特定应用)就是关联了数据表中行数据的类。他们通过一个唯一标示符来关联到行。因为这些唯一标示符，实体独立的存在并且定义了自己的生命周期。比如，当我们删除一个Membership,  User 和 Group 实体依然存在。
nc6-2-1 =  实体独立性的概念可以被应用开发者修改，只需要使用cascades的概念。 在关联关系中Cascades允许某些操作从一个实体传递到另一个实体（或者"cascade"）。Cascades 在<a href="#c8">Chapter 8, Association Mappings</a>中有详细介绍。

#		**********************************************************************************************************
#		6.3. Significance of type categories
#		**********************************************************************************************************

title6-3 = 6.3. 类型分类的意义
p6-3-1 = 我们为什么要花费那么多时间将类型分类? 这些差异的重点在哪里?
p6-3-2 = 主要的分类在实体类型和值类型。回顾一下，我们说那些使用自然标示符的实体和其他的对象独立的存在 而值不是。一个应用不能“删除”产品sku;然而当这个产品本身被删除时sku也被移除了(显而易见的，你可以修改一个产品的sku为null或者标记为“go away”。 但是即使是在这里，存取也是通过Product).
p6-3-3 = 你也不可以定义一个关联到Product sku。 你可以通过sku来定义一个到该Product的关联，假设sku是唯一的，但这是完全不相同的。
p6-3-4 = TBC...

#		**********************************************************************************************************
#		6.4. Custom types
#		**********************************************************************************************************

title6-4 = 6.4. 自定义类型
p6-4-1 = Hibernate可以让开发者非常容易的创建自定义类型。例如，也许你想将 type java.lang.BigInteger的属性持久化到 VARCHAR 列。自定义类型并不仅限于将值映射到单个的表列中。例如，也许你想 将 FIRST_NAME, INITIAL and SURNAME 列链接成一个<code>java.lang.String</code>。
p6-4-2 = 有三种方式可以自定义Hibernate类型。 为了说明不同方法之间的区别, 我们可以参考示例，例如我们需要将java.math.BigDecimal 和 <code>java.util.Currency</code>组合到一个自定义的 Money 类。

#		**********************************************************************************************************
#		6.4.1. Custom types using org.hibernate.type.Type
#		**********************************************************************************************************

title6-4-1 = 6.4.1. 使用 org.hibernate.type.Type自定义类型
p6-4-1-1 = 第一种方法是直接实现 <code>org.hibernate.type.Type</code> 接口 (或者是他的一个派生类). 你可能会对更具体的允许注册类型的 <code>org.hibernate.type.BasicType</code> 更感兴趣， (参考 <a href="#c6-5">Section 6.5, \u201C类型注册\u201D</a>)。这种注册的好处是当某个属性的元数据没有指定Hibernate类型时， Hibernate将会查询暴露的属性类型对应的注册类型。在我们的示例中这个属性类型是Money, 我们使用它作为我们在注册表中注册类型的关键字:
ic6-4-1-1 = 重要的是我们要在添加映射之前注册类型。

#		**********************************************************************************************************
#		6.4.2. Custom types using org.hibernate.usertype.UserType
#		**********************************************************************************************************

title6-4-2 = 6.4.2. 使用org.hibernate.usertype.UserType自定义类型
nc6-4-2-1 = <code>org.hibernate.usertype.UserType</code> 和 <code>org.hibernate.usertype.CompositeUserType</code> 都是最初添加的，用于把用户代码和<code>org.hibernate.type.Type</code> 接口的内部改变隔离。
p6-4-2-1 = 第二种方法是使用<code>org.hibernate.usertype.UserType</code> 接口, 它提供了<code>org.hibernate.type.Type</code> 接口的简化视图。使用 <code>org.hibernate.usertype.UserType</code>, 我们自定义的Money类型如下：
p6-4-2-2 = <code>org.hibernate.type.Type</code> 示例和 <code>org.hibernate.usertype.UserType</code> 示例的区别并不大, 这是因为只展示了代码片段。如果你选择<code>org.hibernate.type.Type</code> 这种方法，相比<code>org.hibernate.usertype.UserType</code>来讲有很多方法需要你实现。

#		**********************************************************************************************************
#		6.4.3. Custom types using org.hibernate.usertype.CompositeUserType
#		**********************************************************************************************************

title6-4-3 = 6.4.3. 使用org.hibernate.usertype.CompositeUserType自定义类型
p6-4-3-1 = 第三种方法是使用<code>org.hibernate.usertype.CompositeUserType</code> 接口, 和 <code>org.hibernate.usertype.UserType</code> 的区别在于它让我们可以提供某些信息给Hibernate来处理Money类的构成(尤其是两个属性)。例如，这可以保证我们在HQL中可以使用amount属性的引用。使用 <code>org.hibernate.usertype.CompositeUserType</code>, 我们自定义的Money类如下：

#		**********************************************************************************************************
#		6.5. Type registry
#		**********************************************************************************************************

title6-5 = 6.5. 类型注册
p6-5-1 = 当需要在特定的情况下使用特殊的 <code>org.hibernate.type.Type</code>时，Hibernate内部使用基本类型的注册表(参考 <a href="#c6-1-1">Section 6.1.1, \u201C基本值类型\u201D</a>) 。它也提供了方法让应用可以添加额外的基本类型的注册，同样也可以覆写标准的基本类型的注册。
p6-5-2 = 注册一个新类型或者覆写一个已存在的注册类型，在引导Hibernate时，应用将会使用 <code>org.hibernate.cfg.Configuration</code> 类的registerTypeOverride方法，例如，你想Hibernate使用你自定义的SuperDuperStringType; 在引导时你可以：
p6-5-3 = 需要传递到registerTypeOverride 的参数是一个 <code>org.hibernate.type.BasicType</code>，它是我们之前看到的某个具体的<code>org.hibernate.type.Type</code> 。 它添加了一个方法：
p6-5-4 = 一种方式是使用继承(SuperDuperStringType 继承 <code>org.hibernate.type.StringType</code>); 另一种方式是使用委托。


























