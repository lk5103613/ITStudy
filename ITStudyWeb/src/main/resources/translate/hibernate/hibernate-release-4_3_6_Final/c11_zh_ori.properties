
#		**********************************************************************************************************
#		Chapter 11. Working with objects
#		**********************************************************************************************************

title11 = 第十一章. 使用对象
p11-1 = Hibernate 是完整的对象/关系映射解决方案，它使开发者不在需要理会底层数据库系统的细节，应为它提供了对象状态管理的功能。也就是说，相对于常见的JDBC/SQL 持久层方案中需要管理SQL语句，Hibernate采用了更自然的面向对象的视角来持久化Java应用中的数据。
p11-2 = 换句话说，使用Hibernate的开发者总是关注对象的状态，不必考虑SQL语句的执行。这部分细节是Hibernate需要考虑的，只有开发者在进行系统性能调优的时候才需要进行了解。

#		**********************************************************************************************************
#		11.1. Hibernate object states
#		**********************************************************************************************************

title11-1 = 11.1. Hibernate 对象的状态
p11-1-1 = Hibernate 定义并支持下列对象状态:
li11-1-1-1 = <code>Transient</code> - 由new操作符创建的并且尚未与Hibernate Session关联的对象被认定为瞬时的。它在数据库中没有持久化的表示，并且没有被分配标示符。如果瞬态的对象在程序中没有被引用，那么该对象将会被垃圾回收器销毁。使用 Session to 可以持久化一个对象 (Hibernate会自动执行必要的SQL语句)。
li11-1-1-2 = <code>Persistent</code> - 一个持久化实例在数据库中有相应的记录，并拥有一个持久化标示符。它可以是刚被保存的或者刚被加载的。无论怎样，它存定义于相关联的Session中。 Hibernate可以监听到持久化对象的任何改动，并且在当前工作单元结束时将对象数据与数据库同步。开发者不需要手动执行UPDATE语句，同样的就，将对象从持久化状态变成瞬态时，也不需要执行DELETE语句。
li11-1-1-3 = <code>Detached</code> - 托管的实例是指已经被持久化的，但是关联的Session已经关闭的对象。对托管对象的引用依然有效，对象可继续被修改。在之后一个托管的实例可以重新绑定到一个新的Session上来重新持久化t (并保存所有的修改)。这个功能使长时间的工作单元成为可能，在这个工作单元中需要用户思考的时间。我们称之为应用程序事务。i.e.,从用户的角度看是一个工作单元。
p11-1-2 = 接下来我们讨论状态以及状态间的转换(以及Hibernate中触发转换的方法)。

#		**********************************************************************************************************
#		11.2. Making objects persistent
#		**********************************************************************************************************

title11-2 = 11.2. 使对象持久化
p11-2-1 = 在Hibernate中，新实例化的持久化类的对象时瞬时的。我们可以通过将它与Session相关联来把它持久化:
p11-2-2 = 如果<code>Cat</code>有一个generated 的标示符生成器,当调用<code>save()</code>方法时标示符会自动产生。如果Cat的标示符是assigned 类型的,或者是一个复合主键，那么该标示符应该在调用<code>save()</code>之前手动赋予<code>cat</code>。你也可以使用 <code>persist()</code> 代替<code>save()</code>方法, EJB3 中定义的语义。
li11-2-1-1 = <code>persist()</code> 把一个瞬态的对象持久化。然而，他不保证会立刻给持久化实例分配标示符，也许分配操作将会在flush时执行。 persist()也可以确保 如果在事务边界之外被调用也不会执行insert语句。这种方法适用于被扩展的Session上下文的长期运行的会话中。
li11-2-1-2 = <code>save()</code> 可以确保返回一个标示符。如果执行了 INSERT，会得到一个标示符( e.g. "identity" 生成器, 不是 "sequence"), 那么这个 INSERT 会立即执行，不管你是不是在一个事物中。这种方法在扩展的session/persistence 上下文的长会话中是有问题的。
p11-2-3 = 另一种选择是,你可以使用可以重载版本的<code>save()</code>方法来指定标示符。
p11-2-4 = 如果你持久化的对象有关联的对象(e.g. 前面示例中的 kittens 集合 ), 你可以按照任何顺序来持久化这些对象，除非你在外键列上有 NOT NULL 约束。 Hibernate不会违反外键约束。然而，如果你用错误的顺序持久化对象，那么就可能会违反NOT NULL 约束。
p11-2-5 = 通常你不需要关系这些细节，因为你很可能会使用Hibernate的传播性持久化的功能自动保存相关联的那些对象。这样，违反NOT NULL 约束的情况就不会出现了 - Hibernate 将会管理好所有的事情。传播性持久化将会在本章稍后讨论。

#		**********************************************************************************************************
#		11.3. Loading an object
#		**********************************************************************************************************

title11-3 = 11.3. 装载对象
p11-3-1 = 如果你知道一个对象的标示符，那么就可以通过<code>load()</code> 方法来获取这个对象。<code>load()</code>方法会创建指定类的持久化实例，并从数据库加载其数据。
p11-3-2 = 此外, 你也可以把数据加载到指定的实例上:
p11-3-3 = 请注意，如果没有关联的数据行， <code>load()</code>将会抛出一个 unrecoverable exception。如果该类的映射使用了代理， <code>load()</code> 方法只会返回一个未初始化的代理，并且直到你调用该代理的某个方法时才会去访问数据库。如果你希望在某个对象中创建一个指向另一个对象的关联，又不想在从数据库中装载该对象的同时装载相关联的那个对象，那么这种操作方式就用的上了。如果在相应类映射关系设置了batch-size，那么使用这种操作方式允许多个对象被一批装载。
p11-3-4 = 如果你不确定是否有匹配行的存在，你应该使用get()方法，它会立刻访问数据库并且如果没有响应的记录时返回null.
p11-3-5 = 你甚至可以选用一个LockMode，用SQL的<code>SELECT ...</code> FOR <code>UPDATE</code>来加载对象。参考API文档获取更多的信息。
p11-3-6 = 任何关联的对象或者包含的集合都不会被以<code>FOR UPDATE</code>方式返回, 除非你指定了lock或者all作为关联的级联风格。
p11-3-7 = 任何时候都可以使用<code>refresh()</code> 方法强迫装载对象和它的集合。 如果你使用数据库触发器功能来处理对象的某些属性，这个方法就很有用了。
p11-3-8 = Hibernate会从数据库中装载多少东西？会执行多少条相应的<code>SQL SELECTs</code>语句？这取决于抓取策略。在 <a href="#c20-1">Section 20.1, \u201C抓取策略\u201D</a>中解释。

#		**********************************************************************************************************
#		11.4. Querying
#		**********************************************************************************************************

title11-4 = 11.4. 查询
p11-4-1 = 如果不知道所要寻找的对象的持久化标识，那么你需要使用查询。Hibernate支持强大且易于使用的面向对象查询语言(HQL)。如果希望通过编程的方式创建查询， Hibernate提供了完善的按条件(Query By Criteria, QBC)以及按样例(Query By Example, QBE)进行查询的功能。你也可以用原生SQL(native SQL)描述查询，Hibernate额外提供了将结果集转化为对象的支持。

#		**********************************************************************************************************
#		11.4.1. Executing queries
#		**********************************************************************************************************

title11-4-1 = 11.4.1. 执行查询
p11-4-1-1 = HQL和原生SQL查询要通过为 <code>org.hibernate.Query</code>的实例来表达. 这个接口提供了参数绑定、结果集处理以及运行实际查询的方法。你总是可以通过当前Session获取一个Query对象：
p11-4-1-2 = 一个查询通常在调用<code>list()</code>时被执行。执行结果会完全装载进内存中的一个集合。查询返回的对象处于持久化状态。如果你知道的查询只会返回一个对象，可使用list()的快捷方式<code>uniqueResult()</code>。注意，使用集合预先抓取的查询往往会返回多次根对象，们的集合类都被初始化了。你可以通过一个集合来过滤这些重复对象。

#		**********************************************************************************************************
#		11.4.1.1. Iterating results
#		**********************************************************************************************************

title11-4-1-1 = 11.4.1.1. 迭代式获取结果
p11-4-1-1-1 = 某些情况下, 你可以使用 <code>iterate()</code>方法得到更好的性能。这通常是你预期返回的结果在session或者二级缓存中已经存在的情况。如果没有被缓存， <code>iterate()</code> 会比<code>list()</code>更慢，并且在一个简单的查询中可能需要多次访问数据库。iterate()会首先使用1条语句得到所有对象的持久化标识，再根据持久化标识执行n条附加的select语句实例化实际的对象。

#		**********************************************************************************************************
#		11.4.1.2. Queries that return tuples
#		**********************************************************************************************************

title11-4-1-2 = 11.4.1.2.  返回元组的查询
p11-4-1-2-1 =  Hibernate查询有时返回元组(tuples)，每个元组(tuples)以数组的形式返回:

#		**********************************************************************************************************
#		11.4.1.3. Scalar results
#		**********************************************************************************************************

title11-4-1-3 = 11.4.1.3. 标量结果
p11-4-1-3-1 = 查询可在select从句中指定类的属性，甚至可以调用SQL统计(aggregate)函数。属性或统计结果被认定为"标量Scalar"的结果而不是持久(persistent state)的实体。

#		**********************************************************************************************************
#		11.4.1.4. Bind parameters
#		**********************************************************************************************************

title11-4-1-4 = 11.4.1.4. 绑定参数
p11-4-1-4-1 = 接口<code>Query</code> 提供了对命名参数、JDBC风格的问号(?)参数进行绑定的方法。不同于JDBC，ibernate对参数从0开始计数。命名参数(named parameters)在查询字符串中是形如<code>:name</code> 的标识符。命名参数的优点是:
li11-4-1-4-1-1 = 命名参数与其在查询串中出现的顺序无关
li11-4-1-4-1-2 = 它们可在同一查询串中多次出现
li11-4-1-4-1-3 = 它们本身是自我说明的

#		**********************************************************************************************************
#		11.4.1.5. Pagination
#		**********************************************************************************************************

title11-4-1-5 = 11.4.1.5. 分页
p11-4-1-5-1 = 如果你需要指定结果集的范围，希望返回的最大行数/或开始的行数, 应该使用Query接口提供的方法:
p11-4-1-5-2 = Hibernate 知道如何将这个有限定条件的查询转换成你的数据库的原生SQL。

#		**********************************************************************************************************
#		11.4.1.6. Scrollable iteration
#		**********************************************************************************************************

title11-4-1-6 = 11.4.1.6. 可滚动遍历
p11-4-1-6-1 = 如果你的JDBC驱动支持可滚动的ResuleSets, Query接口可以使用ScrollableResults，允许你在查询结果中灵活游走。
p11-4-1-6-2 = 请注意，使用此功能需要保持数据库连接（以及游标(cursor)）处于一直打开状态。如果你需要断开连接使用分页功能，请使用 <code>setMaxResult()/setFirstResult()</code> 方法。

#		**********************************************************************************************************
#		11.4.1.7. Externalizing named queries
#		**********************************************************************************************************

title11-4-1-7 = 11.4.1.7. 外置命名查询
p11-4-1-7-1 = 你可以在映射文件中或者注解中定义命名查询。 <code>@NamedQuery</code> 和 <code>@NamedQueries</code> 可以被定义在类上，参考 <a href="#example-named-query-annotation">Example 11.1, \u201C 使用 @NamedQuery定义命名查询\u201D</a>。然而他们是定义在全局的 session工厂/实体管理工厂范围。 一个命名查询由他的名字和实际的查询字符串组成。
p11-4-1-7-2 = 在映射文件中可以使用 <code>&lt;query&gt;</code> 节点配置。 如果你的查询串中包含可能被解释为XML标记(markup)的字符，别忘了用CDATA包裹起来。
p11-4-1-7-3 = 参数绑定及执行以编程方式完成，参考 <a href="#example-parameter-binding-named-query">Example 11.3, \u201C命名查询的参数绑定\u201D</a>。
p11-4-1-7-4 = 请注意实际的程序代码与所用的查询语言无关。你也可在元数据中定义原生SQL查询，或将原有的其他的查询语句放在配置文件中，这样就可以让Hibernate统一管理，达到迁移的目的。
p11-4-1-7-5 = 也请注意在<code>&lt;hibernate-mapping&gt;</code>元素中声明的查询必须有一个全局唯一的名字。而在<code>&lt;class&gt;</code>元素中声明的查询自动具有全局名，是通过类的全名加以限定的。比如<code>eg.Cat.ByNameAndMaximumWeight</code>。

#		**********************************************************************************************************
#		11.4.2. Filtering collections
#		**********************************************************************************************************

title11-4-2 = 11.4.2. 过滤集合
p11-4-2-1 =集合过滤器<code>filter</code>是一种用于一个持久化集合或者数组的特殊的查询。查询字符串中可以使用"this"来引用集合中的当前元素。
p11-4-2-2 = 返回的集合可以被认为是一个bag,它是所给集合的副本。 原来的集合不会被改动。这与“过滤器filter”的含义不符，不过与我们期待的行为一致。
p11-4-2-3 = 请注意过滤器并不需要from子句，当然需要的话它们也可以加上，过滤器不限定于只能返回集合元素本身。
p11-4-2-4 = 即使无条件的过滤器也是有意义的。例如，用于加载一个大集合的子集：

#		**********************************************************************************************************
#		11.4.3. Criteria queries
#		**********************************************************************************************************

title11-4-3 = 11.4.3. 条件查询
p11-4-3-1 = HQL极为强大，但是有些人希望能够动态的使用一种面向对象API创建查询，而非在他们的Java代码中嵌入字符串。对于那部分人来说，Hibernate提供了直观的Criteria查询API：
p11-4-3-2 = Criteria以及相关的样例(Example)API将会再 <a href="#c17">Chapter 17, 条件查询</a>中详细讨论。

#		**********************************************************************************************************
#		11.4.4. Queries in native SQL
#		**********************************************************************************************************

title11-4-4 = 11.4.4.  使用原生SQL的查询
p11-4-4-1 = 你可以使用<code>createSQLQuery()</code>方法，用SQL来描述查询。并由Hibernate将结果集转换成对象。请注意，你可以在任何时候调用<code>session.connection()</code> 来获得并使用JDBC Connection对象。如果你选择使用Hibernate的API, 你必须把SQL别名用大括号包围起来:
p11-4-4-2 = SQL queries can contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <a href="c18">Chapter 18, Native SQL</a>.

#		**********************************************************************************************************
#		11.5. Modifying persistent objects
#		**********************************************************************************************************

title11-5 = 11.5. 修改持久对象
p11-5-1 = 事务中的持久实例(就是通过session装载、保存、创建或者查询出的对象) 可以被应用程序修改，并且在session flush时所用的修改都会被持久化。本章后面会详细讨论。这里不需要调用某个特定的方法 (比如 <code>update()</code>, 设计它的目的是不同的) 将你的修改持久化。所以最直接的更新一个对象的方法就是在Session处于打开状态时<code>load()</code>它，然后直接修改即可：
p11-5-2 = 有时这种程序模型效率低下，因为在相同的session中他需要执行<code>SELECT</code> 来加载实体，再使用SQL 的<code>UPDATE</code> 语句来持久化所做的修改。为此Hibernate提供了另一种途径，使用脱管实例。

#		**********************************************************************************************************
#		11.6. Modifying detached objects
#		**********************************************************************************************************

title11-6 = 11.6. 修改脱管对象
p11-6-1 = 很多程序需要在某个事务中获取对象，然后将对象发送到界面层去操作，最后在一个新的事务保存所做的修改。在高并发访问的环境中使用这种方式，通常使用附带版本信息的数据来保证这些“长“工作单元之间的隔离。
p11-6-2 = Hibernate 通过提供<code>Session.update()</code>或<code>Session.merge()</code>重新关联脱管实例的办法来支持这种模型:
p11-6-3 = 如果具有<code>catId</code>持久化标识的<code>Cat</code>之前已经被另一Session(<code>secondSession</code>)装载了，应用程序进行重关联操作(reattach)的时候会抛出一个异常。
p11-6-4 = 如果你确定当前session没有包含与之具有相同持久化标识的持久实例，则使用<code>update()</code>方法。如果想随时合并你的的改动而不考虑session的状态，使用<code>merge()</code> 方法。换句话说，在一个新session中通常第一个调用的是<code>update()</code>方法，以便保证重新关联脱管对象的操作首先被执行。
p11-6-5 = 如果希望相关联的脱管对象（通过引用“可到达”的脱管对象）的数据也要更新到数据库时（并且也仅仅在这种情况）， 可以对该相关联的脱管对象单独调用<code>update()</code> 当然这些可以自动完成，即通过使用传播性持久化，参考 <a href="#c11-11">Section 11.11, \u201C传播性持久化\u201D</a>。
p11-6-6 = <code>lock()</code> 方法也允许程序重新关联某个对象到一个新session上。不过，该脱管(detached)的对象必须是没有修改过的。
p11-6-7 = 请注意，<code>lock()</code>可以搭配多种LockMode， 更多信息请阅读API文档以及关于事务处理的章节。重新关联不是<code>lock()</code>的唯一用途。
p11-6-8 = 其他用于长时间工作单元的模型会在<a href="#c13-3">Section 13.3, \u201COptimistic concurrency control\u201D</a>中讨论。

#		**********************************************************************************************************
#		11.7. Automatic state detection
#		**********************************************************************************************************

title11-7 = 11.7. 自动状态监测
p11-7-1 = Hibernate的用户曾要求一个既可自动分配新持久化标识(identifier)保存瞬时(transient)对象，又可更新/重新关联脱管(detached)实例的通用方法。<code>saveOrUpdate()</code>方法实现了这个功能。
p11-7-2 = 对于新用户来讲，<code>saveOrUpdate()</code>的用途和语义可能会困扰他们。首先，只要你没有尝试在一个session中使用另一个session的实例，你不需要使用<code>update()</code>, <code>saveOrUpdate()</code>, 或者 <code>merge()</code>。有的应用从头至尾都没有用到这些方法。
p11-7-3 = 通常情况下<code>update()</code>或者<code>saveOrUpdate()</code>是在以下这些情况下使用的：
li11-7-1-1 = t程序在第一个session中加载对象
li11-7-1-2 = 该对象被传递到表现层
li11-7-1-3 = 对象发生了一些改动
li11-7-1-4 = t该对象被返回到业务逻辑层
li11-7-1-5 = 程序调用第二个session的<code>update()</code>方法持久这些改动
p11-7-4 = <code>saveOrUpdate()</code>做以下这些事：
li11-7-2-1 = 如果对象已经在本session中持久化了，不做任何事
li11-7-2-2 = 果另一个与本session关联的对象拥有相同的持久化标识(identifier)，抛出一个异常
li11-7-2-3 = 如果对象没有持久化标识(identifier)属性，对其调用<code>save()</code>
li11-7-2-4 = 如果对象的持久标识(identifier)表明其是一个新实例化的对象，对其调用<code>save()</code>
li11-7-2-5 = 如果对象是附带版本信息的（通过<code>&lt;version&gt;</code>或<code>&lt;timestamp&gt;</code>） 并且版本属性的值表明其是一个新实例化的对象，<code>save()</code>它。
li11-7-2-6 = 否则<code>update()</code> 这个对象
p11-7-5 = <code>merge()</code>可非常不同:
li11-7-3-1 = 如果session中存在相同持久化标识(identifier)的实例，用用户给出的对象的状态覆盖旧有的持久实例
li11-7-3-2 = 如果session没有相应的持久实例，则尝试从数据库中加载，或创建新的持久化实例
li11-7-3-3 = 最后返回该持久实例
li11-7-3-4 = 用户给出的这个对象没有被关联到session上，它依旧是脱管的

#		**********************************************************************************************************
#		11.8. Deleting persistent objects
#		**********************************************************************************************************

title11-8 = 11.8. 删除游离对象
p11-8-1 = <code>Session.delete()</code>将会把对象的状态从数据库中删除。然而你的应用可能还持有这个已山处对象的引用。所以，最好这样理解：delete()的用途是把一个持久实例变成瞬时(transient)实例。
p11-8-2 = 你可以用任何顺序删除对象，不会收到外键约束的制约。当然，如果你搞错了顺序，还是有可能引发在外键字段定义的NOT NULL约束冲突。 例如你删除了父对象，但是忘记删除孩子们。

#		**********************************************************************************************************
#		11.9. Replicating object between two different datastores
#		**********************************************************************************************************

title11-9 = 11.9. 两个不同的数据存储之间复制对象
p11-9-1 = 偶尔会用到不重新生成持久化标识(identifier)，将持久实例以及其关联的实例持久到不同的数据库中的操作。
p11-9-2 = <code>ReplicationMode</code>这种模式决定当数据库中存在冲突行时<code>replicate()</code>方法会怎样处理：
li11-9-1-1 = <code>ReplicationMode.IGNORE</code>: 忽略
li11-9-1-2 = <code>ReplicationMode.OVERWRITE</code>: 覆盖相同的行
li11-9-1-3 = <code>ReplicationMode.EXCEPTION</code>: 抛出异常
li11-9-1-4 = <code>ReplicationMode.LATEST_VERSION</code>: 如果当先版本较新，则覆盖，否则忽略
p11-9-3 = 这个功能的用途包括使录入的数据在不同数据库中一致，产品升级时升级系统配置信息，回滚non-ACID事务中的修改等等。

#		**********************************************************************************************************
#		11.10. Flushing the Session
#		**********************************************************************************************************

title11-10 = 11.10. Session刷新
p11-10-1 = 又是Session会执行SQL语句来是的内存中的对象与数据库同步。这个过程，叫做<code>flush</code>，在以下情况会默认发生：
li11-10-1-1 = 在一些查询操作之前
li11-10-1-2 = 在<code>org.hibernate.Transaction.commit()</code>方法执行之后
li11-10-1-3 = 在<code>Session.flush()</code>方法执行之后
p11-10-2 = 涉及的SQL语句会按照下面的顺序发出执行：
li11-10-2-1 = 所有对实体进行插入的语句，其顺序按照对象执行<code>Session.save()</code>的时间顺序
li11-10-2-2 = 所有实体执行更新语句
li11-10-2-3 = 所有集合执行删除语句
li11-10-2-4 = 所有集合的元素进行删除，更新和插入语句
li11-10-2-5 = 所有集合执行插入语句
li11-10-2-6 = 所有对实体进行删除的语句，其顺序按照对象执行<code>Session.delete()</code>的时间顺序
p11-10-3 = 有一个例外：对象使用<code>native</code>方式生成ID的话，它在执行save时就会被插入。
p11-10-4 = 除非你明确的执行了<code>flush()</code>方法，否则无法保证Session何时执行JDBC调用，只能确定它执行的顺序。但是，Hibernate可以保证<code>Query.list(..)</code>方法永远不会返回失效的或错误的数据。
p11-10-5 = 通过改变默认行为来减少flush执行的次数是可行的。<code>FlushMode</code>类定义了三种不同的模式：仅在提交时刷出(仅当Hibernate的Transaction API被使用时有效)，按照刚才说的方式刷出，以及除非明确使用<code>flush()</code>否则从不刷出。 最后一种模式对于那些需要长时间保持Session为打开或者断线状态的长时间运行的工作单元很有用。(查看 <a href="#c13-3-2">Section 13.3.2, \u201CExtended session and automatic versioning\u201D</a>).
p11-10-6 = 当flush时，有可能出现一个异常（比如，一个DML操作违反了一个约束）。由于异常处理包括一些有关事务行为的理解，我们将在<a href="#c13">Chapter 13, Transactions and Concurrency</a>讨论它。

#		**********************************************************************************************************
#		11.11. Transitive persistence
#		**********************************************************************************************************

title11-11 = 11.11. 持久化的传递性
p11-11-1 = 对每一个对象都要执行保存，删除或重关联操作让人感觉有点麻烦，尤其是在处理许多彼此关联的对象的时候。 一个常见的例子是父子关系。考虑下面的例子:
p11-11-2 = 如果一个父子关系中的子对象是值类型(value typed)（例如，地址或字符串的集合）的，他们的生命周期会依赖于父对象，可以享受方便的级联操作(Cascading)，不需要额外的动作。 父对象被保存时，这些值类型(value typed)子对象也将被保存；父对象被删除时，子对象也将被删除。 这对将一个子对象从集合中移除是同样有效：Hibernate会检测到，并且因为值类型(value typed)的对象不可能被其他对象引用，所以Hibernate会在数据库中删除这个子对象。
p11-11-3 = 现在考虑同样的场景，不过父子对象都是实体(entities)类型，而非值类型(value typed)（例如，类别与个体，或母猫和小猫）。 实体有自己的生命期，允许共享对其的引用（因此从集合中移除一个实体，不意味着它可以被删除）， 并且实体到其他关联实体之间默认没有级联操作的设置。 Hibernate默认不实现所谓的可到达即持久化（persistence by reachability）的策略。
p11-11-4 = 对于每一个Hibernate session的基本操作 - 包括<code>persist()</code>, <code>merge()</code>, <code>saveOrUpdate()</code>, <code>delete()</code>, <code>lock()</code>, <code>refresh()</code>, <code>evict()</code>, <code>replicate()</code>For each basic operation of the Hibernate session - including <code>persist()</code>, <code>merge()</code>, <code>saveOrUpdate()</code>, <code>delete()</code>, <code>lock()</code>, <code>refresh()</code>, <code>evict()</code>, <code>replicate()</code> - 都对应有一个级联风格。这些风格为：create, merge, save-update, delete, lock, refresh, evict, replicate。如果你希望一个操作执行相应的级联操作，你必须在映射文件中指明出来，比如：
p11-11-5 = 级联风格是可以组合的：
p11-11-6 = 你甚至可以使用<code>cascade="all"</code>来指明所有的操作都用相应的级联操作。默认时的<code>cascade="none"</code>指明没有操作会被级联。
p11-11-7 = 如果你使用注解的方式，那么你可能需要注意级联属性使用的是<code>CascadeType</code>数组中的值。JPA的级联概念与上面所说的持久化传递以及操作级联十分相近，但是在级联类型的语义上有些许的差别：
li11-11-1-1 = <code>CascadeType.PERSIST</code>: 做持久化(create)操作时的级联，即当相关的实体执行了<code>persist()</code>方法或者实体被管理时级联。
li11-11-1-2 = <code>CascadeType.MERGE</code>: 在做合并操作时级联，即当相关实体调用<code>merge()</code>方法时或者实体被管理时级联。
li11-11-1-3 = <code>CascadeType.REMOVE</code>: 在做删除操作时级联，即当相关实体调用<code>delete()</code>方法时级联。
li11-11-1-4 = <code>CascadeType.REFRESH</code>: 在做更新操作时级联，即当相关实体调用<code>refresh()</code>方法时级联。
li11-11-1-5 = <code>CascadeType.DETACH</code>: 在做分离操作时级联，即当相关实体调用<code>detach()</code>方法时级联。
li11-11-1-6 = <code>CascadeType.ALL</code>: 包括上面所有操作。
nc11-11-1 = <code>CascadeType.ALL</code>同样包含Hibernate一些特别的操作，比如<code>save-update</code>，<code>lock</code> 等。
p11-11-8 = 注意有一个特殊的级联风格(cascade style) delete-orphan，只应用于one-to-many关联，表明delete()操作 应该被应用于所有从关联中删除的对象。使用注解的话是没有<code>CascadeType.DELETE-ORPHAN</code>这一属性的。你可以使用例子<a href="#example-one-to-many-with-orphan-removal">Example 11.4, \u201C@OneToMany with orphanRemoval\u201D</a>中的<code>orphanRemoval</code>做相同的操作。如果一个实体从一个<code>@OneToMany</code>的集合中移除，或者一个相关的实体从一个<code>@OneToOne</code>的关系中解除，那么在orphanRemoval设为true的情况下，这个相关实体会被标记为删除。
p11-11-9 = 建议:
li11-11-2-1 = 通常情况下在多对一或多对多的情况下使用级联是没有意义的。实际上 <code>@ManyToOne</code>和<code>@ManyToMany</code>并没有<code>orphanRemoval</code>属性。级联通常对于一对一和一对多有用处。
li11-11-2-2 = 如果子对象的生命周期被绑定在父对象的生命周期之上，可以通过指定<code>cascade="all,delete-orphan" </code>来将其变为自动生命周期管理对象。
li11-11-2-3 = 其他情况下，你根本用不着级联。但是如果你认为你经常需要在一个事务中同时处理父和子，并且你希望少打点字，那么考虑使用<code>cascade="persist,merge,save-update"</code>。
p11-11-10 = 可以使用<code>cascade="all"</code>将一个关联关系（无论是对值对象的关联，或者对一个集合的关联）标记为父/子关系的关联。 这样对父对象进行save/update/delete操作就会导致子对象也进行save/update/delete操作。
p11-11-11 = 此外，一个持久的父对象对子对象的浅引用(mere reference)会导致子对象被同步<code>save/update</code>。 不过，这个隐喻(metaphor)的说法并不完整。除非关联是<code>&lt;one-to-many&gt;</code>关联并且被标记为<code>cascade="delete-orphan"</code>， 否则父对象失去对某个子对象的引用不会导致该子对象被自动删除。 父子关系的级联(cascading)操作准确语义如下：
li11-11-3-1 = 如果父对象被执行<code>persist()</code>操作，所有的子对象也会执行<code>persist()</code>。
li11-11-3-2 = 如果父对象被执行<code>merge()</code>操作，所有的子对象也会执行<code>merge()</code>。
li11-11-3-3 = 如果父对象被执行 <code>save()</code>, <code>update()</code> 或者 <code>saveOrUpdate()</code>，所有子对象都会执行<code>saveOrUpdate()</code>。
li11-11-3-4 = 如果某个持久的父对象引用了瞬时(transient)或者脱管(detached)的子对象，那么子对象将会被<code>saveOrUpdate()</code>
li11-11-3-5 = 如果父对象被删除，那么所有子对象也会被<code>delete()</code>
li11-11-3-6 = 除非被标记为<code>cascade="delete-orphan"</code>（删除“孤儿”模式，此时不被任何一个父对象引用的子对象会被删除）， 否则子对象失掉父对象对其的引用时，什么事也不会发生。 如果有特殊需要，应用程序可通过显式调用delete()删除子对象。
p11-11-12 = 最后，注意级联操作可能是在调用期间或者刷新期间作用到对象图上的。所有的操作，如果被允许，都在进行操作时级联到相关的实体上。然而，<code>save-update</code> 和 <code>delete-orphan</code>是在session刷新时才级联到相关的实体上。

#		**********************************************************************************************************
#		11.12. Using metadata
#		**********************************************************************************************************

title11-12 = 11.12. 使用元数据
p11-12-1 = Hibernate中有一个非常丰富的元级别(meta-level)的模型，含有所有的实体和值类型数据的元数据。 有时这个模型对应用程序本身也会非常有用。 比如说，应用程序可能在实现一种“智能”的深度拷贝算法时， 通过使用Hibernate的元数据来了解哪些对象应该被拷贝（比如，可变的值类型数据）， 那些不应该（不可变的值类型数据，也许还有某些被关联的实体）。
p11-12-2 = Hibernate提供了<code>ClassMetadata</code>接口，<code>CollectionMetadata</code>接口和Type层次体系来访问元数据。 可以通过SessionFactory获取元数据接口的实例。

