#preface
preface = 序言
# 1
c1 = 1. 教程
c1-1 = 1.1. 第一部分 - 第一个Hibernate应用
c1-1-1 = 1.1.1. 安装
c1-1-2 = 1.1.2. 第一个类
c1-1-3 = 1.1.3. 映射文件
c1-1-4 = 1.1.4. Hibernate 配置
c1-1-5 = 1.1.5. 使用Maven
c1-1-6 = 1.1.6. 启动和辅助
c1-1-7 = 1.1.7. 加载和存储对象
c1-2 = 1.2. 第二部分 - 关联映射
c1-2-1 = 1.2.1. 映射Person类
c1-2-2 = 1.2.2. 基于Set的单向关联
c1-2-3 = 1.2.3. 使关联工作
c1-2-4 = 1.2.4. 值的集合
c1-2-5 = 1.2.5. 双向关联
c1-2-6 = 1.2.6. 使双向关联工作
c1-3 = 1.3. 第三部分 - EventManager Web 应用
c1-3-1 = 1.3.1. 写一个基础的servlet
c1-3-2 = 1.3.2. 处理和渲染
c1-3-3 = 1.3.3. 部署和测试
c1-4 = 1.4. 总结
#2
c2 = 2. 体系结构
c2-1 = 2.1. 概览
c2-1-1 = 2.1.1. 最小的架构
c2-1-2 = 2.1.2. 复杂的架构
c2-1-3 = 2.1.3. 基础的API
c2-2 = 2.2. 会话上下文
#3
c3 = 3. 配置
c3-1 = 3.1. 代码配置
c3-2 = 3.2. 获取 SessionFactory
c3-3 = 3.3. JDBC 链接
c3-4 = 3.4. 可选的配置项
c3-4-1 = 3.4.1. SQL 方言
c3-4-2 = 3.4.2. 外连接抓取
c3-4-3 = 3.4.3. 二进制流
c3-4-4 = 3.4.4. 二级查询缓存
c3-4-5 = 3.4.5. 查询语言替换
c3-4-6 = 3.4.6. Hibernate 统计
c3-5 = 3.5. 日志
c3-6 = 3.6. 实现一个命名策略(NamingStrategy
c3-7 = 3.7. 实现一个PersisterClassProvider
c3-8 = 3.8. XML 配置文件
c3-9 = 3.9. Java EE 应用服务器集成
c3-9-1 = 3.9.1. 事务配置策略
c3-9-2 = 3.9.2. JNDI绑定SessionFactory
c3-9-3 = 3.9.3. JTA管理当前Session上下文
#4
c4 = 4. 持久化类
c4-1 = 4.1. 简单的POJO例子
c4-1-1 = 4.1.1. 实现一个无参构造函数
c4-1-2 = 4.1.2. 提供一个标示符属性
c4-1-3 = 4.1.3. 优先考虑非final的类（半可选）
c4-1-4 = 4.1.4. 为持久化字段声明函数和存取器（可选）
c4-2 = 4.2.  实现集成
c4-3 = 4.3. 实现equals()和hashCode()方法
c4-4 = 4.4. 动态模型
c4-5 = 4.5. 元组片段映射
c4-6 = 4.6. EntityNameResolvers
#5
c5 = 5. 基础的O/R 映射
c5-1 = 5.1. 映射定义
c5-1-1 = 5.1.1. 实体
c5-1-2 = 5.1.2. 标示符
c5-1-3 = 5.1.3. 乐观锁属性（可选）
c5-1-4 = 5.1.4. 属性
c5-1-5 = 5.1.5. 嵌入对象（又名”组件“）
c5-1-6 = 5.1.6. 继承策略
c5-1-7 = 5.1.7. 映射一对一和一对多关联
c5-1-8 = 5.1.8. Natural-id
c5-1-9 = 5.1.9. Any
c5-1-10 = 5.1.10. Properties
c5-1-11 = 5.1.11. 一些hbm.xml d的特殊性
c5-2 = 5.2. Hibernate 类型
c5-2-1 = 5.2.1. 实体和值
c5-2-2 = 5.2.2. 基本数据类型
c5-2-3 = 5.2.3. 自定义数据类型
c5-3 = 5.3. 多次映射同一个类
c5-4 = 5.4. SQL引用标示符
c5-5 = 5.5. 数据库生成属性
c5-6 = 5.6. 列的变化：读和写表达式
c5-7 = 5.7. 辅助数据库对象
#6
c6 = 6. 类型
c6-1 = 6.1. 值类型
c6-1-1 = 6.1.1. 基本值类型Basic value types
c6-1-2 = 6.1.2. 组合类型
c6-1-3 = 6.1.3. 结合类型
c6-2 = 6.2. 实体类型
c6-3 = 6.3. 类型分类的意义
c6-4 = 6.4. 自定义类型
c6-4-1 = 6.4.1. 使用org.hibernate.type.Type自定义类型
c6-4-2 = 6.4.2. 使用 org.hibernate.usertype.UserType自定义类型
c6-4-3 = 6.4.3. 使用org.hibernate.usertype.CompositeUserType自定义类型
c6-5 = 6.5. 类型注册
#7
c7 = 7.  集合映射
c7-1 = 7.1. 持久化集合
c7-2 = 7.2. 怎样映射集合
c7-2-1 = 7.2.1. 集合外键
c7-2-2 = 7.2.2. 集合索引
c7-2-3 = 7.2.3. 基础类型和可嵌入对象的集合
c7-3 = 7.3. 高级的集合映射
c7-3-1 = 7.3.1. 有序集合
c7-3-2 = 7.3.2. 双向关联
c7-3-3 = 7.3.3. 索引集合的双向关联
c7-3-4 = 7.3.4. 三重关联
c7-3-5 = 7.3.5. 使用 &lt;idbag&gt;
c7-4 = 7.4. 集合示例
#8
c8 = 8. 关联映射
c8-1 = 8.1. 介绍
c8-2 = 8.2. 单向关联
c8-2-1 = 8.2.1. Many-to-one
c8-2-2 = 8.2.2. One-to-one
c8-2-3 = 8.2.3. One-to-many
c8-3 = 8.3. 使用链接表的单向关联
c8-3-1 = 8.3.1. One-to-many
c8-3-2 = 8.3.2. Many-to-one
c8-3-3 = 8.3.3. One-to-one
c8-3-4 = 8.3.4. Many-to-many
c8-4 = 8.4. 双向关联
c8-4-1 = 8.4.1. one-to-many / many-to-one
c8-4-2 = 8.4.2. One-to-one
c8-5 = 8.5. 使用连接表的双向关联
c8-5-1 = 8.5.1. one-to-many / many-to-one
c8-5-2 = 8.5.2. one to one
c8-5-3 = 8.5.3. Many-to-many
c8-6 = 8.6. 更复杂的关联
#9
c9 = 9. 组件映射
c9-1 = 9.1. 依赖对象
c9-2 = 9.2. 集合中出现的依赖对象
c9-3 = 9.3. 组件作为Map索引
c9-4 = 9.4. 组件作为联合标示符
c9-5 = 9.5. 动态组件
#10
c10 = 10. 继承映射
c10-1 = 10.1. 三种策略
c10-1-1 = 10.1.1. 每个类层级一样表
c10-1-2 = 10.1.2. 每个子类一样表
c10-1-3 = 10.1.3. 每个子类一样表：使用辨别标示符
c10-1-4 = 10.1.4. ”每个子类一样表“和”每个类层级一张表“混合使用 
c10-1-5 = 10.1.5. 每个具体类一张表
c10-1-6 = 10.1.6. 使用隐式多态的每个具体类一张表 
c10-1-7 = 10.1.7. 隐式多态与其他继承映射混合使用 
c10-2 = 10.2. 局限性
#11
c11 = 11. 对象 
c11-1 = 11.1. Hibernate对象的状态
c11-2 = 11.2. 使对象持久化
c11-3 = 11.3. 加载一个对象
c11-4 = 11.4. 查询
c11-4-1 = 11.4.1. 执行查询
c11-4-2 = 11.4.2. 过滤集合
c11-4-3 = 11.4.3. 条件查询
c11-4-4 = 11.4.4. 原生SQL查询
c11-5 = 11.5. 修改持久化对象
c11-6 = 11.6. 修改游离对象
c11-7 = 11.7. 自动状态监测
c11-8 = 11.8. 删除游离对象
c11-9 = 11.9. 两个不同的数据存储之间复制对象
c11-10 = 11.10. Session刷新
c11-11 = 11.11. 持久化的传递性
c11-12 = 11.12. 使用元数据
#12
c12 = 12. 只读实体
c12-1 = 12.1. 使实体只读
c12-1-1 = 12.1.1. 不可变实体类
c12-1-2 = 12.1.2. 加载持久化数据位只读
c12-1-3 = 12.1.3. 使用Hql查询或者条件查询加载只读实体
c12-1-4 = 12.1.4. 把一个持久化实体变为只读
c12-2 = 12.2. 只读对属性类型的影响
c12-2-1 = 12.2.1. 简单属性
c12-2-2 = 12.2.2. 单向关联
c12-2-3 = 12.2.3. 双向关联
#13
c13 = 13. 事务和并行
c13-1 = 13.1. Session和事务的作用于
c13-1-1 = 13.1.1. 工作单元
c13-1-2 = 13.1.2. 长会话
c13-1-3 = 13.1.3. 关注对象标示符
c13-1-4 = 13.1.4. 常见问题
c13-2 = 13.2. 数据库事务界定
c13-2-1 = 13.2.1. 非管理环境
c13-2-2 = 13.2.2. 使用JTA
c13-2-3 = 13.2.3. 异常处理
c13-2-4 = 13.2.4. 事务超时
c13-3 = 13.3. 乐观并发控制
c13-3-1 = 13.3.1. 应用版本检查
c13-3-2 = 13.3.2. 延长会话和自动版本控制
c13-3-3 = 13.3.3. 游离的对象和自动版本控制
c13-3-4 = 13.3.4. 自定义自动版本控制
c13-4 = 13.4. 悲观锁
c13-5 = 13.5. 链接释放模式
#14
c14 = 14. 拦截器与事件
c14-1 = 14.1. 拦截器
c14-2 = 14.2. 事件系统
c14-3 = 14.3. Hibernate 安全声明
#15
c15 = 15. 批处理
c15-1 = 15.1. 批量插入
c15-2 = 15.2. 批量更新
c15-3 = 15.3. StatelessSession接口
c15-4 = 15.4. DML风格操作
#16
c16 = 16. HQL: Hibernate查询语言
c16-1 = 16.1. 大小写敏感
c16-2 = 16.2. 遵从条款
c16-3 = 16.3. 关联和连接
c16-4 = 16.4. 链接的语法格式
c16-5 = 16.5. 引用标示符属性
c16-6 = 16.6. select子句
c16-7 = 16.7. 聚合函数
c16-8 = 16.8. 多态查询
c16-9 = 16.9. where查询
c16-10 = 16.10. 表达式
c16-11 = 16.11. order by 子句
c16-12 = 16.12. group by子句
c16-13 = 16.13. 子查询
c16-14 = 16.14. HQL例子
c16-15 = 16.15. 批量更新和删除
c16-16 = 16.16. 提示和技巧
c16-17 = 16.17. 组件
c16-18 = 16.18. 行值构造语法
#17
c17 = 17. 条件查询
c17-1 = 17.1. 创建条件实例
c17-2 = 17.2. 限制结果集内容
c17-3 = 17.3. 结果集排序
c17-4 = 17.4. 关联
c17-5 = 17.5. 动态关联抓取
c17-6 = 17.6. 组件
c17-7 = 17.7. 集合
c17-8 = 17.8. 查询示例
c17-9 = 17.9. 投影聚合和分组
c17-10 = 17.10. 离线查询和子查询
c17-11 = 17.11. 根据自然标识查询r
#18
c18 = 18. 原生sql
c18-1 = 18.1. 使用SQLQuery
c18-1-1 = 18.1.1. 标量查询
c18-1-2 = 18.1.2. 实体查询
c18-1-3 = 18.1.3. 处理关联和集合
c18-1-4 = 18.1.4. 返回多个实体
c18-1-5 = 18.1.5. 返回不受管理的实体
c18-1-6 = 18.1.6. 处理继承
c18-1-7 = 18.1.7. 参数
c18-2 = 18.2. 命名SQL查询
c18-2-1 = 18.2.1. 使用return-property来显示的指定列名/别名
c18-2-2 = 18.2.2. 使用存储过程查询
c18-3 = 18.3. 定制SQL 来create, update 和delete
c18-4 = 18.4. 定制SQL来loading
#19
c19 = 19. 过滤数据
c19-1 = 19.1. Hibernate 过滤器
#20
c20 = 20. 提高性能
c20-1 = 20.1. 抓取策略
c20-1-1 = 20.1.1. 操作延迟加载关联
c20-1-2 = 20.1.2. 调整抓取策略
c20-1-3 = 20.1.3. 单向关联代理
c20-1-4 = 20.1.4. 初始化集合和代理
c20-1-5 = 20.1.5. 使用批量抓取
c20-1-6 = 20.1.6. 使用子查询抓取
c20-1-7 = 20.1.7. 抓取分析
c20-1-8 = 20.1.8. 使用延迟属性抓取
c20-2 = 20.2. 二级缓存
c20-2-1 = 20.2.1. 缓存映射
c20-2-2 = 20.2.2. 策略：只读
c20-2-3 = 20.2.3. 策略：读写
c20-2-4 = 20.2.4. 策略：非严格读写
c20-2-5 = 20.2.5. 策略：事务缓存
c20-2-6 = 20.2.6. 缓存提供者对缓存并发策略的支持情况
c20-3 = 20.3. 缓存管理
c20-4 = 20.4. 查询缓存
c20-4-1 = 20.4.1. 启用缓存查询
c20-4-2 = 20.4.2. 缓存查询区域
c20-5 = 20.5. 增强字节码
c20-5-1 = 20.5.1. 实现org.hibernate.engine.spi.ManagedEntity接口
c20-5-2 = 20.5.2. 运行时工具
c20-5-3 = 20.5.3. 构建时工具
c20-6 = 20.6. 理解集合类的性能
c20-6-1 = 20.6.1. 分类法
c20-6-2 = 20.6.2. Lists, maps, idbags 和sets 对于操作update都是非常有效的集合
c20-6-3 = 20.6.3. Bags 和lists是最有效的逆向集合
c20-6-4 = 20.6.4. 一次性删除
c20-7 = 20.7. 性能检测
c20-7-1 = 20.7.1. 检测 SessionFactory
c20-7-2 = 20.7.2. 度量
#21
c21 = 21. 工具集指南
c21-1 = 21.1. 自动模式生成
c21-1-1 = 21.1.1. 自定义模式
c21-1-2 = 21.1.2. 运行该工具
c21-1-3 = 21.1.3. 属性
c21-1-4 = 21.1.4. 使用Ant
c21-1-5 = 21.1.5. 模式的增量更新
c21-1-6 = 21.1.6. 使用Ant进行增量模式更新
c21-1-7 = 21.1.7. 模式验证
c21-1-8 = 21.1.8. 使用Ant进行模式验证
#22
c22 = 22. 附加模块
c22-1 = 22.1. 实体验证
c22-1-1 = 22.1.1. 添加实体验证
c22-1-2 = 22.1.2. 配置
c22-1-3 = 22.1.3. 验证捕获
c22-1-4 = 22.1.4. 数据库模式
c22-2 = 22.2. Hibernate查询
c22-2-1 = 22.2.1. 描述
c22-2-2 = 22.2.2. 集成Hibernate 注解
#23
c23 = 23. 示例: Parent/Child
c23-1 = 23.1. 关于集合的贴士
c23-2 = 23.2. 双向 one-to-many
c23-3 = 23.3. 级联生命周期
c23-4 = 23.4. 级联和unsaved-value
c23-5 = 23.5. 总结
#24
c24 = 24. 示例: Weblog 应用
c24-1 = 24.1. 持久化类
c24-2 = 24.2. Hibernate 映射
c24-3 = 24.3. Hibernate 代码
#25
c25 = 25. 示例: 多种映射
c25-1 = 25.1. Employer/Employee
c25-2 = 25.2. Author/Work
c25-3 = 25.3. Customer/Order/Product
c25-4 = 25.4. 其他映射
c25-4-1 = 25.4.1. 类型化 one-to-one 关联
c25-4-2 = 25.4.2. 组合键示例
c25-4-3 = 25.4.3. 共享组合键的Many-to-many
c25-4-4 = 25.4.4. 基于内容辨别
c25-4-5 = 25.4.5. 备用键之间的关联
#26
c26 = 26. 最佳实践
#27
c27 = 27. 数据库可移植性
c27-1 = 27.1. 可移植性基础
c27-2 = 27.2. 方言
c27-3 = 27.3. 方言解决方案
c27-4 = 27.4. 生成标示符
c27-5 = 27.5. 数据库函数
c27-6 = 27.6. 类型映射